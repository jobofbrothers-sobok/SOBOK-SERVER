
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model Customer
 * 
 */
export type Customer = {
  id: number
  loginId: string
  password: string
  name: string
  email: string
  phone: string
  termsAgree: boolean
  marketingAgree: boolean | null
  storeId: number | null
  image: string | null
  stampCount: number
  couponCount: number
}

/**
 * Model Delivery
 * 
 */
export type Delivery = {
  id: number
  reward: string
  customer: string
  phone: string
  address: string
  detailAddress: string | null
  message: string
  isGrant: boolean | null
  customerId: number
}

/**
 * Model Manager
 * 
 */
export type Manager = {
  id: number
  loginId: string
  password: string
}

/**
 * Model Stamp
 * 
 */
export type Stamp = {
  id: number
  randNum: string | null
  timestamp: Date | null
  customerId: number | null
  storeId: number | null
  store: string | null
  tourId: number | null
  tour: string | null
}

/**
 * Model Store
 * 
 */
export type Store = {
  id: number
  storeName: string
  description: string | null
  officeHour: string | null
  dayOff: string | null
  homepage: string | null
  image: string | null
  category: string[]
  ownerId: number
  tourId: number | null
  x: string | null
  y: string | null
}

/**
 * Model Store_Menu
 * 
 */
export type Store_Menu = {
  id: number
  title: string | null
  content: string | null
  image: string | null
  storeId: number | null
}

/**
 * Model Store_Notice
 * 
 */
export type Store_Notice = {
  id: number
  category: string | null
  title: string | null
  content: string | null
  image: string | null
  storeId: number | null
  createdTime: Date | null
}

/**
 * Model Store_Owner
 * 
 */
export type Store_Owner = {
  id: number
  loginId: string
  password: string | null
  store: string | null
  director: string | null
  phone: string | null
  email: string | null
  address: string | null
  detailAddress: string | null
  licenseNumber: string | null
  licenseImage: string
  authorized: boolean | null
  termsAgree: boolean | null
  marketingAgree: boolean | null
  storeId: number | null
  stampAuthorized: boolean | null
  profileImage: string | null
}

/**
 * Model Store_Product
 * 
 */
export type Store_Product = {
  id: number
  category: string | null
  name: string | null
  price: string | null
  discountPrice: string | null
  url: string | null
  image: string | null
  storeId: number | null
}

/**
 * Model Tour
 * 
 */
export type Tour = {
  id: number
  keyword: string
  title: string
  reward: string
  image: string | null
  cafeList: string[]
}

/**
 * Model Store_Review
 * 
 */
export type Store_Review = {
  id: number
  title: string | null
  content: string
  image: string | null
  timestamp: Date
  writerId: number
  storeId: number
  writerName: string
}

/**
 * Model Notice
 * 
 */
export type Notice = {
  id: number
  title: string
  content: string
  image: string | null
  timestamp: Date
}

/**
 * Model Alim_Customer
 * 
 */
export type Alim_Customer = {
  id: number
  loginId: string
  name: string | null
  phone: string
  customerId: number
  requestId: number
}

/**
 * Model Alim_Request
 * 
 */
export type Alim_Request = {
  id: number
  category: string
  content: string
  isMessage: boolean
  isKakao: boolean
  writerId: number
  timestamp: Date
}

/**
 * Model Stamp_Request
 * 
 */
export type Stamp_Request = {
  id: number
  ownerId: number
  isGrant: boolean
}

/**
 * Model Store_Like
 * 
 */
export type Store_Like = {
  id: number
  customerId: number
  storeId: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Customers
 * const customers = await prisma.customer.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Customers
   * const customers = await prisma.customer.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<GlobalReject>;

  /**
   * `prisma.delivery`: Exposes CRUD operations for the **Delivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deliveries
    * const deliveries = await prisma.delivery.findMany()
    * ```
    */
  get delivery(): Prisma.DeliveryDelegate<GlobalReject>;

  /**
   * `prisma.manager`: Exposes CRUD operations for the **Manager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Managers
    * const managers = await prisma.manager.findMany()
    * ```
    */
  get manager(): Prisma.ManagerDelegate<GlobalReject>;

  /**
   * `prisma.stamp`: Exposes CRUD operations for the **Stamp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stamps
    * const stamps = await prisma.stamp.findMany()
    * ```
    */
  get stamp(): Prisma.StampDelegate<GlobalReject>;

  /**
   * `prisma.store`: Exposes CRUD operations for the **Store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.StoreDelegate<GlobalReject>;

  /**
   * `prisma.store_Menu`: Exposes CRUD operations for the **Store_Menu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Store_Menus
    * const store_Menus = await prisma.store_Menu.findMany()
    * ```
    */
  get store_Menu(): Prisma.Store_MenuDelegate<GlobalReject>;

  /**
   * `prisma.store_Notice`: Exposes CRUD operations for the **Store_Notice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Store_Notices
    * const store_Notices = await prisma.store_Notice.findMany()
    * ```
    */
  get store_Notice(): Prisma.Store_NoticeDelegate<GlobalReject>;

  /**
   * `prisma.store_Owner`: Exposes CRUD operations for the **Store_Owner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Store_Owners
    * const store_Owners = await prisma.store_Owner.findMany()
    * ```
    */
  get store_Owner(): Prisma.Store_OwnerDelegate<GlobalReject>;

  /**
   * `prisma.store_Product`: Exposes CRUD operations for the **Store_Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Store_Products
    * const store_Products = await prisma.store_Product.findMany()
    * ```
    */
  get store_Product(): Prisma.Store_ProductDelegate<GlobalReject>;

  /**
   * `prisma.tour`: Exposes CRUD operations for the **Tour** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tours
    * const tours = await prisma.tour.findMany()
    * ```
    */
  get tour(): Prisma.TourDelegate<GlobalReject>;

  /**
   * `prisma.store_Review`: Exposes CRUD operations for the **Store_Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Store_Reviews
    * const store_Reviews = await prisma.store_Review.findMany()
    * ```
    */
  get store_Review(): Prisma.Store_ReviewDelegate<GlobalReject>;

  /**
   * `prisma.notice`: Exposes CRUD operations for the **Notice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notices
    * const notices = await prisma.notice.findMany()
    * ```
    */
  get notice(): Prisma.NoticeDelegate<GlobalReject>;

  /**
   * `prisma.alim_Customer`: Exposes CRUD operations for the **Alim_Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alim_Customers
    * const alim_Customers = await prisma.alim_Customer.findMany()
    * ```
    */
  get alim_Customer(): Prisma.Alim_CustomerDelegate<GlobalReject>;

  /**
   * `prisma.alim_Request`: Exposes CRUD operations for the **Alim_Request** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alim_Requests
    * const alim_Requests = await prisma.alim_Request.findMany()
    * ```
    */
  get alim_Request(): Prisma.Alim_RequestDelegate<GlobalReject>;

  /**
   * `prisma.stamp_Request`: Exposes CRUD operations for the **Stamp_Request** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stamp_Requests
    * const stamp_Requests = await prisma.stamp_Request.findMany()
    * ```
    */
  get stamp_Request(): Prisma.Stamp_RequestDelegate<GlobalReject>;

  /**
   * `prisma.store_Like`: Exposes CRUD operations for the **Store_Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Store_Likes
    * const store_Likes = await prisma.store_Like.findMany()
    * ```
    */
  get store_Like(): Prisma.Store_LikeDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.14.0
   * Query Engine version: d9a4c5988f480fa576d43970d5a23641aa77bc9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Customer: 'Customer',
    Delivery: 'Delivery',
    Manager: 'Manager',
    Stamp: 'Stamp',
    Store: 'Store',
    Store_Menu: 'Store_Menu',
    Store_Notice: 'Store_Notice',
    Store_Owner: 'Store_Owner',
    Store_Product: 'Store_Product',
    Tour: 'Tour',
    Store_Review: 'Store_Review',
    Notice: 'Notice',
    Alim_Customer: 'Alim_Customer',
    Alim_Request: 'Alim_Request',
    Stamp_Request: 'Stamp_Request',
    Store_Like: 'Store_Like'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CustomerCountOutputType
   */


  export type CustomerCountOutputType = {
    Alim_Customer: number
    Delivery: number
    Stamp: number
    Store_Like: number
    Store_Review: number
  }

  export type CustomerCountOutputTypeSelect = {
    Alim_Customer?: boolean
    Delivery?: boolean
    Stamp?: boolean
    Store_Like?: boolean
    Store_Review?: boolean
  }

  export type CustomerCountOutputTypeGetPayload<S extends boolean | null | undefined | CustomerCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CustomerCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CustomerCountOutputTypeArgs)
    ? CustomerCountOutputType 
    : S extends { select: any } & (CustomerCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CustomerCountOutputType ? CustomerCountOutputType[P] : never
  } 
      : CustomerCountOutputType




  // Custom InputTypes

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect | null
  }



  /**
   * Count Type StoreCountOutputType
   */


  export type StoreCountOutputType = {
    Customer: number
    Stamp: number
    Store_Like: number
    Store_Menu: number
    Store_Notice: number
    Store_Product: number
  }

  export type StoreCountOutputTypeSelect = {
    Customer?: boolean
    Stamp?: boolean
    Store_Like?: boolean
    Store_Menu?: boolean
    Store_Notice?: boolean
    Store_Product?: boolean
  }

  export type StoreCountOutputTypeGetPayload<S extends boolean | null | undefined | StoreCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? StoreCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (StoreCountOutputTypeArgs)
    ? StoreCountOutputType 
    : S extends { select: any } & (StoreCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof StoreCountOutputType ? StoreCountOutputType[P] : never
  } 
      : StoreCountOutputType




  // Custom InputTypes

  /**
   * StoreCountOutputType without action
   */
  export type StoreCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the StoreCountOutputType
     */
    select?: StoreCountOutputTypeSelect | null
  }



  /**
   * Count Type Store_OwnerCountOutputType
   */


  export type Store_OwnerCountOutputType = {
    Alim_Request: number
  }

  export type Store_OwnerCountOutputTypeSelect = {
    Alim_Request?: boolean
  }

  export type Store_OwnerCountOutputTypeGetPayload<S extends boolean | null | undefined | Store_OwnerCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Store_OwnerCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Store_OwnerCountOutputTypeArgs)
    ? Store_OwnerCountOutputType 
    : S extends { select: any } & (Store_OwnerCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Store_OwnerCountOutputType ? Store_OwnerCountOutputType[P] : never
  } 
      : Store_OwnerCountOutputType




  // Custom InputTypes

  /**
   * Store_OwnerCountOutputType without action
   */
  export type Store_OwnerCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Store_OwnerCountOutputType
     */
    select?: Store_OwnerCountOutputTypeSelect | null
  }



  /**
   * Count Type TourCountOutputType
   */


  export type TourCountOutputType = {
    Stamp: number
    Store: number
  }

  export type TourCountOutputTypeSelect = {
    Stamp?: boolean
    Store?: boolean
  }

  export type TourCountOutputTypeGetPayload<S extends boolean | null | undefined | TourCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TourCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TourCountOutputTypeArgs)
    ? TourCountOutputType 
    : S extends { select: any } & (TourCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TourCountOutputType ? TourCountOutputType[P] : never
  } 
      : TourCountOutputType




  // Custom InputTypes

  /**
   * TourCountOutputType without action
   */
  export type TourCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TourCountOutputType
     */
    select?: TourCountOutputTypeSelect | null
  }



  /**
   * Count Type Alim_RequestCountOutputType
   */


  export type Alim_RequestCountOutputType = {
    Alim_Customer: number
  }

  export type Alim_RequestCountOutputTypeSelect = {
    Alim_Customer?: boolean
  }

  export type Alim_RequestCountOutputTypeGetPayload<S extends boolean | null | undefined | Alim_RequestCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Alim_RequestCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Alim_RequestCountOutputTypeArgs)
    ? Alim_RequestCountOutputType 
    : S extends { select: any } & (Alim_RequestCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Alim_RequestCountOutputType ? Alim_RequestCountOutputType[P] : never
  } 
      : Alim_RequestCountOutputType




  // Custom InputTypes

  /**
   * Alim_RequestCountOutputType without action
   */
  export type Alim_RequestCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Alim_RequestCountOutputType
     */
    select?: Alim_RequestCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Customer
   */


  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
    storeId: number | null
    stampCount: number | null
    couponCount: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
    storeId: number | null
    stampCount: number | null
    couponCount: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    loginId: string | null
    password: string | null
    name: string | null
    email: string | null
    phone: string | null
    termsAgree: boolean | null
    marketingAgree: boolean | null
    storeId: number | null
    image: string | null
    stampCount: number | null
    couponCount: number | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    loginId: string | null
    password: string | null
    name: string | null
    email: string | null
    phone: string | null
    termsAgree: boolean | null
    marketingAgree: boolean | null
    storeId: number | null
    image: string | null
    stampCount: number | null
    couponCount: number | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    loginId: number
    password: number
    name: number
    email: number
    phone: number
    termsAgree: number
    marketingAgree: number
    storeId: number
    image: number
    stampCount: number
    couponCount: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
    storeId?: true
    stampCount?: true
    couponCount?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
    storeId?: true
    stampCount?: true
    couponCount?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    loginId?: true
    password?: true
    name?: true
    email?: true
    phone?: true
    termsAgree?: true
    marketingAgree?: true
    storeId?: true
    image?: true
    stampCount?: true
    couponCount?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    loginId?: true
    password?: true
    name?: true
    email?: true
    phone?: true
    termsAgree?: true
    marketingAgree?: true
    storeId?: true
    image?: true
    stampCount?: true
    couponCount?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    loginId?: true
    password?: true
    name?: true
    email?: true
    phone?: true
    termsAgree?: true
    marketingAgree?: true
    storeId?: true
    image?: true
    stampCount?: true
    couponCount?: true
    _all?: true
  }

  export type CustomerAggregateArgs = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs = {
    where?: CustomerWhereInput
    orderBy?: Enumerable<CustomerOrderByWithAggregationInput>
    by: CustomerScalarFieldEnum[]
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }


  export type CustomerGroupByOutputType = {
    id: number
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree: boolean | null
    storeId: number | null
    image: string | null
    stampCount: number
    couponCount: number
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect = {
    id?: boolean
    loginId?: boolean
    password?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    termsAgree?: boolean
    marketingAgree?: boolean
    storeId?: boolean
    image?: boolean
    stampCount?: boolean
    couponCount?: boolean
    Alim_Customer?: boolean | Customer$Alim_CustomerArgs
    Store?: boolean | StoreArgs
    Delivery?: boolean | Customer$DeliveryArgs
    Stamp?: boolean | Customer$StampArgs
    Store_Like?: boolean | Customer$Store_LikeArgs
    Store_Review?: boolean | Customer$Store_ReviewArgs
    _count?: boolean | CustomerCountOutputTypeArgs
  }


  export type CustomerInclude = {
    Alim_Customer?: boolean | Customer$Alim_CustomerArgs
    Store?: boolean | StoreArgs
    Delivery?: boolean | Customer$DeliveryArgs
    Stamp?: boolean | Customer$StampArgs
    Store_Like?: boolean | Customer$Store_LikeArgs
    Store_Review?: boolean | Customer$Store_ReviewArgs
    _count?: boolean | CustomerCountOutputTypeArgs
  }

  export type CustomerGetPayload<S extends boolean | null | undefined | CustomerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Customer :
    S extends undefined ? never :
    S extends { include: any } & (CustomerArgs | CustomerFindManyArgs)
    ? Customer  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Alim_Customer' ? Array < Alim_CustomerGetPayload<S['include'][P]>>  :
        P extends 'Store' ? StoreGetPayload<S['include'][P]> | null :
        P extends 'Delivery' ? Array < DeliveryGetPayload<S['include'][P]>>  :
        P extends 'Stamp' ? Array < StampGetPayload<S['include'][P]>>  :
        P extends 'Store_Like' ? Array < Store_LikeGetPayload<S['include'][P]>>  :
        P extends 'Store_Review' ? Array < Store_ReviewGetPayload<S['include'][P]>>  :
        P extends '_count' ? CustomerCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (CustomerArgs | CustomerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Alim_Customer' ? Array < Alim_CustomerGetPayload<S['select'][P]>>  :
        P extends 'Store' ? StoreGetPayload<S['select'][P]> | null :
        P extends 'Delivery' ? Array < DeliveryGetPayload<S['select'][P]>>  :
        P extends 'Stamp' ? Array < StampGetPayload<S['select'][P]>>  :
        P extends 'Store_Like' ? Array < Store_LikeGetPayload<S['select'][P]>>  :
        P extends 'Store_Review' ? Array < Store_ReviewGetPayload<S['select'][P]>>  :
        P extends '_count' ? CustomerCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Customer ? Customer[P] : never
  } 
      : Customer


  type CustomerCountArgs = 
    Omit<CustomerFindManyArgs, 'select' | 'include'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CustomerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Customer'> extends True ? Prisma__CustomerClient<CustomerGetPayload<T>> : Prisma__CustomerClient<CustomerGetPayload<T> | null, null>

    /**
     * Find one Customer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, CustomerFindUniqueOrThrowArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CustomerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Customer'> extends True ? Prisma__CustomerClient<CustomerGetPayload<T>> : Prisma__CustomerClient<CustomerGetPayload<T> | null, null>

    /**
     * Find the first Customer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CustomerFindFirstOrThrowArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerFindManyArgs>(
      args?: SelectSubset<T, CustomerFindManyArgs>
    ): Prisma.PrismaPromise<Array<CustomerGetPayload<T>>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
    **/
    create<T extends CustomerCreateArgs>(
      args: SelectSubset<T, CustomerCreateArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Create many Customers.
     *     @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customer = await prisma.customer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerCreateManyArgs>(
      args?: SelectSubset<T, CustomerCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
    **/
    delete<T extends CustomerDeleteArgs>(
      args: SelectSubset<T, CustomerDeleteArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerUpdateArgs>(
      args: SelectSubset<T, CustomerUpdateArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerDeleteManyArgs>(
      args?: SelectSubset<T, CustomerDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerUpdateManyArgs>(
      args: SelectSubset<T, CustomerUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerUpsertArgs>(
      args: SelectSubset<T, CustomerUpsertArgs>
    ): Prisma__CustomerClient<CustomerGetPayload<T>>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CustomerClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Alim_Customer<T extends Customer$Alim_CustomerArgs= {}>(args?: Subset<T, Customer$Alim_CustomerArgs>): Prisma.PrismaPromise<Array<Alim_CustomerGetPayload<T>>| Null>;

    Store<T extends StoreArgs= {}>(args?: Subset<T, StoreArgs>): Prisma__StoreClient<StoreGetPayload<T> | Null>;

    Delivery<T extends Customer$DeliveryArgs= {}>(args?: Subset<T, Customer$DeliveryArgs>): Prisma.PrismaPromise<Array<DeliveryGetPayload<T>>| Null>;

    Stamp<T extends Customer$StampArgs= {}>(args?: Subset<T, Customer$StampArgs>): Prisma.PrismaPromise<Array<StampGetPayload<T>>| Null>;

    Store_Like<T extends Customer$Store_LikeArgs= {}>(args?: Subset<T, Customer$Store_LikeArgs>): Prisma.PrismaPromise<Array<Store_LikeGetPayload<T>>| Null>;

    Store_Review<T extends Customer$Store_ReviewArgs= {}>(args?: Subset<T, Customer$Store_ReviewArgs>): Prisma.PrismaPromise<Array<Store_ReviewGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Customer base type for findUnique actions
   */
  export type CustomerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUnique
   */
  export interface CustomerFindUniqueArgs extends CustomerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer base type for findFirst actions
   */
  export type CustomerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }

  /**
   * Customer findFirst
   */
  export interface CustomerFindFirstArgs extends CustomerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Customer create
   */
  export type CustomerCreateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }


  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs = {
    /**
     * The data used to create many Customers.
     */
    data: Enumerable<CustomerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Customer update
   */
  export type CustomerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }


  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }


  /**
   * Customer delete
   */
  export type CustomerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }


  /**
   * Customer.Alim_Customer
   */
  export type Customer$Alim_CustomerArgs = {
    /**
     * Select specific fields to fetch from the Alim_Customer
     */
    select?: Alim_CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_CustomerInclude | null
    where?: Alim_CustomerWhereInput
    orderBy?: Enumerable<Alim_CustomerOrderByWithRelationInput>
    cursor?: Alim_CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Alim_CustomerScalarFieldEnum>
  }


  /**
   * Customer.Delivery
   */
  export type Customer$DeliveryArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude | null
    where?: DeliveryWhereInput
    orderBy?: Enumerable<DeliveryOrderByWithRelationInput>
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DeliveryScalarFieldEnum>
  }


  /**
   * Customer.Stamp
   */
  export type Customer$StampArgs = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StampInclude | null
    where?: StampWhereInput
    orderBy?: Enumerable<StampOrderByWithRelationInput>
    cursor?: StampWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StampScalarFieldEnum>
  }


  /**
   * Customer.Store_Like
   */
  export type Customer$Store_LikeArgs = {
    /**
     * Select specific fields to fetch from the Store_Like
     */
    select?: Store_LikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_LikeInclude | null
    where?: Store_LikeWhereInput
    orderBy?: Enumerable<Store_LikeOrderByWithRelationInput>
    cursor?: Store_LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Store_LikeScalarFieldEnum>
  }


  /**
   * Customer.Store_Review
   */
  export type Customer$Store_ReviewArgs = {
    /**
     * Select specific fields to fetch from the Store_Review
     */
    select?: Store_ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ReviewInclude | null
    where?: Store_ReviewWhereInput
    orderBy?: Enumerable<Store_ReviewOrderByWithRelationInput>
    cursor?: Store_ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Store_ReviewScalarFieldEnum>
  }


  /**
   * Customer without action
   */
  export type CustomerArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
  }



  /**
   * Model Delivery
   */


  export type AggregateDelivery = {
    _count: DeliveryCountAggregateOutputType | null
    _avg: DeliveryAvgAggregateOutputType | null
    _sum: DeliverySumAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  export type DeliveryAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type DeliverySumAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type DeliveryMinAggregateOutputType = {
    id: number | null
    reward: string | null
    customer: string | null
    phone: string | null
    address: string | null
    detailAddress: string | null
    message: string | null
    isGrant: boolean | null
    customerId: number | null
  }

  export type DeliveryMaxAggregateOutputType = {
    id: number | null
    reward: string | null
    customer: string | null
    phone: string | null
    address: string | null
    detailAddress: string | null
    message: string | null
    isGrant: boolean | null
    customerId: number | null
  }

  export type DeliveryCountAggregateOutputType = {
    id: number
    reward: number
    customer: number
    phone: number
    address: number
    detailAddress: number
    message: number
    isGrant: number
    customerId: number
    _all: number
  }


  export type DeliveryAvgAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type DeliverySumAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type DeliveryMinAggregateInputType = {
    id?: true
    reward?: true
    customer?: true
    phone?: true
    address?: true
    detailAddress?: true
    message?: true
    isGrant?: true
    customerId?: true
  }

  export type DeliveryMaxAggregateInputType = {
    id?: true
    reward?: true
    customer?: true
    phone?: true
    address?: true
    detailAddress?: true
    message?: true
    isGrant?: true
    customerId?: true
  }

  export type DeliveryCountAggregateInputType = {
    id?: true
    reward?: true
    customer?: true
    phone?: true
    address?: true
    detailAddress?: true
    message?: true
    isGrant?: true
    customerId?: true
    _all?: true
  }

  export type DeliveryAggregateArgs = {
    /**
     * Filter which Delivery to aggregate.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: Enumerable<DeliveryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deliveries
    **/
    _count?: true | DeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliverySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryMaxAggregateInputType
  }

  export type GetDeliveryAggregateType<T extends DeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelivery[P]>
      : GetScalarType<T[P], AggregateDelivery[P]>
  }




  export type DeliveryGroupByArgs = {
    where?: DeliveryWhereInput
    orderBy?: Enumerable<DeliveryOrderByWithAggregationInput>
    by: DeliveryScalarFieldEnum[]
    having?: DeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryCountAggregateInputType | true
    _avg?: DeliveryAvgAggregateInputType
    _sum?: DeliverySumAggregateInputType
    _min?: DeliveryMinAggregateInputType
    _max?: DeliveryMaxAggregateInputType
  }


  export type DeliveryGroupByOutputType = {
    id: number
    reward: string
    customer: string
    phone: string
    address: string
    detailAddress: string | null
    message: string
    isGrant: boolean | null
    customerId: number
    _count: DeliveryCountAggregateOutputType | null
    _avg: DeliveryAvgAggregateOutputType | null
    _sum: DeliverySumAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  type GetDeliveryGroupByPayload<T extends DeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
        }
      >
    >


  export type DeliverySelect = {
    id?: boolean
    reward?: boolean
    customer?: boolean
    phone?: boolean
    address?: boolean
    detailAddress?: boolean
    message?: boolean
    isGrant?: boolean
    customerId?: boolean
    Customer?: boolean | CustomerArgs
  }


  export type DeliveryInclude = {
    Customer?: boolean | CustomerArgs
  }

  export type DeliveryGetPayload<S extends boolean | null | undefined | DeliveryArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Delivery :
    S extends undefined ? never :
    S extends { include: any } & (DeliveryArgs | DeliveryFindManyArgs)
    ? Delivery  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Customer' ? CustomerGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (DeliveryArgs | DeliveryFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Customer' ? CustomerGetPayload<S['select'][P]> :  P extends keyof Delivery ? Delivery[P] : never
  } 
      : Delivery


  type DeliveryCountArgs = 
    Omit<DeliveryFindManyArgs, 'select' | 'include'> & {
      select?: DeliveryCountAggregateInputType | true
    }

  export interface DeliveryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Delivery that matches the filter.
     * @param {DeliveryFindUniqueArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeliveryFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeliveryFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Delivery'> extends True ? Prisma__DeliveryClient<DeliveryGetPayload<T>> : Prisma__DeliveryClient<DeliveryGetPayload<T> | null, null>

    /**
     * Find one Delivery that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DeliveryFindUniqueOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeliveryFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, DeliveryFindUniqueOrThrowArgs>
    ): Prisma__DeliveryClient<DeliveryGetPayload<T>>

    /**
     * Find the first Delivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeliveryFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeliveryFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Delivery'> extends True ? Prisma__DeliveryClient<DeliveryGetPayload<T>> : Prisma__DeliveryClient<DeliveryGetPayload<T> | null, null>

    /**
     * Find the first Delivery that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeliveryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, DeliveryFindFirstOrThrowArgs>
    ): Prisma__DeliveryClient<DeliveryGetPayload<T>>

    /**
     * Find zero or more Deliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deliveries
     * const deliveries = await prisma.delivery.findMany()
     * 
     * // Get first 10 Deliveries
     * const deliveries = await prisma.delivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryWithIdOnly = await prisma.delivery.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeliveryFindManyArgs>(
      args?: SelectSubset<T, DeliveryFindManyArgs>
    ): Prisma.PrismaPromise<Array<DeliveryGetPayload<T>>>

    /**
     * Create a Delivery.
     * @param {DeliveryCreateArgs} args - Arguments to create a Delivery.
     * @example
     * // Create one Delivery
     * const Delivery = await prisma.delivery.create({
     *   data: {
     *     // ... data to create a Delivery
     *   }
     * })
     * 
    **/
    create<T extends DeliveryCreateArgs>(
      args: SelectSubset<T, DeliveryCreateArgs>
    ): Prisma__DeliveryClient<DeliveryGetPayload<T>>

    /**
     * Create many Deliveries.
     *     @param {DeliveryCreateManyArgs} args - Arguments to create many Deliveries.
     *     @example
     *     // Create many Deliveries
     *     const delivery = await prisma.delivery.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeliveryCreateManyArgs>(
      args?: SelectSubset<T, DeliveryCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Delivery.
     * @param {DeliveryDeleteArgs} args - Arguments to delete one Delivery.
     * @example
     * // Delete one Delivery
     * const Delivery = await prisma.delivery.delete({
     *   where: {
     *     // ... filter to delete one Delivery
     *   }
     * })
     * 
    **/
    delete<T extends DeliveryDeleteArgs>(
      args: SelectSubset<T, DeliveryDeleteArgs>
    ): Prisma__DeliveryClient<DeliveryGetPayload<T>>

    /**
     * Update one Delivery.
     * @param {DeliveryUpdateArgs} args - Arguments to update one Delivery.
     * @example
     * // Update one Delivery
     * const delivery = await prisma.delivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeliveryUpdateArgs>(
      args: SelectSubset<T, DeliveryUpdateArgs>
    ): Prisma__DeliveryClient<DeliveryGetPayload<T>>

    /**
     * Delete zero or more Deliveries.
     * @param {DeliveryDeleteManyArgs} args - Arguments to filter Deliveries to delete.
     * @example
     * // Delete a few Deliveries
     * const { count } = await prisma.delivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeliveryDeleteManyArgs>(
      args?: SelectSubset<T, DeliveryDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deliveries
     * const delivery = await prisma.delivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeliveryUpdateManyArgs>(
      args: SelectSubset<T, DeliveryUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Delivery.
     * @param {DeliveryUpsertArgs} args - Arguments to update or create a Delivery.
     * @example
     * // Update or create a Delivery
     * const delivery = await prisma.delivery.upsert({
     *   create: {
     *     // ... data to create a Delivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delivery we want to update
     *   }
     * })
    **/
    upsert<T extends DeliveryUpsertArgs>(
      args: SelectSubset<T, DeliveryUpsertArgs>
    ): Prisma__DeliveryClient<DeliveryGetPayload<T>>

    /**
     * Count the number of Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryCountArgs} args - Arguments to filter Deliveries to count.
     * @example
     * // Count the number of Deliveries
     * const count = await prisma.delivery.count({
     *   where: {
     *     // ... the filter for the Deliveries we want to count
     *   }
     * })
    **/
    count<T extends DeliveryCountArgs>(
      args?: Subset<T, DeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryAggregateArgs>(args: Subset<T, DeliveryAggregateArgs>): Prisma.PrismaPromise<GetDeliveryAggregateType<T>>

    /**
     * Group by Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Delivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeliveryClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Customer<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Delivery base type for findUnique actions
   */
  export type DeliveryFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery findUnique
   */
  export interface DeliveryFindUniqueArgs extends DeliveryFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Delivery findUniqueOrThrow
   */
  export type DeliveryFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }


  /**
   * Delivery base type for findFirst actions
   */
  export type DeliveryFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: Enumerable<DeliveryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: Enumerable<DeliveryScalarFieldEnum>
  }

  /**
   * Delivery findFirst
   */
  export interface DeliveryFindFirstArgs extends DeliveryFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Delivery findFirstOrThrow
   */
  export type DeliveryFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: Enumerable<DeliveryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: Enumerable<DeliveryScalarFieldEnum>
  }


  /**
   * Delivery findMany
   */
  export type DeliveryFindManyArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude | null
    /**
     * Filter, which Deliveries to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: Enumerable<DeliveryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    distinct?: Enumerable<DeliveryScalarFieldEnum>
  }


  /**
   * Delivery create
   */
  export type DeliveryCreateArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude | null
    /**
     * The data needed to create a Delivery.
     */
    data: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
  }


  /**
   * Delivery createMany
   */
  export type DeliveryCreateManyArgs = {
    /**
     * The data used to create many Deliveries.
     */
    data: Enumerable<DeliveryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Delivery update
   */
  export type DeliveryUpdateArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude | null
    /**
     * The data needed to update a Delivery.
     */
    data: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
    /**
     * Choose, which Delivery to update.
     */
    where: DeliveryWhereUniqueInput
  }


  /**
   * Delivery updateMany
   */
  export type DeliveryUpdateManyArgs = {
    /**
     * The data used to update Deliveries.
     */
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyInput>
    /**
     * Filter which Deliveries to update
     */
    where?: DeliveryWhereInput
  }


  /**
   * Delivery upsert
   */
  export type DeliveryUpsertArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude | null
    /**
     * The filter to search for the Delivery to update in case it exists.
     */
    where: DeliveryWhereUniqueInput
    /**
     * In case the Delivery found by the `where` argument doesn't exist, create a new Delivery with this data.
     */
    create: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
    /**
     * In case the Delivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
  }


  /**
   * Delivery delete
   */
  export type DeliveryDeleteArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude | null
    /**
     * Filter which Delivery to delete.
     */
    where: DeliveryWhereUniqueInput
  }


  /**
   * Delivery deleteMany
   */
  export type DeliveryDeleteManyArgs = {
    /**
     * Filter which Deliveries to delete
     */
    where?: DeliveryWhereInput
  }


  /**
   * Delivery without action
   */
  export type DeliveryArgs = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DeliveryInclude | null
  }



  /**
   * Model Manager
   */


  export type AggregateManager = {
    _count: ManagerCountAggregateOutputType | null
    _avg: ManagerAvgAggregateOutputType | null
    _sum: ManagerSumAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  export type ManagerAvgAggregateOutputType = {
    id: number | null
  }

  export type ManagerSumAggregateOutputType = {
    id: number | null
  }

  export type ManagerMinAggregateOutputType = {
    id: number | null
    loginId: string | null
    password: string | null
  }

  export type ManagerMaxAggregateOutputType = {
    id: number | null
    loginId: string | null
    password: string | null
  }

  export type ManagerCountAggregateOutputType = {
    id: number
    loginId: number
    password: number
    _all: number
  }


  export type ManagerAvgAggregateInputType = {
    id?: true
  }

  export type ManagerSumAggregateInputType = {
    id?: true
  }

  export type ManagerMinAggregateInputType = {
    id?: true
    loginId?: true
    password?: true
  }

  export type ManagerMaxAggregateInputType = {
    id?: true
    loginId?: true
    password?: true
  }

  export type ManagerCountAggregateInputType = {
    id?: true
    loginId?: true
    password?: true
    _all?: true
  }

  export type ManagerAggregateArgs = {
    /**
     * Filter which Manager to aggregate.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: Enumerable<ManagerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Managers
    **/
    _count?: true | ManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManagerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManagerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManagerMaxAggregateInputType
  }

  export type GetManagerAggregateType<T extends ManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManager[P]>
      : GetScalarType<T[P], AggregateManager[P]>
  }




  export type ManagerGroupByArgs = {
    where?: ManagerWhereInput
    orderBy?: Enumerable<ManagerOrderByWithAggregationInput>
    by: ManagerScalarFieldEnum[]
    having?: ManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManagerCountAggregateInputType | true
    _avg?: ManagerAvgAggregateInputType
    _sum?: ManagerSumAggregateInputType
    _min?: ManagerMinAggregateInputType
    _max?: ManagerMaxAggregateInputType
  }


  export type ManagerGroupByOutputType = {
    id: number
    loginId: string
    password: string
    _count: ManagerCountAggregateOutputType | null
    _avg: ManagerAvgAggregateOutputType | null
    _sum: ManagerSumAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  type GetManagerGroupByPayload<T extends ManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManagerGroupByOutputType[P]>
            : GetScalarType<T[P], ManagerGroupByOutputType[P]>
        }
      >
    >


  export type ManagerSelect = {
    id?: boolean
    loginId?: boolean
    password?: boolean
  }


  export type ManagerGetPayload<S extends boolean | null | undefined | ManagerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Manager :
    S extends undefined ? never :
    S extends { include: any } & (ManagerArgs | ManagerFindManyArgs)
    ? Manager 
    : S extends { select: any } & (ManagerArgs | ManagerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Manager ? Manager[P] : never
  } 
      : Manager


  type ManagerCountArgs = 
    Omit<ManagerFindManyArgs, 'select' | 'include'> & {
      select?: ManagerCountAggregateInputType | true
    }

  export interface ManagerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Manager that matches the filter.
     * @param {ManagerFindUniqueArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ManagerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ManagerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Manager'> extends True ? Prisma__ManagerClient<ManagerGetPayload<T>> : Prisma__ManagerClient<ManagerGetPayload<T> | null, null>

    /**
     * Find one Manager that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ManagerFindUniqueOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ManagerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ManagerFindUniqueOrThrowArgs>
    ): Prisma__ManagerClient<ManagerGetPayload<T>>

    /**
     * Find the first Manager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ManagerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ManagerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Manager'> extends True ? Prisma__ManagerClient<ManagerGetPayload<T>> : Prisma__ManagerClient<ManagerGetPayload<T> | null, null>

    /**
     * Find the first Manager that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ManagerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ManagerFindFirstOrThrowArgs>
    ): Prisma__ManagerClient<ManagerGetPayload<T>>

    /**
     * Find zero or more Managers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Managers
     * const managers = await prisma.manager.findMany()
     * 
     * // Get first 10 Managers
     * const managers = await prisma.manager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const managerWithIdOnly = await prisma.manager.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ManagerFindManyArgs>(
      args?: SelectSubset<T, ManagerFindManyArgs>
    ): Prisma.PrismaPromise<Array<ManagerGetPayload<T>>>

    /**
     * Create a Manager.
     * @param {ManagerCreateArgs} args - Arguments to create a Manager.
     * @example
     * // Create one Manager
     * const Manager = await prisma.manager.create({
     *   data: {
     *     // ... data to create a Manager
     *   }
     * })
     * 
    **/
    create<T extends ManagerCreateArgs>(
      args: SelectSubset<T, ManagerCreateArgs>
    ): Prisma__ManagerClient<ManagerGetPayload<T>>

    /**
     * Create many Managers.
     *     @param {ManagerCreateManyArgs} args - Arguments to create many Managers.
     *     @example
     *     // Create many Managers
     *     const manager = await prisma.manager.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ManagerCreateManyArgs>(
      args?: SelectSubset<T, ManagerCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Manager.
     * @param {ManagerDeleteArgs} args - Arguments to delete one Manager.
     * @example
     * // Delete one Manager
     * const Manager = await prisma.manager.delete({
     *   where: {
     *     // ... filter to delete one Manager
     *   }
     * })
     * 
    **/
    delete<T extends ManagerDeleteArgs>(
      args: SelectSubset<T, ManagerDeleteArgs>
    ): Prisma__ManagerClient<ManagerGetPayload<T>>

    /**
     * Update one Manager.
     * @param {ManagerUpdateArgs} args - Arguments to update one Manager.
     * @example
     * // Update one Manager
     * const manager = await prisma.manager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ManagerUpdateArgs>(
      args: SelectSubset<T, ManagerUpdateArgs>
    ): Prisma__ManagerClient<ManagerGetPayload<T>>

    /**
     * Delete zero or more Managers.
     * @param {ManagerDeleteManyArgs} args - Arguments to filter Managers to delete.
     * @example
     * // Delete a few Managers
     * const { count } = await prisma.manager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ManagerDeleteManyArgs>(
      args?: SelectSubset<T, ManagerDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ManagerUpdateManyArgs>(
      args: SelectSubset<T, ManagerUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Manager.
     * @param {ManagerUpsertArgs} args - Arguments to update or create a Manager.
     * @example
     * // Update or create a Manager
     * const manager = await prisma.manager.upsert({
     *   create: {
     *     // ... data to create a Manager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manager we want to update
     *   }
     * })
    **/
    upsert<T extends ManagerUpsertArgs>(
      args: SelectSubset<T, ManagerUpsertArgs>
    ): Prisma__ManagerClient<ManagerGetPayload<T>>

    /**
     * Count the number of Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCountArgs} args - Arguments to filter Managers to count.
     * @example
     * // Count the number of Managers
     * const count = await prisma.manager.count({
     *   where: {
     *     // ... the filter for the Managers we want to count
     *   }
     * })
    **/
    count<T extends ManagerCountArgs>(
      args?: Subset<T, ManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagerAggregateArgs>(args: Subset<T, ManagerAggregateArgs>): Prisma.PrismaPromise<GetManagerAggregateType<T>>

    /**
     * Group by Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManagerGroupByArgs['orderBy'] }
        : { orderBy?: ManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Manager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ManagerClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Manager base type for findUnique actions
   */
  export type ManagerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findUnique
   */
  export interface ManagerFindUniqueArgs extends ManagerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Manager findUniqueOrThrow
   */
  export type ManagerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }


  /**
   * Manager base type for findFirst actions
   */
  export type ManagerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: Enumerable<ManagerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: Enumerable<ManagerScalarFieldEnum>
  }

  /**
   * Manager findFirst
   */
  export interface ManagerFindFirstArgs extends ManagerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Manager findFirstOrThrow
   */
  export type ManagerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: Enumerable<ManagerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: Enumerable<ManagerScalarFieldEnum>
  }


  /**
   * Manager findMany
   */
  export type ManagerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect | null
    /**
     * Filter, which Managers to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: Enumerable<ManagerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    distinct?: Enumerable<ManagerScalarFieldEnum>
  }


  /**
   * Manager create
   */
  export type ManagerCreateArgs = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect | null
    /**
     * The data needed to create a Manager.
     */
    data: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
  }


  /**
   * Manager createMany
   */
  export type ManagerCreateManyArgs = {
    /**
     * The data used to create many Managers.
     */
    data: Enumerable<ManagerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Manager update
   */
  export type ManagerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect | null
    /**
     * The data needed to update a Manager.
     */
    data: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
    /**
     * Choose, which Manager to update.
     */
    where: ManagerWhereUniqueInput
  }


  /**
   * Manager updateMany
   */
  export type ManagerUpdateManyArgs = {
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
  }


  /**
   * Manager upsert
   */
  export type ManagerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect | null
    /**
     * The filter to search for the Manager to update in case it exists.
     */
    where: ManagerWhereUniqueInput
    /**
     * In case the Manager found by the `where` argument doesn't exist, create a new Manager with this data.
     */
    create: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
    /**
     * In case the Manager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
  }


  /**
   * Manager delete
   */
  export type ManagerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect | null
    /**
     * Filter which Manager to delete.
     */
    where: ManagerWhereUniqueInput
  }


  /**
   * Manager deleteMany
   */
  export type ManagerDeleteManyArgs = {
    /**
     * Filter which Managers to delete
     */
    where?: ManagerWhereInput
  }


  /**
   * Manager without action
   */
  export type ManagerArgs = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect | null
  }



  /**
   * Model Stamp
   */


  export type AggregateStamp = {
    _count: StampCountAggregateOutputType | null
    _avg: StampAvgAggregateOutputType | null
    _sum: StampSumAggregateOutputType | null
    _min: StampMinAggregateOutputType | null
    _max: StampMaxAggregateOutputType | null
  }

  export type StampAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    storeId: number | null
    tourId: number | null
  }

  export type StampSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    storeId: number | null
    tourId: number | null
  }

  export type StampMinAggregateOutputType = {
    id: number | null
    randNum: string | null
    timestamp: Date | null
    customerId: number | null
    storeId: number | null
    store: string | null
    tourId: number | null
    tour: string | null
  }

  export type StampMaxAggregateOutputType = {
    id: number | null
    randNum: string | null
    timestamp: Date | null
    customerId: number | null
    storeId: number | null
    store: string | null
    tourId: number | null
    tour: string | null
  }

  export type StampCountAggregateOutputType = {
    id: number
    randNum: number
    timestamp: number
    customerId: number
    storeId: number
    store: number
    tourId: number
    tour: number
    _all: number
  }


  export type StampAvgAggregateInputType = {
    id?: true
    customerId?: true
    storeId?: true
    tourId?: true
  }

  export type StampSumAggregateInputType = {
    id?: true
    customerId?: true
    storeId?: true
    tourId?: true
  }

  export type StampMinAggregateInputType = {
    id?: true
    randNum?: true
    timestamp?: true
    customerId?: true
    storeId?: true
    store?: true
    tourId?: true
    tour?: true
  }

  export type StampMaxAggregateInputType = {
    id?: true
    randNum?: true
    timestamp?: true
    customerId?: true
    storeId?: true
    store?: true
    tourId?: true
    tour?: true
  }

  export type StampCountAggregateInputType = {
    id?: true
    randNum?: true
    timestamp?: true
    customerId?: true
    storeId?: true
    store?: true
    tourId?: true
    tour?: true
    _all?: true
  }

  export type StampAggregateArgs = {
    /**
     * Filter which Stamp to aggregate.
     */
    where?: StampWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stamps to fetch.
     */
    orderBy?: Enumerable<StampOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StampWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stamps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stamps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stamps
    **/
    _count?: true | StampCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StampAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StampSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StampMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StampMaxAggregateInputType
  }

  export type GetStampAggregateType<T extends StampAggregateArgs> = {
        [P in keyof T & keyof AggregateStamp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStamp[P]>
      : GetScalarType<T[P], AggregateStamp[P]>
  }




  export type StampGroupByArgs = {
    where?: StampWhereInput
    orderBy?: Enumerable<StampOrderByWithAggregationInput>
    by: StampScalarFieldEnum[]
    having?: StampScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StampCountAggregateInputType | true
    _avg?: StampAvgAggregateInputType
    _sum?: StampSumAggregateInputType
    _min?: StampMinAggregateInputType
    _max?: StampMaxAggregateInputType
  }


  export type StampGroupByOutputType = {
    id: number
    randNum: string | null
    timestamp: Date | null
    customerId: number | null
    storeId: number | null
    store: string | null
    tourId: number | null
    tour: string | null
    _count: StampCountAggregateOutputType | null
    _avg: StampAvgAggregateOutputType | null
    _sum: StampSumAggregateOutputType | null
    _min: StampMinAggregateOutputType | null
    _max: StampMaxAggregateOutputType | null
  }

  type GetStampGroupByPayload<T extends StampGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<StampGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StampGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StampGroupByOutputType[P]>
            : GetScalarType<T[P], StampGroupByOutputType[P]>
        }
      >
    >


  export type StampSelect = {
    id?: boolean
    randNum?: boolean
    timestamp?: boolean
    customerId?: boolean
    storeId?: boolean
    store?: boolean
    tourId?: boolean
    tour?: boolean
    Customer?: boolean | CustomerArgs
    Store?: boolean | StoreArgs
    Tour?: boolean | TourArgs
  }


  export type StampInclude = {
    Customer?: boolean | CustomerArgs
    Store?: boolean | StoreArgs
    Tour?: boolean | TourArgs
  }

  export type StampGetPayload<S extends boolean | null | undefined | StampArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Stamp :
    S extends undefined ? never :
    S extends { include: any } & (StampArgs | StampFindManyArgs)
    ? Stamp  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Customer' ? CustomerGetPayload<S['include'][P]> | null :
        P extends 'Store' ? StoreGetPayload<S['include'][P]> | null :
        P extends 'Tour' ? TourGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (StampArgs | StampFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Customer' ? CustomerGetPayload<S['select'][P]> | null :
        P extends 'Store' ? StoreGetPayload<S['select'][P]> | null :
        P extends 'Tour' ? TourGetPayload<S['select'][P]> | null :  P extends keyof Stamp ? Stamp[P] : never
  } 
      : Stamp


  type StampCountArgs = 
    Omit<StampFindManyArgs, 'select' | 'include'> & {
      select?: StampCountAggregateInputType | true
    }

  export interface StampDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Stamp that matches the filter.
     * @param {StampFindUniqueArgs} args - Arguments to find a Stamp
     * @example
     * // Get one Stamp
     * const stamp = await prisma.stamp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StampFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StampFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Stamp'> extends True ? Prisma__StampClient<StampGetPayload<T>> : Prisma__StampClient<StampGetPayload<T> | null, null>

    /**
     * Find one Stamp that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StampFindUniqueOrThrowArgs} args - Arguments to find a Stamp
     * @example
     * // Get one Stamp
     * const stamp = await prisma.stamp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StampFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StampFindUniqueOrThrowArgs>
    ): Prisma__StampClient<StampGetPayload<T>>

    /**
     * Find the first Stamp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampFindFirstArgs} args - Arguments to find a Stamp
     * @example
     * // Get one Stamp
     * const stamp = await prisma.stamp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StampFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StampFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Stamp'> extends True ? Prisma__StampClient<StampGetPayload<T>> : Prisma__StampClient<StampGetPayload<T> | null, null>

    /**
     * Find the first Stamp that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampFindFirstOrThrowArgs} args - Arguments to find a Stamp
     * @example
     * // Get one Stamp
     * const stamp = await prisma.stamp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StampFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StampFindFirstOrThrowArgs>
    ): Prisma__StampClient<StampGetPayload<T>>

    /**
     * Find zero or more Stamps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stamps
     * const stamps = await prisma.stamp.findMany()
     * 
     * // Get first 10 Stamps
     * const stamps = await prisma.stamp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stampWithIdOnly = await prisma.stamp.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StampFindManyArgs>(
      args?: SelectSubset<T, StampFindManyArgs>
    ): Prisma.PrismaPromise<Array<StampGetPayload<T>>>

    /**
     * Create a Stamp.
     * @param {StampCreateArgs} args - Arguments to create a Stamp.
     * @example
     * // Create one Stamp
     * const Stamp = await prisma.stamp.create({
     *   data: {
     *     // ... data to create a Stamp
     *   }
     * })
     * 
    **/
    create<T extends StampCreateArgs>(
      args: SelectSubset<T, StampCreateArgs>
    ): Prisma__StampClient<StampGetPayload<T>>

    /**
     * Create many Stamps.
     *     @param {StampCreateManyArgs} args - Arguments to create many Stamps.
     *     @example
     *     // Create many Stamps
     *     const stamp = await prisma.stamp.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StampCreateManyArgs>(
      args?: SelectSubset<T, StampCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stamp.
     * @param {StampDeleteArgs} args - Arguments to delete one Stamp.
     * @example
     * // Delete one Stamp
     * const Stamp = await prisma.stamp.delete({
     *   where: {
     *     // ... filter to delete one Stamp
     *   }
     * })
     * 
    **/
    delete<T extends StampDeleteArgs>(
      args: SelectSubset<T, StampDeleteArgs>
    ): Prisma__StampClient<StampGetPayload<T>>

    /**
     * Update one Stamp.
     * @param {StampUpdateArgs} args - Arguments to update one Stamp.
     * @example
     * // Update one Stamp
     * const stamp = await prisma.stamp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StampUpdateArgs>(
      args: SelectSubset<T, StampUpdateArgs>
    ): Prisma__StampClient<StampGetPayload<T>>

    /**
     * Delete zero or more Stamps.
     * @param {StampDeleteManyArgs} args - Arguments to filter Stamps to delete.
     * @example
     * // Delete a few Stamps
     * const { count } = await prisma.stamp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StampDeleteManyArgs>(
      args?: SelectSubset<T, StampDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stamps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stamps
     * const stamp = await prisma.stamp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StampUpdateManyArgs>(
      args: SelectSubset<T, StampUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stamp.
     * @param {StampUpsertArgs} args - Arguments to update or create a Stamp.
     * @example
     * // Update or create a Stamp
     * const stamp = await prisma.stamp.upsert({
     *   create: {
     *     // ... data to create a Stamp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stamp we want to update
     *   }
     * })
    **/
    upsert<T extends StampUpsertArgs>(
      args: SelectSubset<T, StampUpsertArgs>
    ): Prisma__StampClient<StampGetPayload<T>>

    /**
     * Count the number of Stamps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampCountArgs} args - Arguments to filter Stamps to count.
     * @example
     * // Count the number of Stamps
     * const count = await prisma.stamp.count({
     *   where: {
     *     // ... the filter for the Stamps we want to count
     *   }
     * })
    **/
    count<T extends StampCountArgs>(
      args?: Subset<T, StampCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StampCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stamp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StampAggregateArgs>(args: Subset<T, StampAggregateArgs>): Prisma.PrismaPromise<GetStampAggregateType<T>>

    /**
     * Group by Stamp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StampGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StampGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StampGroupByArgs['orderBy'] }
        : { orderBy?: StampGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StampGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStampGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Stamp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StampClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Customer<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    Store<T extends StoreArgs= {}>(args?: Subset<T, StoreArgs>): Prisma__StoreClient<StoreGetPayload<T> | Null>;

    Tour<T extends TourArgs= {}>(args?: Subset<T, TourArgs>): Prisma__TourClient<TourGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Stamp base type for findUnique actions
   */
  export type StampFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StampInclude | null
    /**
     * Filter, which Stamp to fetch.
     */
    where: StampWhereUniqueInput
  }

  /**
   * Stamp findUnique
   */
  export interface StampFindUniqueArgs extends StampFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Stamp findUniqueOrThrow
   */
  export type StampFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StampInclude | null
    /**
     * Filter, which Stamp to fetch.
     */
    where: StampWhereUniqueInput
  }


  /**
   * Stamp base type for findFirst actions
   */
  export type StampFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StampInclude | null
    /**
     * Filter, which Stamp to fetch.
     */
    where?: StampWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stamps to fetch.
     */
    orderBy?: Enumerable<StampOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stamps.
     */
    cursor?: StampWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stamps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stamps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stamps.
     */
    distinct?: Enumerable<StampScalarFieldEnum>
  }

  /**
   * Stamp findFirst
   */
  export interface StampFindFirstArgs extends StampFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Stamp findFirstOrThrow
   */
  export type StampFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StampInclude | null
    /**
     * Filter, which Stamp to fetch.
     */
    where?: StampWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stamps to fetch.
     */
    orderBy?: Enumerable<StampOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stamps.
     */
    cursor?: StampWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stamps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stamps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stamps.
     */
    distinct?: Enumerable<StampScalarFieldEnum>
  }


  /**
   * Stamp findMany
   */
  export type StampFindManyArgs = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StampInclude | null
    /**
     * Filter, which Stamps to fetch.
     */
    where?: StampWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stamps to fetch.
     */
    orderBy?: Enumerable<StampOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stamps.
     */
    cursor?: StampWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stamps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stamps.
     */
    skip?: number
    distinct?: Enumerable<StampScalarFieldEnum>
  }


  /**
   * Stamp create
   */
  export type StampCreateArgs = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StampInclude | null
    /**
     * The data needed to create a Stamp.
     */
    data: XOR<StampCreateInput, StampUncheckedCreateInput>
  }


  /**
   * Stamp createMany
   */
  export type StampCreateManyArgs = {
    /**
     * The data used to create many Stamps.
     */
    data: Enumerable<StampCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Stamp update
   */
  export type StampUpdateArgs = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StampInclude | null
    /**
     * The data needed to update a Stamp.
     */
    data: XOR<StampUpdateInput, StampUncheckedUpdateInput>
    /**
     * Choose, which Stamp to update.
     */
    where: StampWhereUniqueInput
  }


  /**
   * Stamp updateMany
   */
  export type StampUpdateManyArgs = {
    /**
     * The data used to update Stamps.
     */
    data: XOR<StampUpdateManyMutationInput, StampUncheckedUpdateManyInput>
    /**
     * Filter which Stamps to update
     */
    where?: StampWhereInput
  }


  /**
   * Stamp upsert
   */
  export type StampUpsertArgs = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StampInclude | null
    /**
     * The filter to search for the Stamp to update in case it exists.
     */
    where: StampWhereUniqueInput
    /**
     * In case the Stamp found by the `where` argument doesn't exist, create a new Stamp with this data.
     */
    create: XOR<StampCreateInput, StampUncheckedCreateInput>
    /**
     * In case the Stamp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StampUpdateInput, StampUncheckedUpdateInput>
  }


  /**
   * Stamp delete
   */
  export type StampDeleteArgs = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StampInclude | null
    /**
     * Filter which Stamp to delete.
     */
    where: StampWhereUniqueInput
  }


  /**
   * Stamp deleteMany
   */
  export type StampDeleteManyArgs = {
    /**
     * Filter which Stamps to delete
     */
    where?: StampWhereInput
  }


  /**
   * Stamp without action
   */
  export type StampArgs = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StampInclude | null
  }



  /**
   * Model Store
   */


  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
    tourId: number | null
  }

  export type StoreSumAggregateOutputType = {
    id: number | null
    ownerId: number | null
    tourId: number | null
  }

  export type StoreMinAggregateOutputType = {
    id: number | null
    storeName: string | null
    description: string | null
    officeHour: string | null
    dayOff: string | null
    homepage: string | null
    image: string | null
    ownerId: number | null
    tourId: number | null
    x: string | null
    y: string | null
  }

  export type StoreMaxAggregateOutputType = {
    id: number | null
    storeName: string | null
    description: string | null
    officeHour: string | null
    dayOff: string | null
    homepage: string | null
    image: string | null
    ownerId: number | null
    tourId: number | null
    x: string | null
    y: string | null
  }

  export type StoreCountAggregateOutputType = {
    id: number
    storeName: number
    description: number
    officeHour: number
    dayOff: number
    homepage: number
    image: number
    category: number
    ownerId: number
    tourId: number
    x: number
    y: number
    _all: number
  }


  export type StoreAvgAggregateInputType = {
    id?: true
    ownerId?: true
    tourId?: true
  }

  export type StoreSumAggregateInputType = {
    id?: true
    ownerId?: true
    tourId?: true
  }

  export type StoreMinAggregateInputType = {
    id?: true
    storeName?: true
    description?: true
    officeHour?: true
    dayOff?: true
    homepage?: true
    image?: true
    ownerId?: true
    tourId?: true
    x?: true
    y?: true
  }

  export type StoreMaxAggregateInputType = {
    id?: true
    storeName?: true
    description?: true
    officeHour?: true
    dayOff?: true
    homepage?: true
    image?: true
    ownerId?: true
    tourId?: true
    x?: true
    y?: true
  }

  export type StoreCountAggregateInputType = {
    id?: true
    storeName?: true
    description?: true
    officeHour?: true
    dayOff?: true
    homepage?: true
    image?: true
    category?: true
    ownerId?: true
    tourId?: true
    x?: true
    y?: true
    _all?: true
  }

  export type StoreAggregateArgs = {
    /**
     * Filter which Store to aggregate.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: Enumerable<StoreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type StoreGroupByArgs = {
    where?: StoreWhereInput
    orderBy?: Enumerable<StoreOrderByWithAggregationInput>
    by: StoreScalarFieldEnum[]
    having?: StoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _avg?: StoreAvgAggregateInputType
    _sum?: StoreSumAggregateInputType
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }


  export type StoreGroupByOutputType = {
    id: number
    storeName: string
    description: string | null
    officeHour: string | null
    dayOff: string | null
    homepage: string | null
    image: string | null
    category: string[]
    ownerId: number
    tourId: number | null
    x: string | null
    y: string | null
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends StoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type StoreSelect = {
    id?: boolean
    storeName?: boolean
    description?: boolean
    officeHour?: boolean
    dayOff?: boolean
    homepage?: boolean
    image?: boolean
    category?: boolean
    ownerId?: boolean
    tourId?: boolean
    x?: boolean
    y?: boolean
    Customer?: boolean | Store$CustomerArgs
    Stamp?: boolean | Store$StampArgs
    Store_Owner_Store_ownerIdToStore_Owner?: boolean | Store_OwnerArgs
    Tour?: boolean | TourArgs
    Store_Like?: boolean | Store$Store_LikeArgs
    Store_Menu?: boolean | Store$Store_MenuArgs
    Store_Notice?: boolean | Store$Store_NoticeArgs
    Store_Owner_Store_Owner_storeIdToStore?: boolean | Store_OwnerArgs
    Store_Product?: boolean | Store$Store_ProductArgs
    Store_Review?: boolean | Store_ReviewArgs
    _count?: boolean | StoreCountOutputTypeArgs
  }


  export type StoreInclude = {
    Customer?: boolean | Store$CustomerArgs
    Stamp?: boolean | Store$StampArgs
    Store_Owner_Store_ownerIdToStore_Owner?: boolean | Store_OwnerArgs
    Tour?: boolean | TourArgs
    Store_Like?: boolean | Store$Store_LikeArgs
    Store_Menu?: boolean | Store$Store_MenuArgs
    Store_Notice?: boolean | Store$Store_NoticeArgs
    Store_Owner_Store_Owner_storeIdToStore?: boolean | Store_OwnerArgs
    Store_Product?: boolean | Store$Store_ProductArgs
    Store_Review?: boolean | Store_ReviewArgs
    _count?: boolean | StoreCountOutputTypeArgs
  }

  export type StoreGetPayload<S extends boolean | null | undefined | StoreArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Store :
    S extends undefined ? never :
    S extends { include: any } & (StoreArgs | StoreFindManyArgs)
    ? Store  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Customer' ? Array < CustomerGetPayload<S['include'][P]>>  :
        P extends 'Stamp' ? Array < StampGetPayload<S['include'][P]>>  :
        P extends 'Store_Owner_Store_ownerIdToStore_Owner' ? Store_OwnerGetPayload<S['include'][P]> :
        P extends 'Tour' ? TourGetPayload<S['include'][P]> | null :
        P extends 'Store_Like' ? Array < Store_LikeGetPayload<S['include'][P]>>  :
        P extends 'Store_Menu' ? Array < Store_MenuGetPayload<S['include'][P]>>  :
        P extends 'Store_Notice' ? Array < Store_NoticeGetPayload<S['include'][P]>>  :
        P extends 'Store_Owner_Store_Owner_storeIdToStore' ? Store_OwnerGetPayload<S['include'][P]> | null :
        P extends 'Store_Product' ? Array < Store_ProductGetPayload<S['include'][P]>>  :
        P extends 'Store_Review' ? Store_ReviewGetPayload<S['include'][P]> | null :
        P extends '_count' ? StoreCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (StoreArgs | StoreFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Customer' ? Array < CustomerGetPayload<S['select'][P]>>  :
        P extends 'Stamp' ? Array < StampGetPayload<S['select'][P]>>  :
        P extends 'Store_Owner_Store_ownerIdToStore_Owner' ? Store_OwnerGetPayload<S['select'][P]> :
        P extends 'Tour' ? TourGetPayload<S['select'][P]> | null :
        P extends 'Store_Like' ? Array < Store_LikeGetPayload<S['select'][P]>>  :
        P extends 'Store_Menu' ? Array < Store_MenuGetPayload<S['select'][P]>>  :
        P extends 'Store_Notice' ? Array < Store_NoticeGetPayload<S['select'][P]>>  :
        P extends 'Store_Owner_Store_Owner_storeIdToStore' ? Store_OwnerGetPayload<S['select'][P]> | null :
        P extends 'Store_Product' ? Array < Store_ProductGetPayload<S['select'][P]>>  :
        P extends 'Store_Review' ? Store_ReviewGetPayload<S['select'][P]> | null :
        P extends '_count' ? StoreCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Store ? Store[P] : never
  } 
      : Store


  type StoreCountArgs = 
    Omit<StoreFindManyArgs, 'select' | 'include'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface StoreDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Store that matches the filter.
     * @param {StoreFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StoreFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, StoreFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Store'> extends True ? Prisma__StoreClient<StoreGetPayload<T>> : Prisma__StoreClient<StoreGetPayload<T> | null, null>

    /**
     * Find one Store that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {StoreFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StoreFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, StoreFindUniqueOrThrowArgs>
    ): Prisma__StoreClient<StoreGetPayload<T>>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StoreFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, StoreFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Store'> extends True ? Prisma__StoreClient<StoreGetPayload<T>> : Prisma__StoreClient<StoreGetPayload<T> | null, null>

    /**
     * Find the first Store that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StoreFindFirstOrThrowArgs>(
      args?: SelectSubset<T, StoreFindFirstOrThrowArgs>
    ): Prisma__StoreClient<StoreGetPayload<T>>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeWithIdOnly = await prisma.store.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends StoreFindManyArgs>(
      args?: SelectSubset<T, StoreFindManyArgs>
    ): Prisma.PrismaPromise<Array<StoreGetPayload<T>>>

    /**
     * Create a Store.
     * @param {StoreCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
    **/
    create<T extends StoreCreateArgs>(
      args: SelectSubset<T, StoreCreateArgs>
    ): Prisma__StoreClient<StoreGetPayload<T>>

    /**
     * Create many Stores.
     *     @param {StoreCreateManyArgs} args - Arguments to create many Stores.
     *     @example
     *     // Create many Stores
     *     const store = await prisma.store.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends StoreCreateManyArgs>(
      args?: SelectSubset<T, StoreCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Store.
     * @param {StoreDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
    **/
    delete<T extends StoreDeleteArgs>(
      args: SelectSubset<T, StoreDeleteArgs>
    ): Prisma__StoreClient<StoreGetPayload<T>>

    /**
     * Update one Store.
     * @param {StoreUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StoreUpdateArgs>(
      args: SelectSubset<T, StoreUpdateArgs>
    ): Prisma__StoreClient<StoreGetPayload<T>>

    /**
     * Delete zero or more Stores.
     * @param {StoreDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StoreDeleteManyArgs>(
      args?: SelectSubset<T, StoreDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StoreUpdateManyArgs>(
      args: SelectSubset<T, StoreUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Store.
     * @param {StoreUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
    **/
    upsert<T extends StoreUpsertArgs>(
      args: SelectSubset<T, StoreUpsertArgs>
    ): Prisma__StoreClient<StoreGetPayload<T>>

    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoreCountArgs>(
      args?: Subset<T, StoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreGroupByArgs['orderBy'] }
        : { orderBy?: StoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__StoreClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Customer<T extends Store$CustomerArgs= {}>(args?: Subset<T, Store$CustomerArgs>): Prisma.PrismaPromise<Array<CustomerGetPayload<T>>| Null>;

    Stamp<T extends Store$StampArgs= {}>(args?: Subset<T, Store$StampArgs>): Prisma.PrismaPromise<Array<StampGetPayload<T>>| Null>;

    Store_Owner_Store_ownerIdToStore_Owner<T extends Store_OwnerArgs= {}>(args?: Subset<T, Store_OwnerArgs>): Prisma__Store_OwnerClient<Store_OwnerGetPayload<T> | Null>;

    Tour<T extends TourArgs= {}>(args?: Subset<T, TourArgs>): Prisma__TourClient<TourGetPayload<T> | Null>;

    Store_Like<T extends Store$Store_LikeArgs= {}>(args?: Subset<T, Store$Store_LikeArgs>): Prisma.PrismaPromise<Array<Store_LikeGetPayload<T>>| Null>;

    Store_Menu<T extends Store$Store_MenuArgs= {}>(args?: Subset<T, Store$Store_MenuArgs>): Prisma.PrismaPromise<Array<Store_MenuGetPayload<T>>| Null>;

    Store_Notice<T extends Store$Store_NoticeArgs= {}>(args?: Subset<T, Store$Store_NoticeArgs>): Prisma.PrismaPromise<Array<Store_NoticeGetPayload<T>>| Null>;

    Store_Owner_Store_Owner_storeIdToStore<T extends Store_OwnerArgs= {}>(args?: Subset<T, Store_OwnerArgs>): Prisma__Store_OwnerClient<Store_OwnerGetPayload<T> | Null>;

    Store_Product<T extends Store$Store_ProductArgs= {}>(args?: Subset<T, Store$Store_ProductArgs>): Prisma.PrismaPromise<Array<Store_ProductGetPayload<T>>| Null>;

    Store_Review<T extends Store_ReviewArgs= {}>(args?: Subset<T, Store_ReviewArgs>): Prisma__Store_ReviewClient<Store_ReviewGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Store base type for findUnique actions
   */
  export type StoreFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findUnique
   */
  export interface StoreFindUniqueArgs extends StoreFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Store findUniqueOrThrow
   */
  export type StoreFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }


  /**
   * Store base type for findFirst actions
   */
  export type StoreFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: Enumerable<StoreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: Enumerable<StoreScalarFieldEnum>
  }

  /**
   * Store findFirst
   */
  export interface StoreFindFirstArgs extends StoreFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Store findFirstOrThrow
   */
  export type StoreFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: Enumerable<StoreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: Enumerable<StoreScalarFieldEnum>
  }


  /**
   * Store findMany
   */
  export type StoreFindManyArgs = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: Enumerable<StoreOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: Enumerable<StoreScalarFieldEnum>
  }


  /**
   * Store create
   */
  export type StoreCreateArgs = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude | null
    /**
     * The data needed to create a Store.
     */
    data: XOR<StoreCreateInput, StoreUncheckedCreateInput>
  }


  /**
   * Store createMany
   */
  export type StoreCreateManyArgs = {
    /**
     * The data used to create many Stores.
     */
    data: Enumerable<StoreCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Store update
   */
  export type StoreUpdateArgs = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude | null
    /**
     * The data needed to update a Store.
     */
    data: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
    /**
     * Choose, which Store to update.
     */
    where: StoreWhereUniqueInput
  }


  /**
   * Store updateMany
   */
  export type StoreUpdateManyArgs = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
  }


  /**
   * Store upsert
   */
  export type StoreUpsertArgs = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude | null
    /**
     * The filter to search for the Store to update in case it exists.
     */
    where: StoreWhereUniqueInput
    /**
     * In case the Store found by the `where` argument doesn't exist, create a new Store with this data.
     */
    create: XOR<StoreCreateInput, StoreUncheckedCreateInput>
    /**
     * In case the Store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
  }


  /**
   * Store delete
   */
  export type StoreDeleteArgs = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude | null
    /**
     * Filter which Store to delete.
     */
    where: StoreWhereUniqueInput
  }


  /**
   * Store deleteMany
   */
  export type StoreDeleteManyArgs = {
    /**
     * Filter which Stores to delete
     */
    where?: StoreWhereInput
  }


  /**
   * Store.Customer
   */
  export type Store$CustomerArgs = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude | null
    where?: CustomerWhereInput
    orderBy?: Enumerable<CustomerOrderByWithRelationInput>
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CustomerScalarFieldEnum>
  }


  /**
   * Store.Stamp
   */
  export type Store$StampArgs = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StampInclude | null
    where?: StampWhereInput
    orderBy?: Enumerable<StampOrderByWithRelationInput>
    cursor?: StampWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StampScalarFieldEnum>
  }


  /**
   * Store.Store_Like
   */
  export type Store$Store_LikeArgs = {
    /**
     * Select specific fields to fetch from the Store_Like
     */
    select?: Store_LikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_LikeInclude | null
    where?: Store_LikeWhereInput
    orderBy?: Enumerable<Store_LikeOrderByWithRelationInput>
    cursor?: Store_LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Store_LikeScalarFieldEnum>
  }


  /**
   * Store.Store_Menu
   */
  export type Store$Store_MenuArgs = {
    /**
     * Select specific fields to fetch from the Store_Menu
     */
    select?: Store_MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_MenuInclude | null
    where?: Store_MenuWhereInput
    orderBy?: Enumerable<Store_MenuOrderByWithRelationInput>
    cursor?: Store_MenuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Store_MenuScalarFieldEnum>
  }


  /**
   * Store.Store_Notice
   */
  export type Store$Store_NoticeArgs = {
    /**
     * Select specific fields to fetch from the Store_Notice
     */
    select?: Store_NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_NoticeInclude | null
    where?: Store_NoticeWhereInput
    orderBy?: Enumerable<Store_NoticeOrderByWithRelationInput>
    cursor?: Store_NoticeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Store_NoticeScalarFieldEnum>
  }


  /**
   * Store.Store_Product
   */
  export type Store$Store_ProductArgs = {
    /**
     * Select specific fields to fetch from the Store_Product
     */
    select?: Store_ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ProductInclude | null
    where?: Store_ProductWhereInput
    orderBy?: Enumerable<Store_ProductOrderByWithRelationInput>
    cursor?: Store_ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Store_ProductScalarFieldEnum>
  }


  /**
   * Store without action
   */
  export type StoreArgs = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude | null
  }



  /**
   * Model Store_Menu
   */


  export type AggregateStore_Menu = {
    _count: Store_MenuCountAggregateOutputType | null
    _avg: Store_MenuAvgAggregateOutputType | null
    _sum: Store_MenuSumAggregateOutputType | null
    _min: Store_MenuMinAggregateOutputType | null
    _max: Store_MenuMaxAggregateOutputType | null
  }

  export type Store_MenuAvgAggregateOutputType = {
    id: number | null
    storeId: number | null
  }

  export type Store_MenuSumAggregateOutputType = {
    id: number | null
    storeId: number | null
  }

  export type Store_MenuMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    image: string | null
    storeId: number | null
  }

  export type Store_MenuMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    image: string | null
    storeId: number | null
  }

  export type Store_MenuCountAggregateOutputType = {
    id: number
    title: number
    content: number
    image: number
    storeId: number
    _all: number
  }


  export type Store_MenuAvgAggregateInputType = {
    id?: true
    storeId?: true
  }

  export type Store_MenuSumAggregateInputType = {
    id?: true
    storeId?: true
  }

  export type Store_MenuMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    image?: true
    storeId?: true
  }

  export type Store_MenuMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    image?: true
    storeId?: true
  }

  export type Store_MenuCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    image?: true
    storeId?: true
    _all?: true
  }

  export type Store_MenuAggregateArgs = {
    /**
     * Filter which Store_Menu to aggregate.
     */
    where?: Store_MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Menus to fetch.
     */
    orderBy?: Enumerable<Store_MenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Store_MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Store_Menus
    **/
    _count?: true | Store_MenuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Store_MenuAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Store_MenuSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Store_MenuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Store_MenuMaxAggregateInputType
  }

  export type GetStore_MenuAggregateType<T extends Store_MenuAggregateArgs> = {
        [P in keyof T & keyof AggregateStore_Menu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore_Menu[P]>
      : GetScalarType<T[P], AggregateStore_Menu[P]>
  }




  export type Store_MenuGroupByArgs = {
    where?: Store_MenuWhereInput
    orderBy?: Enumerable<Store_MenuOrderByWithAggregationInput>
    by: Store_MenuScalarFieldEnum[]
    having?: Store_MenuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Store_MenuCountAggregateInputType | true
    _avg?: Store_MenuAvgAggregateInputType
    _sum?: Store_MenuSumAggregateInputType
    _min?: Store_MenuMinAggregateInputType
    _max?: Store_MenuMaxAggregateInputType
  }


  export type Store_MenuGroupByOutputType = {
    id: number
    title: string | null
    content: string | null
    image: string | null
    storeId: number | null
    _count: Store_MenuCountAggregateOutputType | null
    _avg: Store_MenuAvgAggregateOutputType | null
    _sum: Store_MenuSumAggregateOutputType | null
    _min: Store_MenuMinAggregateOutputType | null
    _max: Store_MenuMaxAggregateOutputType | null
  }

  type GetStore_MenuGroupByPayload<T extends Store_MenuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Store_MenuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Store_MenuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Store_MenuGroupByOutputType[P]>
            : GetScalarType<T[P], Store_MenuGroupByOutputType[P]>
        }
      >
    >


  export type Store_MenuSelect = {
    id?: boolean
    title?: boolean
    content?: boolean
    image?: boolean
    storeId?: boolean
    Store?: boolean | StoreArgs
  }


  export type Store_MenuInclude = {
    Store?: boolean | StoreArgs
  }

  export type Store_MenuGetPayload<S extends boolean | null | undefined | Store_MenuArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Store_Menu :
    S extends undefined ? never :
    S extends { include: any } & (Store_MenuArgs | Store_MenuFindManyArgs)
    ? Store_Menu  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Store' ? StoreGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (Store_MenuArgs | Store_MenuFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Store' ? StoreGetPayload<S['select'][P]> | null :  P extends keyof Store_Menu ? Store_Menu[P] : never
  } 
      : Store_Menu


  type Store_MenuCountArgs = 
    Omit<Store_MenuFindManyArgs, 'select' | 'include'> & {
      select?: Store_MenuCountAggregateInputType | true
    }

  export interface Store_MenuDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Store_Menu that matches the filter.
     * @param {Store_MenuFindUniqueArgs} args - Arguments to find a Store_Menu
     * @example
     * // Get one Store_Menu
     * const store_Menu = await prisma.store_Menu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Store_MenuFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Store_MenuFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Store_Menu'> extends True ? Prisma__Store_MenuClient<Store_MenuGetPayload<T>> : Prisma__Store_MenuClient<Store_MenuGetPayload<T> | null, null>

    /**
     * Find one Store_Menu that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Store_MenuFindUniqueOrThrowArgs} args - Arguments to find a Store_Menu
     * @example
     * // Get one Store_Menu
     * const store_Menu = await prisma.store_Menu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Store_MenuFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Store_MenuFindUniqueOrThrowArgs>
    ): Prisma__Store_MenuClient<Store_MenuGetPayload<T>>

    /**
     * Find the first Store_Menu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_MenuFindFirstArgs} args - Arguments to find a Store_Menu
     * @example
     * // Get one Store_Menu
     * const store_Menu = await prisma.store_Menu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Store_MenuFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Store_MenuFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Store_Menu'> extends True ? Prisma__Store_MenuClient<Store_MenuGetPayload<T>> : Prisma__Store_MenuClient<Store_MenuGetPayload<T> | null, null>

    /**
     * Find the first Store_Menu that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_MenuFindFirstOrThrowArgs} args - Arguments to find a Store_Menu
     * @example
     * // Get one Store_Menu
     * const store_Menu = await prisma.store_Menu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Store_MenuFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Store_MenuFindFirstOrThrowArgs>
    ): Prisma__Store_MenuClient<Store_MenuGetPayload<T>>

    /**
     * Find zero or more Store_Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_MenuFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Store_Menus
     * const store_Menus = await prisma.store_Menu.findMany()
     * 
     * // Get first 10 Store_Menus
     * const store_Menus = await prisma.store_Menu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const store_MenuWithIdOnly = await prisma.store_Menu.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Store_MenuFindManyArgs>(
      args?: SelectSubset<T, Store_MenuFindManyArgs>
    ): Prisma.PrismaPromise<Array<Store_MenuGetPayload<T>>>

    /**
     * Create a Store_Menu.
     * @param {Store_MenuCreateArgs} args - Arguments to create a Store_Menu.
     * @example
     * // Create one Store_Menu
     * const Store_Menu = await prisma.store_Menu.create({
     *   data: {
     *     // ... data to create a Store_Menu
     *   }
     * })
     * 
    **/
    create<T extends Store_MenuCreateArgs>(
      args: SelectSubset<T, Store_MenuCreateArgs>
    ): Prisma__Store_MenuClient<Store_MenuGetPayload<T>>

    /**
     * Create many Store_Menus.
     *     @param {Store_MenuCreateManyArgs} args - Arguments to create many Store_Menus.
     *     @example
     *     // Create many Store_Menus
     *     const store_Menu = await prisma.store_Menu.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Store_MenuCreateManyArgs>(
      args?: SelectSubset<T, Store_MenuCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Store_Menu.
     * @param {Store_MenuDeleteArgs} args - Arguments to delete one Store_Menu.
     * @example
     * // Delete one Store_Menu
     * const Store_Menu = await prisma.store_Menu.delete({
     *   where: {
     *     // ... filter to delete one Store_Menu
     *   }
     * })
     * 
    **/
    delete<T extends Store_MenuDeleteArgs>(
      args: SelectSubset<T, Store_MenuDeleteArgs>
    ): Prisma__Store_MenuClient<Store_MenuGetPayload<T>>

    /**
     * Update one Store_Menu.
     * @param {Store_MenuUpdateArgs} args - Arguments to update one Store_Menu.
     * @example
     * // Update one Store_Menu
     * const store_Menu = await prisma.store_Menu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Store_MenuUpdateArgs>(
      args: SelectSubset<T, Store_MenuUpdateArgs>
    ): Prisma__Store_MenuClient<Store_MenuGetPayload<T>>

    /**
     * Delete zero or more Store_Menus.
     * @param {Store_MenuDeleteManyArgs} args - Arguments to filter Store_Menus to delete.
     * @example
     * // Delete a few Store_Menus
     * const { count } = await prisma.store_Menu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Store_MenuDeleteManyArgs>(
      args?: SelectSubset<T, Store_MenuDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Store_Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_MenuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Store_Menus
     * const store_Menu = await prisma.store_Menu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Store_MenuUpdateManyArgs>(
      args: SelectSubset<T, Store_MenuUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Store_Menu.
     * @param {Store_MenuUpsertArgs} args - Arguments to update or create a Store_Menu.
     * @example
     * // Update or create a Store_Menu
     * const store_Menu = await prisma.store_Menu.upsert({
     *   create: {
     *     // ... data to create a Store_Menu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store_Menu we want to update
     *   }
     * })
    **/
    upsert<T extends Store_MenuUpsertArgs>(
      args: SelectSubset<T, Store_MenuUpsertArgs>
    ): Prisma__Store_MenuClient<Store_MenuGetPayload<T>>

    /**
     * Count the number of Store_Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_MenuCountArgs} args - Arguments to filter Store_Menus to count.
     * @example
     * // Count the number of Store_Menus
     * const count = await prisma.store_Menu.count({
     *   where: {
     *     // ... the filter for the Store_Menus we want to count
     *   }
     * })
    **/
    count<T extends Store_MenuCountArgs>(
      args?: Subset<T, Store_MenuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Store_MenuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store_Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_MenuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Store_MenuAggregateArgs>(args: Subset<T, Store_MenuAggregateArgs>): Prisma.PrismaPromise<GetStore_MenuAggregateType<T>>

    /**
     * Group by Store_Menu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_MenuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Store_MenuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Store_MenuGroupByArgs['orderBy'] }
        : { orderBy?: Store_MenuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Store_MenuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStore_MenuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Store_Menu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Store_MenuClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Store<T extends StoreArgs= {}>(args?: Subset<T, StoreArgs>): Prisma__StoreClient<StoreGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Store_Menu base type for findUnique actions
   */
  export type Store_MenuFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Store_Menu
     */
    select?: Store_MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_MenuInclude | null
    /**
     * Filter, which Store_Menu to fetch.
     */
    where: Store_MenuWhereUniqueInput
  }

  /**
   * Store_Menu findUnique
   */
  export interface Store_MenuFindUniqueArgs extends Store_MenuFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Store_Menu findUniqueOrThrow
   */
  export type Store_MenuFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Store_Menu
     */
    select?: Store_MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_MenuInclude | null
    /**
     * Filter, which Store_Menu to fetch.
     */
    where: Store_MenuWhereUniqueInput
  }


  /**
   * Store_Menu base type for findFirst actions
   */
  export type Store_MenuFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Store_Menu
     */
    select?: Store_MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_MenuInclude | null
    /**
     * Filter, which Store_Menu to fetch.
     */
    where?: Store_MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Menus to fetch.
     */
    orderBy?: Enumerable<Store_MenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Store_Menus.
     */
    cursor?: Store_MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Store_Menus.
     */
    distinct?: Enumerable<Store_MenuScalarFieldEnum>
  }

  /**
   * Store_Menu findFirst
   */
  export interface Store_MenuFindFirstArgs extends Store_MenuFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Store_Menu findFirstOrThrow
   */
  export type Store_MenuFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Store_Menu
     */
    select?: Store_MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_MenuInclude | null
    /**
     * Filter, which Store_Menu to fetch.
     */
    where?: Store_MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Menus to fetch.
     */
    orderBy?: Enumerable<Store_MenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Store_Menus.
     */
    cursor?: Store_MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Store_Menus.
     */
    distinct?: Enumerable<Store_MenuScalarFieldEnum>
  }


  /**
   * Store_Menu findMany
   */
  export type Store_MenuFindManyArgs = {
    /**
     * Select specific fields to fetch from the Store_Menu
     */
    select?: Store_MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_MenuInclude | null
    /**
     * Filter, which Store_Menus to fetch.
     */
    where?: Store_MenuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Menus to fetch.
     */
    orderBy?: Enumerable<Store_MenuOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Store_Menus.
     */
    cursor?: Store_MenuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Menus.
     */
    skip?: number
    distinct?: Enumerable<Store_MenuScalarFieldEnum>
  }


  /**
   * Store_Menu create
   */
  export type Store_MenuCreateArgs = {
    /**
     * Select specific fields to fetch from the Store_Menu
     */
    select?: Store_MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_MenuInclude | null
    /**
     * The data needed to create a Store_Menu.
     */
    data: XOR<Store_MenuCreateInput, Store_MenuUncheckedCreateInput>
  }


  /**
   * Store_Menu createMany
   */
  export type Store_MenuCreateManyArgs = {
    /**
     * The data used to create many Store_Menus.
     */
    data: Enumerable<Store_MenuCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Store_Menu update
   */
  export type Store_MenuUpdateArgs = {
    /**
     * Select specific fields to fetch from the Store_Menu
     */
    select?: Store_MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_MenuInclude | null
    /**
     * The data needed to update a Store_Menu.
     */
    data: XOR<Store_MenuUpdateInput, Store_MenuUncheckedUpdateInput>
    /**
     * Choose, which Store_Menu to update.
     */
    where: Store_MenuWhereUniqueInput
  }


  /**
   * Store_Menu updateMany
   */
  export type Store_MenuUpdateManyArgs = {
    /**
     * The data used to update Store_Menus.
     */
    data: XOR<Store_MenuUpdateManyMutationInput, Store_MenuUncheckedUpdateManyInput>
    /**
     * Filter which Store_Menus to update
     */
    where?: Store_MenuWhereInput
  }


  /**
   * Store_Menu upsert
   */
  export type Store_MenuUpsertArgs = {
    /**
     * Select specific fields to fetch from the Store_Menu
     */
    select?: Store_MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_MenuInclude | null
    /**
     * The filter to search for the Store_Menu to update in case it exists.
     */
    where: Store_MenuWhereUniqueInput
    /**
     * In case the Store_Menu found by the `where` argument doesn't exist, create a new Store_Menu with this data.
     */
    create: XOR<Store_MenuCreateInput, Store_MenuUncheckedCreateInput>
    /**
     * In case the Store_Menu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Store_MenuUpdateInput, Store_MenuUncheckedUpdateInput>
  }


  /**
   * Store_Menu delete
   */
  export type Store_MenuDeleteArgs = {
    /**
     * Select specific fields to fetch from the Store_Menu
     */
    select?: Store_MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_MenuInclude | null
    /**
     * Filter which Store_Menu to delete.
     */
    where: Store_MenuWhereUniqueInput
  }


  /**
   * Store_Menu deleteMany
   */
  export type Store_MenuDeleteManyArgs = {
    /**
     * Filter which Store_Menus to delete
     */
    where?: Store_MenuWhereInput
  }


  /**
   * Store_Menu without action
   */
  export type Store_MenuArgs = {
    /**
     * Select specific fields to fetch from the Store_Menu
     */
    select?: Store_MenuSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_MenuInclude | null
  }



  /**
   * Model Store_Notice
   */


  export type AggregateStore_Notice = {
    _count: Store_NoticeCountAggregateOutputType | null
    _avg: Store_NoticeAvgAggregateOutputType | null
    _sum: Store_NoticeSumAggregateOutputType | null
    _min: Store_NoticeMinAggregateOutputType | null
    _max: Store_NoticeMaxAggregateOutputType | null
  }

  export type Store_NoticeAvgAggregateOutputType = {
    id: number | null
    storeId: number | null
  }

  export type Store_NoticeSumAggregateOutputType = {
    id: number | null
    storeId: number | null
  }

  export type Store_NoticeMinAggregateOutputType = {
    id: number | null
    category: string | null
    title: string | null
    content: string | null
    image: string | null
    storeId: number | null
    createdTime: Date | null
  }

  export type Store_NoticeMaxAggregateOutputType = {
    id: number | null
    category: string | null
    title: string | null
    content: string | null
    image: string | null
    storeId: number | null
    createdTime: Date | null
  }

  export type Store_NoticeCountAggregateOutputType = {
    id: number
    category: number
    title: number
    content: number
    image: number
    storeId: number
    createdTime: number
    _all: number
  }


  export type Store_NoticeAvgAggregateInputType = {
    id?: true
    storeId?: true
  }

  export type Store_NoticeSumAggregateInputType = {
    id?: true
    storeId?: true
  }

  export type Store_NoticeMinAggregateInputType = {
    id?: true
    category?: true
    title?: true
    content?: true
    image?: true
    storeId?: true
    createdTime?: true
  }

  export type Store_NoticeMaxAggregateInputType = {
    id?: true
    category?: true
    title?: true
    content?: true
    image?: true
    storeId?: true
    createdTime?: true
  }

  export type Store_NoticeCountAggregateInputType = {
    id?: true
    category?: true
    title?: true
    content?: true
    image?: true
    storeId?: true
    createdTime?: true
    _all?: true
  }

  export type Store_NoticeAggregateArgs = {
    /**
     * Filter which Store_Notice to aggregate.
     */
    where?: Store_NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Notices to fetch.
     */
    orderBy?: Enumerable<Store_NoticeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Store_NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Store_Notices
    **/
    _count?: true | Store_NoticeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Store_NoticeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Store_NoticeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Store_NoticeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Store_NoticeMaxAggregateInputType
  }

  export type GetStore_NoticeAggregateType<T extends Store_NoticeAggregateArgs> = {
        [P in keyof T & keyof AggregateStore_Notice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore_Notice[P]>
      : GetScalarType<T[P], AggregateStore_Notice[P]>
  }




  export type Store_NoticeGroupByArgs = {
    where?: Store_NoticeWhereInput
    orderBy?: Enumerable<Store_NoticeOrderByWithAggregationInput>
    by: Store_NoticeScalarFieldEnum[]
    having?: Store_NoticeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Store_NoticeCountAggregateInputType | true
    _avg?: Store_NoticeAvgAggregateInputType
    _sum?: Store_NoticeSumAggregateInputType
    _min?: Store_NoticeMinAggregateInputType
    _max?: Store_NoticeMaxAggregateInputType
  }


  export type Store_NoticeGroupByOutputType = {
    id: number
    category: string | null
    title: string | null
    content: string | null
    image: string | null
    storeId: number | null
    createdTime: Date | null
    _count: Store_NoticeCountAggregateOutputType | null
    _avg: Store_NoticeAvgAggregateOutputType | null
    _sum: Store_NoticeSumAggregateOutputType | null
    _min: Store_NoticeMinAggregateOutputType | null
    _max: Store_NoticeMaxAggregateOutputType | null
  }

  type GetStore_NoticeGroupByPayload<T extends Store_NoticeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Store_NoticeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Store_NoticeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Store_NoticeGroupByOutputType[P]>
            : GetScalarType<T[P], Store_NoticeGroupByOutputType[P]>
        }
      >
    >


  export type Store_NoticeSelect = {
    id?: boolean
    category?: boolean
    title?: boolean
    content?: boolean
    image?: boolean
    storeId?: boolean
    createdTime?: boolean
    Store?: boolean | StoreArgs
  }


  export type Store_NoticeInclude = {
    Store?: boolean | StoreArgs
  }

  export type Store_NoticeGetPayload<S extends boolean | null | undefined | Store_NoticeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Store_Notice :
    S extends undefined ? never :
    S extends { include: any } & (Store_NoticeArgs | Store_NoticeFindManyArgs)
    ? Store_Notice  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Store' ? StoreGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (Store_NoticeArgs | Store_NoticeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Store' ? StoreGetPayload<S['select'][P]> | null :  P extends keyof Store_Notice ? Store_Notice[P] : never
  } 
      : Store_Notice


  type Store_NoticeCountArgs = 
    Omit<Store_NoticeFindManyArgs, 'select' | 'include'> & {
      select?: Store_NoticeCountAggregateInputType | true
    }

  export interface Store_NoticeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Store_Notice that matches the filter.
     * @param {Store_NoticeFindUniqueArgs} args - Arguments to find a Store_Notice
     * @example
     * // Get one Store_Notice
     * const store_Notice = await prisma.store_Notice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Store_NoticeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Store_NoticeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Store_Notice'> extends True ? Prisma__Store_NoticeClient<Store_NoticeGetPayload<T>> : Prisma__Store_NoticeClient<Store_NoticeGetPayload<T> | null, null>

    /**
     * Find one Store_Notice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Store_NoticeFindUniqueOrThrowArgs} args - Arguments to find a Store_Notice
     * @example
     * // Get one Store_Notice
     * const store_Notice = await prisma.store_Notice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Store_NoticeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Store_NoticeFindUniqueOrThrowArgs>
    ): Prisma__Store_NoticeClient<Store_NoticeGetPayload<T>>

    /**
     * Find the first Store_Notice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_NoticeFindFirstArgs} args - Arguments to find a Store_Notice
     * @example
     * // Get one Store_Notice
     * const store_Notice = await prisma.store_Notice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Store_NoticeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Store_NoticeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Store_Notice'> extends True ? Prisma__Store_NoticeClient<Store_NoticeGetPayload<T>> : Prisma__Store_NoticeClient<Store_NoticeGetPayload<T> | null, null>

    /**
     * Find the first Store_Notice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_NoticeFindFirstOrThrowArgs} args - Arguments to find a Store_Notice
     * @example
     * // Get one Store_Notice
     * const store_Notice = await prisma.store_Notice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Store_NoticeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Store_NoticeFindFirstOrThrowArgs>
    ): Prisma__Store_NoticeClient<Store_NoticeGetPayload<T>>

    /**
     * Find zero or more Store_Notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_NoticeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Store_Notices
     * const store_Notices = await prisma.store_Notice.findMany()
     * 
     * // Get first 10 Store_Notices
     * const store_Notices = await prisma.store_Notice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const store_NoticeWithIdOnly = await prisma.store_Notice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Store_NoticeFindManyArgs>(
      args?: SelectSubset<T, Store_NoticeFindManyArgs>
    ): Prisma.PrismaPromise<Array<Store_NoticeGetPayload<T>>>

    /**
     * Create a Store_Notice.
     * @param {Store_NoticeCreateArgs} args - Arguments to create a Store_Notice.
     * @example
     * // Create one Store_Notice
     * const Store_Notice = await prisma.store_Notice.create({
     *   data: {
     *     // ... data to create a Store_Notice
     *   }
     * })
     * 
    **/
    create<T extends Store_NoticeCreateArgs>(
      args: SelectSubset<T, Store_NoticeCreateArgs>
    ): Prisma__Store_NoticeClient<Store_NoticeGetPayload<T>>

    /**
     * Create many Store_Notices.
     *     @param {Store_NoticeCreateManyArgs} args - Arguments to create many Store_Notices.
     *     @example
     *     // Create many Store_Notices
     *     const store_Notice = await prisma.store_Notice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Store_NoticeCreateManyArgs>(
      args?: SelectSubset<T, Store_NoticeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Store_Notice.
     * @param {Store_NoticeDeleteArgs} args - Arguments to delete one Store_Notice.
     * @example
     * // Delete one Store_Notice
     * const Store_Notice = await prisma.store_Notice.delete({
     *   where: {
     *     // ... filter to delete one Store_Notice
     *   }
     * })
     * 
    **/
    delete<T extends Store_NoticeDeleteArgs>(
      args: SelectSubset<T, Store_NoticeDeleteArgs>
    ): Prisma__Store_NoticeClient<Store_NoticeGetPayload<T>>

    /**
     * Update one Store_Notice.
     * @param {Store_NoticeUpdateArgs} args - Arguments to update one Store_Notice.
     * @example
     * // Update one Store_Notice
     * const store_Notice = await prisma.store_Notice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Store_NoticeUpdateArgs>(
      args: SelectSubset<T, Store_NoticeUpdateArgs>
    ): Prisma__Store_NoticeClient<Store_NoticeGetPayload<T>>

    /**
     * Delete zero or more Store_Notices.
     * @param {Store_NoticeDeleteManyArgs} args - Arguments to filter Store_Notices to delete.
     * @example
     * // Delete a few Store_Notices
     * const { count } = await prisma.store_Notice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Store_NoticeDeleteManyArgs>(
      args?: SelectSubset<T, Store_NoticeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Store_Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_NoticeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Store_Notices
     * const store_Notice = await prisma.store_Notice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Store_NoticeUpdateManyArgs>(
      args: SelectSubset<T, Store_NoticeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Store_Notice.
     * @param {Store_NoticeUpsertArgs} args - Arguments to update or create a Store_Notice.
     * @example
     * // Update or create a Store_Notice
     * const store_Notice = await prisma.store_Notice.upsert({
     *   create: {
     *     // ... data to create a Store_Notice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store_Notice we want to update
     *   }
     * })
    **/
    upsert<T extends Store_NoticeUpsertArgs>(
      args: SelectSubset<T, Store_NoticeUpsertArgs>
    ): Prisma__Store_NoticeClient<Store_NoticeGetPayload<T>>

    /**
     * Count the number of Store_Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_NoticeCountArgs} args - Arguments to filter Store_Notices to count.
     * @example
     * // Count the number of Store_Notices
     * const count = await prisma.store_Notice.count({
     *   where: {
     *     // ... the filter for the Store_Notices we want to count
     *   }
     * })
    **/
    count<T extends Store_NoticeCountArgs>(
      args?: Subset<T, Store_NoticeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Store_NoticeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store_Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_NoticeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Store_NoticeAggregateArgs>(args: Subset<T, Store_NoticeAggregateArgs>): Prisma.PrismaPromise<GetStore_NoticeAggregateType<T>>

    /**
     * Group by Store_Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_NoticeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Store_NoticeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Store_NoticeGroupByArgs['orderBy'] }
        : { orderBy?: Store_NoticeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Store_NoticeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStore_NoticeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Store_Notice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Store_NoticeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Store<T extends StoreArgs= {}>(args?: Subset<T, StoreArgs>): Prisma__StoreClient<StoreGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Store_Notice base type for findUnique actions
   */
  export type Store_NoticeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Store_Notice
     */
    select?: Store_NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_NoticeInclude | null
    /**
     * Filter, which Store_Notice to fetch.
     */
    where: Store_NoticeWhereUniqueInput
  }

  /**
   * Store_Notice findUnique
   */
  export interface Store_NoticeFindUniqueArgs extends Store_NoticeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Store_Notice findUniqueOrThrow
   */
  export type Store_NoticeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Store_Notice
     */
    select?: Store_NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_NoticeInclude | null
    /**
     * Filter, which Store_Notice to fetch.
     */
    where: Store_NoticeWhereUniqueInput
  }


  /**
   * Store_Notice base type for findFirst actions
   */
  export type Store_NoticeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Store_Notice
     */
    select?: Store_NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_NoticeInclude | null
    /**
     * Filter, which Store_Notice to fetch.
     */
    where?: Store_NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Notices to fetch.
     */
    orderBy?: Enumerable<Store_NoticeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Store_Notices.
     */
    cursor?: Store_NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Store_Notices.
     */
    distinct?: Enumerable<Store_NoticeScalarFieldEnum>
  }

  /**
   * Store_Notice findFirst
   */
  export interface Store_NoticeFindFirstArgs extends Store_NoticeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Store_Notice findFirstOrThrow
   */
  export type Store_NoticeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Store_Notice
     */
    select?: Store_NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_NoticeInclude | null
    /**
     * Filter, which Store_Notice to fetch.
     */
    where?: Store_NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Notices to fetch.
     */
    orderBy?: Enumerable<Store_NoticeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Store_Notices.
     */
    cursor?: Store_NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Store_Notices.
     */
    distinct?: Enumerable<Store_NoticeScalarFieldEnum>
  }


  /**
   * Store_Notice findMany
   */
  export type Store_NoticeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Store_Notice
     */
    select?: Store_NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_NoticeInclude | null
    /**
     * Filter, which Store_Notices to fetch.
     */
    where?: Store_NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Notices to fetch.
     */
    orderBy?: Enumerable<Store_NoticeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Store_Notices.
     */
    cursor?: Store_NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Notices.
     */
    skip?: number
    distinct?: Enumerable<Store_NoticeScalarFieldEnum>
  }


  /**
   * Store_Notice create
   */
  export type Store_NoticeCreateArgs = {
    /**
     * Select specific fields to fetch from the Store_Notice
     */
    select?: Store_NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_NoticeInclude | null
    /**
     * The data needed to create a Store_Notice.
     */
    data: XOR<Store_NoticeCreateInput, Store_NoticeUncheckedCreateInput>
  }


  /**
   * Store_Notice createMany
   */
  export type Store_NoticeCreateManyArgs = {
    /**
     * The data used to create many Store_Notices.
     */
    data: Enumerable<Store_NoticeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Store_Notice update
   */
  export type Store_NoticeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Store_Notice
     */
    select?: Store_NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_NoticeInclude | null
    /**
     * The data needed to update a Store_Notice.
     */
    data: XOR<Store_NoticeUpdateInput, Store_NoticeUncheckedUpdateInput>
    /**
     * Choose, which Store_Notice to update.
     */
    where: Store_NoticeWhereUniqueInput
  }


  /**
   * Store_Notice updateMany
   */
  export type Store_NoticeUpdateManyArgs = {
    /**
     * The data used to update Store_Notices.
     */
    data: XOR<Store_NoticeUpdateManyMutationInput, Store_NoticeUncheckedUpdateManyInput>
    /**
     * Filter which Store_Notices to update
     */
    where?: Store_NoticeWhereInput
  }


  /**
   * Store_Notice upsert
   */
  export type Store_NoticeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Store_Notice
     */
    select?: Store_NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_NoticeInclude | null
    /**
     * The filter to search for the Store_Notice to update in case it exists.
     */
    where: Store_NoticeWhereUniqueInput
    /**
     * In case the Store_Notice found by the `where` argument doesn't exist, create a new Store_Notice with this data.
     */
    create: XOR<Store_NoticeCreateInput, Store_NoticeUncheckedCreateInput>
    /**
     * In case the Store_Notice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Store_NoticeUpdateInput, Store_NoticeUncheckedUpdateInput>
  }


  /**
   * Store_Notice delete
   */
  export type Store_NoticeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Store_Notice
     */
    select?: Store_NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_NoticeInclude | null
    /**
     * Filter which Store_Notice to delete.
     */
    where: Store_NoticeWhereUniqueInput
  }


  /**
   * Store_Notice deleteMany
   */
  export type Store_NoticeDeleteManyArgs = {
    /**
     * Filter which Store_Notices to delete
     */
    where?: Store_NoticeWhereInput
  }


  /**
   * Store_Notice without action
   */
  export type Store_NoticeArgs = {
    /**
     * Select specific fields to fetch from the Store_Notice
     */
    select?: Store_NoticeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_NoticeInclude | null
  }



  /**
   * Model Store_Owner
   */


  export type AggregateStore_Owner = {
    _count: Store_OwnerCountAggregateOutputType | null
    _avg: Store_OwnerAvgAggregateOutputType | null
    _sum: Store_OwnerSumAggregateOutputType | null
    _min: Store_OwnerMinAggregateOutputType | null
    _max: Store_OwnerMaxAggregateOutputType | null
  }

  export type Store_OwnerAvgAggregateOutputType = {
    id: number | null
    storeId: number | null
  }

  export type Store_OwnerSumAggregateOutputType = {
    id: number | null
    storeId: number | null
  }

  export type Store_OwnerMinAggregateOutputType = {
    id: number | null
    loginId: string | null
    password: string | null
    store: string | null
    director: string | null
    phone: string | null
    email: string | null
    address: string | null
    detailAddress: string | null
    licenseNumber: string | null
    licenseImage: string | null
    authorized: boolean | null
    termsAgree: boolean | null
    marketingAgree: boolean | null
    storeId: number | null
    stampAuthorized: boolean | null
    profileImage: string | null
  }

  export type Store_OwnerMaxAggregateOutputType = {
    id: number | null
    loginId: string | null
    password: string | null
    store: string | null
    director: string | null
    phone: string | null
    email: string | null
    address: string | null
    detailAddress: string | null
    licenseNumber: string | null
    licenseImage: string | null
    authorized: boolean | null
    termsAgree: boolean | null
    marketingAgree: boolean | null
    storeId: number | null
    stampAuthorized: boolean | null
    profileImage: string | null
  }

  export type Store_OwnerCountAggregateOutputType = {
    id: number
    loginId: number
    password: number
    store: number
    director: number
    phone: number
    email: number
    address: number
    detailAddress: number
    licenseNumber: number
    licenseImage: number
    authorized: number
    termsAgree: number
    marketingAgree: number
    storeId: number
    stampAuthorized: number
    profileImage: number
    _all: number
  }


  export type Store_OwnerAvgAggregateInputType = {
    id?: true
    storeId?: true
  }

  export type Store_OwnerSumAggregateInputType = {
    id?: true
    storeId?: true
  }

  export type Store_OwnerMinAggregateInputType = {
    id?: true
    loginId?: true
    password?: true
    store?: true
    director?: true
    phone?: true
    email?: true
    address?: true
    detailAddress?: true
    licenseNumber?: true
    licenseImage?: true
    authorized?: true
    termsAgree?: true
    marketingAgree?: true
    storeId?: true
    stampAuthorized?: true
    profileImage?: true
  }

  export type Store_OwnerMaxAggregateInputType = {
    id?: true
    loginId?: true
    password?: true
    store?: true
    director?: true
    phone?: true
    email?: true
    address?: true
    detailAddress?: true
    licenseNumber?: true
    licenseImage?: true
    authorized?: true
    termsAgree?: true
    marketingAgree?: true
    storeId?: true
    stampAuthorized?: true
    profileImage?: true
  }

  export type Store_OwnerCountAggregateInputType = {
    id?: true
    loginId?: true
    password?: true
    store?: true
    director?: true
    phone?: true
    email?: true
    address?: true
    detailAddress?: true
    licenseNumber?: true
    licenseImage?: true
    authorized?: true
    termsAgree?: true
    marketingAgree?: true
    storeId?: true
    stampAuthorized?: true
    profileImage?: true
    _all?: true
  }

  export type Store_OwnerAggregateArgs = {
    /**
     * Filter which Store_Owner to aggregate.
     */
    where?: Store_OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Owners to fetch.
     */
    orderBy?: Enumerable<Store_OwnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Store_OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Store_Owners
    **/
    _count?: true | Store_OwnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Store_OwnerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Store_OwnerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Store_OwnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Store_OwnerMaxAggregateInputType
  }

  export type GetStore_OwnerAggregateType<T extends Store_OwnerAggregateArgs> = {
        [P in keyof T & keyof AggregateStore_Owner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore_Owner[P]>
      : GetScalarType<T[P], AggregateStore_Owner[P]>
  }




  export type Store_OwnerGroupByArgs = {
    where?: Store_OwnerWhereInput
    orderBy?: Enumerable<Store_OwnerOrderByWithAggregationInput>
    by: Store_OwnerScalarFieldEnum[]
    having?: Store_OwnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Store_OwnerCountAggregateInputType | true
    _avg?: Store_OwnerAvgAggregateInputType
    _sum?: Store_OwnerSumAggregateInputType
    _min?: Store_OwnerMinAggregateInputType
    _max?: Store_OwnerMaxAggregateInputType
  }


  export type Store_OwnerGroupByOutputType = {
    id: number
    loginId: string
    password: string | null
    store: string | null
    director: string | null
    phone: string | null
    email: string | null
    address: string | null
    detailAddress: string | null
    licenseNumber: string | null
    licenseImage: string
    authorized: boolean | null
    termsAgree: boolean | null
    marketingAgree: boolean | null
    storeId: number | null
    stampAuthorized: boolean | null
    profileImage: string | null
    _count: Store_OwnerCountAggregateOutputType | null
    _avg: Store_OwnerAvgAggregateOutputType | null
    _sum: Store_OwnerSumAggregateOutputType | null
    _min: Store_OwnerMinAggregateOutputType | null
    _max: Store_OwnerMaxAggregateOutputType | null
  }

  type GetStore_OwnerGroupByPayload<T extends Store_OwnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Store_OwnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Store_OwnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Store_OwnerGroupByOutputType[P]>
            : GetScalarType<T[P], Store_OwnerGroupByOutputType[P]>
        }
      >
    >


  export type Store_OwnerSelect = {
    id?: boolean
    loginId?: boolean
    password?: boolean
    store?: boolean
    director?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    detailAddress?: boolean
    licenseNumber?: boolean
    licenseImage?: boolean
    authorized?: boolean
    termsAgree?: boolean
    marketingAgree?: boolean
    storeId?: boolean
    stampAuthorized?: boolean
    profileImage?: boolean
    Alim_Request?: boolean | Store_Owner$Alim_RequestArgs
    Stamp_Request?: boolean | Stamp_RequestArgs
    Store_Store_ownerIdToStore_Owner?: boolean | StoreArgs
    Store_Store_Owner_storeIdToStore?: boolean | StoreArgs
    _count?: boolean | Store_OwnerCountOutputTypeArgs
  }


  export type Store_OwnerInclude = {
    Alim_Request?: boolean | Store_Owner$Alim_RequestArgs
    Stamp_Request?: boolean | Stamp_RequestArgs
    Store_Store_ownerIdToStore_Owner?: boolean | StoreArgs
    Store_Store_Owner_storeIdToStore?: boolean | StoreArgs
    _count?: boolean | Store_OwnerCountOutputTypeArgs
  }

  export type Store_OwnerGetPayload<S extends boolean | null | undefined | Store_OwnerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Store_Owner :
    S extends undefined ? never :
    S extends { include: any } & (Store_OwnerArgs | Store_OwnerFindManyArgs)
    ? Store_Owner  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Alim_Request' ? Array < Alim_RequestGetPayload<S['include'][P]>>  :
        P extends 'Stamp_Request' ? Stamp_RequestGetPayload<S['include'][P]> | null :
        P extends 'Store_Store_ownerIdToStore_Owner' ? StoreGetPayload<S['include'][P]> | null :
        P extends 'Store_Store_Owner_storeIdToStore' ? StoreGetPayload<S['include'][P]> | null :
        P extends '_count' ? Store_OwnerCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (Store_OwnerArgs | Store_OwnerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Alim_Request' ? Array < Alim_RequestGetPayload<S['select'][P]>>  :
        P extends 'Stamp_Request' ? Stamp_RequestGetPayload<S['select'][P]> | null :
        P extends 'Store_Store_ownerIdToStore_Owner' ? StoreGetPayload<S['select'][P]> | null :
        P extends 'Store_Store_Owner_storeIdToStore' ? StoreGetPayload<S['select'][P]> | null :
        P extends '_count' ? Store_OwnerCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Store_Owner ? Store_Owner[P] : never
  } 
      : Store_Owner


  type Store_OwnerCountArgs = 
    Omit<Store_OwnerFindManyArgs, 'select' | 'include'> & {
      select?: Store_OwnerCountAggregateInputType | true
    }

  export interface Store_OwnerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Store_Owner that matches the filter.
     * @param {Store_OwnerFindUniqueArgs} args - Arguments to find a Store_Owner
     * @example
     * // Get one Store_Owner
     * const store_Owner = await prisma.store_Owner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Store_OwnerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Store_OwnerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Store_Owner'> extends True ? Prisma__Store_OwnerClient<Store_OwnerGetPayload<T>> : Prisma__Store_OwnerClient<Store_OwnerGetPayload<T> | null, null>

    /**
     * Find one Store_Owner that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Store_OwnerFindUniqueOrThrowArgs} args - Arguments to find a Store_Owner
     * @example
     * // Get one Store_Owner
     * const store_Owner = await prisma.store_Owner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Store_OwnerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Store_OwnerFindUniqueOrThrowArgs>
    ): Prisma__Store_OwnerClient<Store_OwnerGetPayload<T>>

    /**
     * Find the first Store_Owner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_OwnerFindFirstArgs} args - Arguments to find a Store_Owner
     * @example
     * // Get one Store_Owner
     * const store_Owner = await prisma.store_Owner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Store_OwnerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Store_OwnerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Store_Owner'> extends True ? Prisma__Store_OwnerClient<Store_OwnerGetPayload<T>> : Prisma__Store_OwnerClient<Store_OwnerGetPayload<T> | null, null>

    /**
     * Find the first Store_Owner that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_OwnerFindFirstOrThrowArgs} args - Arguments to find a Store_Owner
     * @example
     * // Get one Store_Owner
     * const store_Owner = await prisma.store_Owner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Store_OwnerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Store_OwnerFindFirstOrThrowArgs>
    ): Prisma__Store_OwnerClient<Store_OwnerGetPayload<T>>

    /**
     * Find zero or more Store_Owners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_OwnerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Store_Owners
     * const store_Owners = await prisma.store_Owner.findMany()
     * 
     * // Get first 10 Store_Owners
     * const store_Owners = await prisma.store_Owner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const store_OwnerWithIdOnly = await prisma.store_Owner.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Store_OwnerFindManyArgs>(
      args?: SelectSubset<T, Store_OwnerFindManyArgs>
    ): Prisma.PrismaPromise<Array<Store_OwnerGetPayload<T>>>

    /**
     * Create a Store_Owner.
     * @param {Store_OwnerCreateArgs} args - Arguments to create a Store_Owner.
     * @example
     * // Create one Store_Owner
     * const Store_Owner = await prisma.store_Owner.create({
     *   data: {
     *     // ... data to create a Store_Owner
     *   }
     * })
     * 
    **/
    create<T extends Store_OwnerCreateArgs>(
      args: SelectSubset<T, Store_OwnerCreateArgs>
    ): Prisma__Store_OwnerClient<Store_OwnerGetPayload<T>>

    /**
     * Create many Store_Owners.
     *     @param {Store_OwnerCreateManyArgs} args - Arguments to create many Store_Owners.
     *     @example
     *     // Create many Store_Owners
     *     const store_Owner = await prisma.store_Owner.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Store_OwnerCreateManyArgs>(
      args?: SelectSubset<T, Store_OwnerCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Store_Owner.
     * @param {Store_OwnerDeleteArgs} args - Arguments to delete one Store_Owner.
     * @example
     * // Delete one Store_Owner
     * const Store_Owner = await prisma.store_Owner.delete({
     *   where: {
     *     // ... filter to delete one Store_Owner
     *   }
     * })
     * 
    **/
    delete<T extends Store_OwnerDeleteArgs>(
      args: SelectSubset<T, Store_OwnerDeleteArgs>
    ): Prisma__Store_OwnerClient<Store_OwnerGetPayload<T>>

    /**
     * Update one Store_Owner.
     * @param {Store_OwnerUpdateArgs} args - Arguments to update one Store_Owner.
     * @example
     * // Update one Store_Owner
     * const store_Owner = await prisma.store_Owner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Store_OwnerUpdateArgs>(
      args: SelectSubset<T, Store_OwnerUpdateArgs>
    ): Prisma__Store_OwnerClient<Store_OwnerGetPayload<T>>

    /**
     * Delete zero or more Store_Owners.
     * @param {Store_OwnerDeleteManyArgs} args - Arguments to filter Store_Owners to delete.
     * @example
     * // Delete a few Store_Owners
     * const { count } = await prisma.store_Owner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Store_OwnerDeleteManyArgs>(
      args?: SelectSubset<T, Store_OwnerDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Store_Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_OwnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Store_Owners
     * const store_Owner = await prisma.store_Owner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Store_OwnerUpdateManyArgs>(
      args: SelectSubset<T, Store_OwnerUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Store_Owner.
     * @param {Store_OwnerUpsertArgs} args - Arguments to update or create a Store_Owner.
     * @example
     * // Update or create a Store_Owner
     * const store_Owner = await prisma.store_Owner.upsert({
     *   create: {
     *     // ... data to create a Store_Owner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store_Owner we want to update
     *   }
     * })
    **/
    upsert<T extends Store_OwnerUpsertArgs>(
      args: SelectSubset<T, Store_OwnerUpsertArgs>
    ): Prisma__Store_OwnerClient<Store_OwnerGetPayload<T>>

    /**
     * Count the number of Store_Owners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_OwnerCountArgs} args - Arguments to filter Store_Owners to count.
     * @example
     * // Count the number of Store_Owners
     * const count = await prisma.store_Owner.count({
     *   where: {
     *     // ... the filter for the Store_Owners we want to count
     *   }
     * })
    **/
    count<T extends Store_OwnerCountArgs>(
      args?: Subset<T, Store_OwnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Store_OwnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store_Owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_OwnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Store_OwnerAggregateArgs>(args: Subset<T, Store_OwnerAggregateArgs>): Prisma.PrismaPromise<GetStore_OwnerAggregateType<T>>

    /**
     * Group by Store_Owner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_OwnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Store_OwnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Store_OwnerGroupByArgs['orderBy'] }
        : { orderBy?: Store_OwnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Store_OwnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStore_OwnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Store_Owner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Store_OwnerClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Alim_Request<T extends Store_Owner$Alim_RequestArgs= {}>(args?: Subset<T, Store_Owner$Alim_RequestArgs>): Prisma.PrismaPromise<Array<Alim_RequestGetPayload<T>>| Null>;

    Stamp_Request<T extends Stamp_RequestArgs= {}>(args?: Subset<T, Stamp_RequestArgs>): Prisma__Stamp_RequestClient<Stamp_RequestGetPayload<T> | Null>;

    Store_Store_ownerIdToStore_Owner<T extends StoreArgs= {}>(args?: Subset<T, StoreArgs>): Prisma__StoreClient<StoreGetPayload<T> | Null>;

    Store_Store_Owner_storeIdToStore<T extends StoreArgs= {}>(args?: Subset<T, StoreArgs>): Prisma__StoreClient<StoreGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Store_Owner base type for findUnique actions
   */
  export type Store_OwnerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Store_Owner
     */
    select?: Store_OwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_OwnerInclude | null
    /**
     * Filter, which Store_Owner to fetch.
     */
    where: Store_OwnerWhereUniqueInput
  }

  /**
   * Store_Owner findUnique
   */
  export interface Store_OwnerFindUniqueArgs extends Store_OwnerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Store_Owner findUniqueOrThrow
   */
  export type Store_OwnerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Store_Owner
     */
    select?: Store_OwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_OwnerInclude | null
    /**
     * Filter, which Store_Owner to fetch.
     */
    where: Store_OwnerWhereUniqueInput
  }


  /**
   * Store_Owner base type for findFirst actions
   */
  export type Store_OwnerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Store_Owner
     */
    select?: Store_OwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_OwnerInclude | null
    /**
     * Filter, which Store_Owner to fetch.
     */
    where?: Store_OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Owners to fetch.
     */
    orderBy?: Enumerable<Store_OwnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Store_Owners.
     */
    cursor?: Store_OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Store_Owners.
     */
    distinct?: Enumerable<Store_OwnerScalarFieldEnum>
  }

  /**
   * Store_Owner findFirst
   */
  export interface Store_OwnerFindFirstArgs extends Store_OwnerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Store_Owner findFirstOrThrow
   */
  export type Store_OwnerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Store_Owner
     */
    select?: Store_OwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_OwnerInclude | null
    /**
     * Filter, which Store_Owner to fetch.
     */
    where?: Store_OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Owners to fetch.
     */
    orderBy?: Enumerable<Store_OwnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Store_Owners.
     */
    cursor?: Store_OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Owners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Store_Owners.
     */
    distinct?: Enumerable<Store_OwnerScalarFieldEnum>
  }


  /**
   * Store_Owner findMany
   */
  export type Store_OwnerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Store_Owner
     */
    select?: Store_OwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_OwnerInclude | null
    /**
     * Filter, which Store_Owners to fetch.
     */
    where?: Store_OwnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Owners to fetch.
     */
    orderBy?: Enumerable<Store_OwnerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Store_Owners.
     */
    cursor?: Store_OwnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Owners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Owners.
     */
    skip?: number
    distinct?: Enumerable<Store_OwnerScalarFieldEnum>
  }


  /**
   * Store_Owner create
   */
  export type Store_OwnerCreateArgs = {
    /**
     * Select specific fields to fetch from the Store_Owner
     */
    select?: Store_OwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_OwnerInclude | null
    /**
     * The data needed to create a Store_Owner.
     */
    data: XOR<Store_OwnerCreateInput, Store_OwnerUncheckedCreateInput>
  }


  /**
   * Store_Owner createMany
   */
  export type Store_OwnerCreateManyArgs = {
    /**
     * The data used to create many Store_Owners.
     */
    data: Enumerable<Store_OwnerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Store_Owner update
   */
  export type Store_OwnerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Store_Owner
     */
    select?: Store_OwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_OwnerInclude | null
    /**
     * The data needed to update a Store_Owner.
     */
    data: XOR<Store_OwnerUpdateInput, Store_OwnerUncheckedUpdateInput>
    /**
     * Choose, which Store_Owner to update.
     */
    where: Store_OwnerWhereUniqueInput
  }


  /**
   * Store_Owner updateMany
   */
  export type Store_OwnerUpdateManyArgs = {
    /**
     * The data used to update Store_Owners.
     */
    data: XOR<Store_OwnerUpdateManyMutationInput, Store_OwnerUncheckedUpdateManyInput>
    /**
     * Filter which Store_Owners to update
     */
    where?: Store_OwnerWhereInput
  }


  /**
   * Store_Owner upsert
   */
  export type Store_OwnerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Store_Owner
     */
    select?: Store_OwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_OwnerInclude | null
    /**
     * The filter to search for the Store_Owner to update in case it exists.
     */
    where: Store_OwnerWhereUniqueInput
    /**
     * In case the Store_Owner found by the `where` argument doesn't exist, create a new Store_Owner with this data.
     */
    create: XOR<Store_OwnerCreateInput, Store_OwnerUncheckedCreateInput>
    /**
     * In case the Store_Owner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Store_OwnerUpdateInput, Store_OwnerUncheckedUpdateInput>
  }


  /**
   * Store_Owner delete
   */
  export type Store_OwnerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Store_Owner
     */
    select?: Store_OwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_OwnerInclude | null
    /**
     * Filter which Store_Owner to delete.
     */
    where: Store_OwnerWhereUniqueInput
  }


  /**
   * Store_Owner deleteMany
   */
  export type Store_OwnerDeleteManyArgs = {
    /**
     * Filter which Store_Owners to delete
     */
    where?: Store_OwnerWhereInput
  }


  /**
   * Store_Owner.Alim_Request
   */
  export type Store_Owner$Alim_RequestArgs = {
    /**
     * Select specific fields to fetch from the Alim_Request
     */
    select?: Alim_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_RequestInclude | null
    where?: Alim_RequestWhereInput
    orderBy?: Enumerable<Alim_RequestOrderByWithRelationInput>
    cursor?: Alim_RequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Alim_RequestScalarFieldEnum>
  }


  /**
   * Store_Owner without action
   */
  export type Store_OwnerArgs = {
    /**
     * Select specific fields to fetch from the Store_Owner
     */
    select?: Store_OwnerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_OwnerInclude | null
  }



  /**
   * Model Store_Product
   */


  export type AggregateStore_Product = {
    _count: Store_ProductCountAggregateOutputType | null
    _avg: Store_ProductAvgAggregateOutputType | null
    _sum: Store_ProductSumAggregateOutputType | null
    _min: Store_ProductMinAggregateOutputType | null
    _max: Store_ProductMaxAggregateOutputType | null
  }

  export type Store_ProductAvgAggregateOutputType = {
    id: number | null
    storeId: number | null
  }

  export type Store_ProductSumAggregateOutputType = {
    id: number | null
    storeId: number | null
  }

  export type Store_ProductMinAggregateOutputType = {
    id: number | null
    category: string | null
    name: string | null
    price: string | null
    discountPrice: string | null
    url: string | null
    image: string | null
    storeId: number | null
  }

  export type Store_ProductMaxAggregateOutputType = {
    id: number | null
    category: string | null
    name: string | null
    price: string | null
    discountPrice: string | null
    url: string | null
    image: string | null
    storeId: number | null
  }

  export type Store_ProductCountAggregateOutputType = {
    id: number
    category: number
    name: number
    price: number
    discountPrice: number
    url: number
    image: number
    storeId: number
    _all: number
  }


  export type Store_ProductAvgAggregateInputType = {
    id?: true
    storeId?: true
  }

  export type Store_ProductSumAggregateInputType = {
    id?: true
    storeId?: true
  }

  export type Store_ProductMinAggregateInputType = {
    id?: true
    category?: true
    name?: true
    price?: true
    discountPrice?: true
    url?: true
    image?: true
    storeId?: true
  }

  export type Store_ProductMaxAggregateInputType = {
    id?: true
    category?: true
    name?: true
    price?: true
    discountPrice?: true
    url?: true
    image?: true
    storeId?: true
  }

  export type Store_ProductCountAggregateInputType = {
    id?: true
    category?: true
    name?: true
    price?: true
    discountPrice?: true
    url?: true
    image?: true
    storeId?: true
    _all?: true
  }

  export type Store_ProductAggregateArgs = {
    /**
     * Filter which Store_Product to aggregate.
     */
    where?: Store_ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Products to fetch.
     */
    orderBy?: Enumerable<Store_ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Store_ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Store_Products
    **/
    _count?: true | Store_ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Store_ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Store_ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Store_ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Store_ProductMaxAggregateInputType
  }

  export type GetStore_ProductAggregateType<T extends Store_ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateStore_Product]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore_Product[P]>
      : GetScalarType<T[P], AggregateStore_Product[P]>
  }




  export type Store_ProductGroupByArgs = {
    where?: Store_ProductWhereInput
    orderBy?: Enumerable<Store_ProductOrderByWithAggregationInput>
    by: Store_ProductScalarFieldEnum[]
    having?: Store_ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Store_ProductCountAggregateInputType | true
    _avg?: Store_ProductAvgAggregateInputType
    _sum?: Store_ProductSumAggregateInputType
    _min?: Store_ProductMinAggregateInputType
    _max?: Store_ProductMaxAggregateInputType
  }


  export type Store_ProductGroupByOutputType = {
    id: number
    category: string | null
    name: string | null
    price: string | null
    discountPrice: string | null
    url: string | null
    image: string | null
    storeId: number | null
    _count: Store_ProductCountAggregateOutputType | null
    _avg: Store_ProductAvgAggregateOutputType | null
    _sum: Store_ProductSumAggregateOutputType | null
    _min: Store_ProductMinAggregateOutputType | null
    _max: Store_ProductMaxAggregateOutputType | null
  }

  type GetStore_ProductGroupByPayload<T extends Store_ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Store_ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Store_ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Store_ProductGroupByOutputType[P]>
            : GetScalarType<T[P], Store_ProductGroupByOutputType[P]>
        }
      >
    >


  export type Store_ProductSelect = {
    id?: boolean
    category?: boolean
    name?: boolean
    price?: boolean
    discountPrice?: boolean
    url?: boolean
    image?: boolean
    storeId?: boolean
    Store?: boolean | StoreArgs
  }


  export type Store_ProductInclude = {
    Store?: boolean | StoreArgs
  }

  export type Store_ProductGetPayload<S extends boolean | null | undefined | Store_ProductArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Store_Product :
    S extends undefined ? never :
    S extends { include: any } & (Store_ProductArgs | Store_ProductFindManyArgs)
    ? Store_Product  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Store' ? StoreGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (Store_ProductArgs | Store_ProductFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Store' ? StoreGetPayload<S['select'][P]> | null :  P extends keyof Store_Product ? Store_Product[P] : never
  } 
      : Store_Product


  type Store_ProductCountArgs = 
    Omit<Store_ProductFindManyArgs, 'select' | 'include'> & {
      select?: Store_ProductCountAggregateInputType | true
    }

  export interface Store_ProductDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Store_Product that matches the filter.
     * @param {Store_ProductFindUniqueArgs} args - Arguments to find a Store_Product
     * @example
     * // Get one Store_Product
     * const store_Product = await prisma.store_Product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Store_ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Store_ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Store_Product'> extends True ? Prisma__Store_ProductClient<Store_ProductGetPayload<T>> : Prisma__Store_ProductClient<Store_ProductGetPayload<T> | null, null>

    /**
     * Find one Store_Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Store_ProductFindUniqueOrThrowArgs} args - Arguments to find a Store_Product
     * @example
     * // Get one Store_Product
     * const store_Product = await prisma.store_Product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Store_ProductFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Store_ProductFindUniqueOrThrowArgs>
    ): Prisma__Store_ProductClient<Store_ProductGetPayload<T>>

    /**
     * Find the first Store_Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_ProductFindFirstArgs} args - Arguments to find a Store_Product
     * @example
     * // Get one Store_Product
     * const store_Product = await prisma.store_Product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Store_ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Store_ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Store_Product'> extends True ? Prisma__Store_ProductClient<Store_ProductGetPayload<T>> : Prisma__Store_ProductClient<Store_ProductGetPayload<T> | null, null>

    /**
     * Find the first Store_Product that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_ProductFindFirstOrThrowArgs} args - Arguments to find a Store_Product
     * @example
     * // Get one Store_Product
     * const store_Product = await prisma.store_Product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Store_ProductFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Store_ProductFindFirstOrThrowArgs>
    ): Prisma__Store_ProductClient<Store_ProductGetPayload<T>>

    /**
     * Find zero or more Store_Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Store_Products
     * const store_Products = await prisma.store_Product.findMany()
     * 
     * // Get first 10 Store_Products
     * const store_Products = await prisma.store_Product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const store_ProductWithIdOnly = await prisma.store_Product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Store_ProductFindManyArgs>(
      args?: SelectSubset<T, Store_ProductFindManyArgs>
    ): Prisma.PrismaPromise<Array<Store_ProductGetPayload<T>>>

    /**
     * Create a Store_Product.
     * @param {Store_ProductCreateArgs} args - Arguments to create a Store_Product.
     * @example
     * // Create one Store_Product
     * const Store_Product = await prisma.store_Product.create({
     *   data: {
     *     // ... data to create a Store_Product
     *   }
     * })
     * 
    **/
    create<T extends Store_ProductCreateArgs>(
      args: SelectSubset<T, Store_ProductCreateArgs>
    ): Prisma__Store_ProductClient<Store_ProductGetPayload<T>>

    /**
     * Create many Store_Products.
     *     @param {Store_ProductCreateManyArgs} args - Arguments to create many Store_Products.
     *     @example
     *     // Create many Store_Products
     *     const store_Product = await prisma.store_Product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Store_ProductCreateManyArgs>(
      args?: SelectSubset<T, Store_ProductCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Store_Product.
     * @param {Store_ProductDeleteArgs} args - Arguments to delete one Store_Product.
     * @example
     * // Delete one Store_Product
     * const Store_Product = await prisma.store_Product.delete({
     *   where: {
     *     // ... filter to delete one Store_Product
     *   }
     * })
     * 
    **/
    delete<T extends Store_ProductDeleteArgs>(
      args: SelectSubset<T, Store_ProductDeleteArgs>
    ): Prisma__Store_ProductClient<Store_ProductGetPayload<T>>

    /**
     * Update one Store_Product.
     * @param {Store_ProductUpdateArgs} args - Arguments to update one Store_Product.
     * @example
     * // Update one Store_Product
     * const store_Product = await prisma.store_Product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Store_ProductUpdateArgs>(
      args: SelectSubset<T, Store_ProductUpdateArgs>
    ): Prisma__Store_ProductClient<Store_ProductGetPayload<T>>

    /**
     * Delete zero or more Store_Products.
     * @param {Store_ProductDeleteManyArgs} args - Arguments to filter Store_Products to delete.
     * @example
     * // Delete a few Store_Products
     * const { count } = await prisma.store_Product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Store_ProductDeleteManyArgs>(
      args?: SelectSubset<T, Store_ProductDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Store_Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Store_Products
     * const store_Product = await prisma.store_Product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Store_ProductUpdateManyArgs>(
      args: SelectSubset<T, Store_ProductUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Store_Product.
     * @param {Store_ProductUpsertArgs} args - Arguments to update or create a Store_Product.
     * @example
     * // Update or create a Store_Product
     * const store_Product = await prisma.store_Product.upsert({
     *   create: {
     *     // ... data to create a Store_Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store_Product we want to update
     *   }
     * })
    **/
    upsert<T extends Store_ProductUpsertArgs>(
      args: SelectSubset<T, Store_ProductUpsertArgs>
    ): Prisma__Store_ProductClient<Store_ProductGetPayload<T>>

    /**
     * Count the number of Store_Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_ProductCountArgs} args - Arguments to filter Store_Products to count.
     * @example
     * // Count the number of Store_Products
     * const count = await prisma.store_Product.count({
     *   where: {
     *     // ... the filter for the Store_Products we want to count
     *   }
     * })
    **/
    count<T extends Store_ProductCountArgs>(
      args?: Subset<T, Store_ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Store_ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store_Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Store_ProductAggregateArgs>(args: Subset<T, Store_ProductAggregateArgs>): Prisma.PrismaPromise<GetStore_ProductAggregateType<T>>

    /**
     * Group by Store_Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Store_ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Store_ProductGroupByArgs['orderBy'] }
        : { orderBy?: Store_ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Store_ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStore_ProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Store_Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Store_ProductClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Store<T extends StoreArgs= {}>(args?: Subset<T, StoreArgs>): Prisma__StoreClient<StoreGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Store_Product base type for findUnique actions
   */
  export type Store_ProductFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Store_Product
     */
    select?: Store_ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ProductInclude | null
    /**
     * Filter, which Store_Product to fetch.
     */
    where: Store_ProductWhereUniqueInput
  }

  /**
   * Store_Product findUnique
   */
  export interface Store_ProductFindUniqueArgs extends Store_ProductFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Store_Product findUniqueOrThrow
   */
  export type Store_ProductFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Store_Product
     */
    select?: Store_ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ProductInclude | null
    /**
     * Filter, which Store_Product to fetch.
     */
    where: Store_ProductWhereUniqueInput
  }


  /**
   * Store_Product base type for findFirst actions
   */
  export type Store_ProductFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Store_Product
     */
    select?: Store_ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ProductInclude | null
    /**
     * Filter, which Store_Product to fetch.
     */
    where?: Store_ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Products to fetch.
     */
    orderBy?: Enumerable<Store_ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Store_Products.
     */
    cursor?: Store_ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Store_Products.
     */
    distinct?: Enumerable<Store_ProductScalarFieldEnum>
  }

  /**
   * Store_Product findFirst
   */
  export interface Store_ProductFindFirstArgs extends Store_ProductFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Store_Product findFirstOrThrow
   */
  export type Store_ProductFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Store_Product
     */
    select?: Store_ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ProductInclude | null
    /**
     * Filter, which Store_Product to fetch.
     */
    where?: Store_ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Products to fetch.
     */
    orderBy?: Enumerable<Store_ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Store_Products.
     */
    cursor?: Store_ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Store_Products.
     */
    distinct?: Enumerable<Store_ProductScalarFieldEnum>
  }


  /**
   * Store_Product findMany
   */
  export type Store_ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Store_Product
     */
    select?: Store_ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ProductInclude | null
    /**
     * Filter, which Store_Products to fetch.
     */
    where?: Store_ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Products to fetch.
     */
    orderBy?: Enumerable<Store_ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Store_Products.
     */
    cursor?: Store_ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Products.
     */
    skip?: number
    distinct?: Enumerable<Store_ProductScalarFieldEnum>
  }


  /**
   * Store_Product create
   */
  export type Store_ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Store_Product
     */
    select?: Store_ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ProductInclude | null
    /**
     * The data needed to create a Store_Product.
     */
    data: XOR<Store_ProductCreateInput, Store_ProductUncheckedCreateInput>
  }


  /**
   * Store_Product createMany
   */
  export type Store_ProductCreateManyArgs = {
    /**
     * The data used to create many Store_Products.
     */
    data: Enumerable<Store_ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Store_Product update
   */
  export type Store_ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Store_Product
     */
    select?: Store_ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ProductInclude | null
    /**
     * The data needed to update a Store_Product.
     */
    data: XOR<Store_ProductUpdateInput, Store_ProductUncheckedUpdateInput>
    /**
     * Choose, which Store_Product to update.
     */
    where: Store_ProductWhereUniqueInput
  }


  /**
   * Store_Product updateMany
   */
  export type Store_ProductUpdateManyArgs = {
    /**
     * The data used to update Store_Products.
     */
    data: XOR<Store_ProductUpdateManyMutationInput, Store_ProductUncheckedUpdateManyInput>
    /**
     * Filter which Store_Products to update
     */
    where?: Store_ProductWhereInput
  }


  /**
   * Store_Product upsert
   */
  export type Store_ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Store_Product
     */
    select?: Store_ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ProductInclude | null
    /**
     * The filter to search for the Store_Product to update in case it exists.
     */
    where: Store_ProductWhereUniqueInput
    /**
     * In case the Store_Product found by the `where` argument doesn't exist, create a new Store_Product with this data.
     */
    create: XOR<Store_ProductCreateInput, Store_ProductUncheckedCreateInput>
    /**
     * In case the Store_Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Store_ProductUpdateInput, Store_ProductUncheckedUpdateInput>
  }


  /**
   * Store_Product delete
   */
  export type Store_ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Store_Product
     */
    select?: Store_ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ProductInclude | null
    /**
     * Filter which Store_Product to delete.
     */
    where: Store_ProductWhereUniqueInput
  }


  /**
   * Store_Product deleteMany
   */
  export type Store_ProductDeleteManyArgs = {
    /**
     * Filter which Store_Products to delete
     */
    where?: Store_ProductWhereInput
  }


  /**
   * Store_Product without action
   */
  export type Store_ProductArgs = {
    /**
     * Select specific fields to fetch from the Store_Product
     */
    select?: Store_ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ProductInclude | null
  }



  /**
   * Model Tour
   */


  export type AggregateTour = {
    _count: TourCountAggregateOutputType | null
    _avg: TourAvgAggregateOutputType | null
    _sum: TourSumAggregateOutputType | null
    _min: TourMinAggregateOutputType | null
    _max: TourMaxAggregateOutputType | null
  }

  export type TourAvgAggregateOutputType = {
    id: number | null
  }

  export type TourSumAggregateOutputType = {
    id: number | null
  }

  export type TourMinAggregateOutputType = {
    id: number | null
    keyword: string | null
    title: string | null
    reward: string | null
    image: string | null
  }

  export type TourMaxAggregateOutputType = {
    id: number | null
    keyword: string | null
    title: string | null
    reward: string | null
    image: string | null
  }

  export type TourCountAggregateOutputType = {
    id: number
    keyword: number
    title: number
    reward: number
    image: number
    cafeList: number
    _all: number
  }


  export type TourAvgAggregateInputType = {
    id?: true
  }

  export type TourSumAggregateInputType = {
    id?: true
  }

  export type TourMinAggregateInputType = {
    id?: true
    keyword?: true
    title?: true
    reward?: true
    image?: true
  }

  export type TourMaxAggregateInputType = {
    id?: true
    keyword?: true
    title?: true
    reward?: true
    image?: true
  }

  export type TourCountAggregateInputType = {
    id?: true
    keyword?: true
    title?: true
    reward?: true
    image?: true
    cafeList?: true
    _all?: true
  }

  export type TourAggregateArgs = {
    /**
     * Filter which Tour to aggregate.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: Enumerable<TourOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tours
    **/
    _count?: true | TourCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TourAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TourSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TourMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TourMaxAggregateInputType
  }

  export type GetTourAggregateType<T extends TourAggregateArgs> = {
        [P in keyof T & keyof AggregateTour]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTour[P]>
      : GetScalarType<T[P], AggregateTour[P]>
  }




  export type TourGroupByArgs = {
    where?: TourWhereInput
    orderBy?: Enumerable<TourOrderByWithAggregationInput>
    by: TourScalarFieldEnum[]
    having?: TourScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TourCountAggregateInputType | true
    _avg?: TourAvgAggregateInputType
    _sum?: TourSumAggregateInputType
    _min?: TourMinAggregateInputType
    _max?: TourMaxAggregateInputType
  }


  export type TourGroupByOutputType = {
    id: number
    keyword: string
    title: string
    reward: string
    image: string | null
    cafeList: string[]
    _count: TourCountAggregateOutputType | null
    _avg: TourAvgAggregateOutputType | null
    _sum: TourSumAggregateOutputType | null
    _min: TourMinAggregateOutputType | null
    _max: TourMaxAggregateOutputType | null
  }

  type GetTourGroupByPayload<T extends TourGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TourGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TourGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TourGroupByOutputType[P]>
            : GetScalarType<T[P], TourGroupByOutputType[P]>
        }
      >
    >


  export type TourSelect = {
    id?: boolean
    keyword?: boolean
    title?: boolean
    reward?: boolean
    image?: boolean
    cafeList?: boolean
    Stamp?: boolean | Tour$StampArgs
    Store?: boolean | Tour$StoreArgs
    _count?: boolean | TourCountOutputTypeArgs
  }


  export type TourInclude = {
    Stamp?: boolean | Tour$StampArgs
    Store?: boolean | Tour$StoreArgs
    _count?: boolean | TourCountOutputTypeArgs
  }

  export type TourGetPayload<S extends boolean | null | undefined | TourArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Tour :
    S extends undefined ? never :
    S extends { include: any } & (TourArgs | TourFindManyArgs)
    ? Tour  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Stamp' ? Array < StampGetPayload<S['include'][P]>>  :
        P extends 'Store' ? Array < StoreGetPayload<S['include'][P]>>  :
        P extends '_count' ? TourCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (TourArgs | TourFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Stamp' ? Array < StampGetPayload<S['select'][P]>>  :
        P extends 'Store' ? Array < StoreGetPayload<S['select'][P]>>  :
        P extends '_count' ? TourCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Tour ? Tour[P] : never
  } 
      : Tour


  type TourCountArgs = 
    Omit<TourFindManyArgs, 'select' | 'include'> & {
      select?: TourCountAggregateInputType | true
    }

  export interface TourDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tour that matches the filter.
     * @param {TourFindUniqueArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TourFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TourFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Tour'> extends True ? Prisma__TourClient<TourGetPayload<T>> : Prisma__TourClient<TourGetPayload<T> | null, null>

    /**
     * Find one Tour that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TourFindUniqueOrThrowArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TourFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, TourFindUniqueOrThrowArgs>
    ): Prisma__TourClient<TourGetPayload<T>>

    /**
     * Find the first Tour that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindFirstArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TourFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TourFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Tour'> extends True ? Prisma__TourClient<TourGetPayload<T>> : Prisma__TourClient<TourGetPayload<T> | null, null>

    /**
     * Find the first Tour that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindFirstOrThrowArgs} args - Arguments to find a Tour
     * @example
     * // Get one Tour
     * const tour = await prisma.tour.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TourFindFirstOrThrowArgs>(
      args?: SelectSubset<T, TourFindFirstOrThrowArgs>
    ): Prisma__TourClient<TourGetPayload<T>>

    /**
     * Find zero or more Tours that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tours
     * const tours = await prisma.tour.findMany()
     * 
     * // Get first 10 Tours
     * const tours = await prisma.tour.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tourWithIdOnly = await prisma.tour.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TourFindManyArgs>(
      args?: SelectSubset<T, TourFindManyArgs>
    ): Prisma.PrismaPromise<Array<TourGetPayload<T>>>

    /**
     * Create a Tour.
     * @param {TourCreateArgs} args - Arguments to create a Tour.
     * @example
     * // Create one Tour
     * const Tour = await prisma.tour.create({
     *   data: {
     *     // ... data to create a Tour
     *   }
     * })
     * 
    **/
    create<T extends TourCreateArgs>(
      args: SelectSubset<T, TourCreateArgs>
    ): Prisma__TourClient<TourGetPayload<T>>

    /**
     * Create many Tours.
     *     @param {TourCreateManyArgs} args - Arguments to create many Tours.
     *     @example
     *     // Create many Tours
     *     const tour = await prisma.tour.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TourCreateManyArgs>(
      args?: SelectSubset<T, TourCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tour.
     * @param {TourDeleteArgs} args - Arguments to delete one Tour.
     * @example
     * // Delete one Tour
     * const Tour = await prisma.tour.delete({
     *   where: {
     *     // ... filter to delete one Tour
     *   }
     * })
     * 
    **/
    delete<T extends TourDeleteArgs>(
      args: SelectSubset<T, TourDeleteArgs>
    ): Prisma__TourClient<TourGetPayload<T>>

    /**
     * Update one Tour.
     * @param {TourUpdateArgs} args - Arguments to update one Tour.
     * @example
     * // Update one Tour
     * const tour = await prisma.tour.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TourUpdateArgs>(
      args: SelectSubset<T, TourUpdateArgs>
    ): Prisma__TourClient<TourGetPayload<T>>

    /**
     * Delete zero or more Tours.
     * @param {TourDeleteManyArgs} args - Arguments to filter Tours to delete.
     * @example
     * // Delete a few Tours
     * const { count } = await prisma.tour.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TourDeleteManyArgs>(
      args?: SelectSubset<T, TourDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tours
     * const tour = await prisma.tour.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TourUpdateManyArgs>(
      args: SelectSubset<T, TourUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tour.
     * @param {TourUpsertArgs} args - Arguments to update or create a Tour.
     * @example
     * // Update or create a Tour
     * const tour = await prisma.tour.upsert({
     *   create: {
     *     // ... data to create a Tour
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tour we want to update
     *   }
     * })
    **/
    upsert<T extends TourUpsertArgs>(
      args: SelectSubset<T, TourUpsertArgs>
    ): Prisma__TourClient<TourGetPayload<T>>

    /**
     * Count the number of Tours.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourCountArgs} args - Arguments to filter Tours to count.
     * @example
     * // Count the number of Tours
     * const count = await prisma.tour.count({
     *   where: {
     *     // ... the filter for the Tours we want to count
     *   }
     * })
    **/
    count<T extends TourCountArgs>(
      args?: Subset<T, TourCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TourCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TourAggregateArgs>(args: Subset<T, TourAggregateArgs>): Prisma.PrismaPromise<GetTourAggregateType<T>>

    /**
     * Group by Tour.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TourGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TourGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TourGroupByArgs['orderBy'] }
        : { orderBy?: TourGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TourGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTourGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Tour.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TourClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Stamp<T extends Tour$StampArgs= {}>(args?: Subset<T, Tour$StampArgs>): Prisma.PrismaPromise<Array<StampGetPayload<T>>| Null>;

    Store<T extends Tour$StoreArgs= {}>(args?: Subset<T, Tour$StoreArgs>): Prisma.PrismaPromise<Array<StoreGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Tour base type for findUnique actions
   */
  export type TourFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TourInclude | null
    /**
     * Filter, which Tour to fetch.
     */
    where: TourWhereUniqueInput
  }

  /**
   * Tour findUnique
   */
  export interface TourFindUniqueArgs extends TourFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tour findUniqueOrThrow
   */
  export type TourFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TourInclude | null
    /**
     * Filter, which Tour to fetch.
     */
    where: TourWhereUniqueInput
  }


  /**
   * Tour base type for findFirst actions
   */
  export type TourFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TourInclude | null
    /**
     * Filter, which Tour to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: Enumerable<TourOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tours.
     */
    distinct?: Enumerable<TourScalarFieldEnum>
  }

  /**
   * Tour findFirst
   */
  export interface TourFindFirstArgs extends TourFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Tour findFirstOrThrow
   */
  export type TourFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TourInclude | null
    /**
     * Filter, which Tour to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: Enumerable<TourOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tours.
     */
    distinct?: Enumerable<TourScalarFieldEnum>
  }


  /**
   * Tour findMany
   */
  export type TourFindManyArgs = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TourInclude | null
    /**
     * Filter, which Tours to fetch.
     */
    where?: TourWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tours to fetch.
     */
    orderBy?: Enumerable<TourOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tours.
     */
    cursor?: TourWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tours from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tours.
     */
    skip?: number
    distinct?: Enumerable<TourScalarFieldEnum>
  }


  /**
   * Tour create
   */
  export type TourCreateArgs = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TourInclude | null
    /**
     * The data needed to create a Tour.
     */
    data: XOR<TourCreateInput, TourUncheckedCreateInput>
  }


  /**
   * Tour createMany
   */
  export type TourCreateManyArgs = {
    /**
     * The data used to create many Tours.
     */
    data: Enumerable<TourCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Tour update
   */
  export type TourUpdateArgs = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TourInclude | null
    /**
     * The data needed to update a Tour.
     */
    data: XOR<TourUpdateInput, TourUncheckedUpdateInput>
    /**
     * Choose, which Tour to update.
     */
    where: TourWhereUniqueInput
  }


  /**
   * Tour updateMany
   */
  export type TourUpdateManyArgs = {
    /**
     * The data used to update Tours.
     */
    data: XOR<TourUpdateManyMutationInput, TourUncheckedUpdateManyInput>
    /**
     * Filter which Tours to update
     */
    where?: TourWhereInput
  }


  /**
   * Tour upsert
   */
  export type TourUpsertArgs = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TourInclude | null
    /**
     * The filter to search for the Tour to update in case it exists.
     */
    where: TourWhereUniqueInput
    /**
     * In case the Tour found by the `where` argument doesn't exist, create a new Tour with this data.
     */
    create: XOR<TourCreateInput, TourUncheckedCreateInput>
    /**
     * In case the Tour was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TourUpdateInput, TourUncheckedUpdateInput>
  }


  /**
   * Tour delete
   */
  export type TourDeleteArgs = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TourInclude | null
    /**
     * Filter which Tour to delete.
     */
    where: TourWhereUniqueInput
  }


  /**
   * Tour deleteMany
   */
  export type TourDeleteManyArgs = {
    /**
     * Filter which Tours to delete
     */
    where?: TourWhereInput
  }


  /**
   * Tour.Stamp
   */
  export type Tour$StampArgs = {
    /**
     * Select specific fields to fetch from the Stamp
     */
    select?: StampSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StampInclude | null
    where?: StampWhereInput
    orderBy?: Enumerable<StampOrderByWithRelationInput>
    cursor?: StampWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StampScalarFieldEnum>
  }


  /**
   * Tour.Store
   */
  export type Tour$StoreArgs = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: StoreInclude | null
    where?: StoreWhereInput
    orderBy?: Enumerable<StoreOrderByWithRelationInput>
    cursor?: StoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<StoreScalarFieldEnum>
  }


  /**
   * Tour without action
   */
  export type TourArgs = {
    /**
     * Select specific fields to fetch from the Tour
     */
    select?: TourSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TourInclude | null
  }



  /**
   * Model Store_Review
   */


  export type AggregateStore_Review = {
    _count: Store_ReviewCountAggregateOutputType | null
    _avg: Store_ReviewAvgAggregateOutputType | null
    _sum: Store_ReviewSumAggregateOutputType | null
    _min: Store_ReviewMinAggregateOutputType | null
    _max: Store_ReviewMaxAggregateOutputType | null
  }

  export type Store_ReviewAvgAggregateOutputType = {
    id: number | null
    writerId: number | null
    storeId: number | null
  }

  export type Store_ReviewSumAggregateOutputType = {
    id: number | null
    writerId: number | null
    storeId: number | null
  }

  export type Store_ReviewMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    image: string | null
    timestamp: Date | null
    writerId: number | null
    storeId: number | null
    writerName: string | null
  }

  export type Store_ReviewMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    image: string | null
    timestamp: Date | null
    writerId: number | null
    storeId: number | null
    writerName: string | null
  }

  export type Store_ReviewCountAggregateOutputType = {
    id: number
    title: number
    content: number
    image: number
    timestamp: number
    writerId: number
    storeId: number
    writerName: number
    _all: number
  }


  export type Store_ReviewAvgAggregateInputType = {
    id?: true
    writerId?: true
    storeId?: true
  }

  export type Store_ReviewSumAggregateInputType = {
    id?: true
    writerId?: true
    storeId?: true
  }

  export type Store_ReviewMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    image?: true
    timestamp?: true
    writerId?: true
    storeId?: true
    writerName?: true
  }

  export type Store_ReviewMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    image?: true
    timestamp?: true
    writerId?: true
    storeId?: true
    writerName?: true
  }

  export type Store_ReviewCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    image?: true
    timestamp?: true
    writerId?: true
    storeId?: true
    writerName?: true
    _all?: true
  }

  export type Store_ReviewAggregateArgs = {
    /**
     * Filter which Store_Review to aggregate.
     */
    where?: Store_ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Reviews to fetch.
     */
    orderBy?: Enumerable<Store_ReviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Store_ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Store_Reviews
    **/
    _count?: true | Store_ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Store_ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Store_ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Store_ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Store_ReviewMaxAggregateInputType
  }

  export type GetStore_ReviewAggregateType<T extends Store_ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateStore_Review]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore_Review[P]>
      : GetScalarType<T[P], AggregateStore_Review[P]>
  }




  export type Store_ReviewGroupByArgs = {
    where?: Store_ReviewWhereInput
    orderBy?: Enumerable<Store_ReviewOrderByWithAggregationInput>
    by: Store_ReviewScalarFieldEnum[]
    having?: Store_ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Store_ReviewCountAggregateInputType | true
    _avg?: Store_ReviewAvgAggregateInputType
    _sum?: Store_ReviewSumAggregateInputType
    _min?: Store_ReviewMinAggregateInputType
    _max?: Store_ReviewMaxAggregateInputType
  }


  export type Store_ReviewGroupByOutputType = {
    id: number
    title: string | null
    content: string
    image: string | null
    timestamp: Date
    writerId: number
    storeId: number
    writerName: string
    _count: Store_ReviewCountAggregateOutputType | null
    _avg: Store_ReviewAvgAggregateOutputType | null
    _sum: Store_ReviewSumAggregateOutputType | null
    _min: Store_ReviewMinAggregateOutputType | null
    _max: Store_ReviewMaxAggregateOutputType | null
  }

  type GetStore_ReviewGroupByPayload<T extends Store_ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Store_ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Store_ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Store_ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], Store_ReviewGroupByOutputType[P]>
        }
      >
    >


  export type Store_ReviewSelect = {
    id?: boolean
    title?: boolean
    content?: boolean
    image?: boolean
    timestamp?: boolean
    writerId?: boolean
    storeId?: boolean
    writerName?: boolean
    Store?: boolean | StoreArgs
    Customer?: boolean | CustomerArgs
  }


  export type Store_ReviewInclude = {
    Store?: boolean | StoreArgs
    Customer?: boolean | CustomerArgs
  }

  export type Store_ReviewGetPayload<S extends boolean | null | undefined | Store_ReviewArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Store_Review :
    S extends undefined ? never :
    S extends { include: any } & (Store_ReviewArgs | Store_ReviewFindManyArgs)
    ? Store_Review  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Store' ? StoreGetPayload<S['include'][P]> :
        P extends 'Customer' ? CustomerGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (Store_ReviewArgs | Store_ReviewFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Store' ? StoreGetPayload<S['select'][P]> :
        P extends 'Customer' ? CustomerGetPayload<S['select'][P]> :  P extends keyof Store_Review ? Store_Review[P] : never
  } 
      : Store_Review


  type Store_ReviewCountArgs = 
    Omit<Store_ReviewFindManyArgs, 'select' | 'include'> & {
      select?: Store_ReviewCountAggregateInputType | true
    }

  export interface Store_ReviewDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Store_Review that matches the filter.
     * @param {Store_ReviewFindUniqueArgs} args - Arguments to find a Store_Review
     * @example
     * // Get one Store_Review
     * const store_Review = await prisma.store_Review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Store_ReviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Store_ReviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Store_Review'> extends True ? Prisma__Store_ReviewClient<Store_ReviewGetPayload<T>> : Prisma__Store_ReviewClient<Store_ReviewGetPayload<T> | null, null>

    /**
     * Find one Store_Review that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Store_ReviewFindUniqueOrThrowArgs} args - Arguments to find a Store_Review
     * @example
     * // Get one Store_Review
     * const store_Review = await prisma.store_Review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Store_ReviewFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Store_ReviewFindUniqueOrThrowArgs>
    ): Prisma__Store_ReviewClient<Store_ReviewGetPayload<T>>

    /**
     * Find the first Store_Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_ReviewFindFirstArgs} args - Arguments to find a Store_Review
     * @example
     * // Get one Store_Review
     * const store_Review = await prisma.store_Review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Store_ReviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Store_ReviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Store_Review'> extends True ? Prisma__Store_ReviewClient<Store_ReviewGetPayload<T>> : Prisma__Store_ReviewClient<Store_ReviewGetPayload<T> | null, null>

    /**
     * Find the first Store_Review that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_ReviewFindFirstOrThrowArgs} args - Arguments to find a Store_Review
     * @example
     * // Get one Store_Review
     * const store_Review = await prisma.store_Review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Store_ReviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Store_ReviewFindFirstOrThrowArgs>
    ): Prisma__Store_ReviewClient<Store_ReviewGetPayload<T>>

    /**
     * Find zero or more Store_Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_ReviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Store_Reviews
     * const store_Reviews = await prisma.store_Review.findMany()
     * 
     * // Get first 10 Store_Reviews
     * const store_Reviews = await prisma.store_Review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const store_ReviewWithIdOnly = await prisma.store_Review.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Store_ReviewFindManyArgs>(
      args?: SelectSubset<T, Store_ReviewFindManyArgs>
    ): Prisma.PrismaPromise<Array<Store_ReviewGetPayload<T>>>

    /**
     * Create a Store_Review.
     * @param {Store_ReviewCreateArgs} args - Arguments to create a Store_Review.
     * @example
     * // Create one Store_Review
     * const Store_Review = await prisma.store_Review.create({
     *   data: {
     *     // ... data to create a Store_Review
     *   }
     * })
     * 
    **/
    create<T extends Store_ReviewCreateArgs>(
      args: SelectSubset<T, Store_ReviewCreateArgs>
    ): Prisma__Store_ReviewClient<Store_ReviewGetPayload<T>>

    /**
     * Create many Store_Reviews.
     *     @param {Store_ReviewCreateManyArgs} args - Arguments to create many Store_Reviews.
     *     @example
     *     // Create many Store_Reviews
     *     const store_Review = await prisma.store_Review.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Store_ReviewCreateManyArgs>(
      args?: SelectSubset<T, Store_ReviewCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Store_Review.
     * @param {Store_ReviewDeleteArgs} args - Arguments to delete one Store_Review.
     * @example
     * // Delete one Store_Review
     * const Store_Review = await prisma.store_Review.delete({
     *   where: {
     *     // ... filter to delete one Store_Review
     *   }
     * })
     * 
    **/
    delete<T extends Store_ReviewDeleteArgs>(
      args: SelectSubset<T, Store_ReviewDeleteArgs>
    ): Prisma__Store_ReviewClient<Store_ReviewGetPayload<T>>

    /**
     * Update one Store_Review.
     * @param {Store_ReviewUpdateArgs} args - Arguments to update one Store_Review.
     * @example
     * // Update one Store_Review
     * const store_Review = await prisma.store_Review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Store_ReviewUpdateArgs>(
      args: SelectSubset<T, Store_ReviewUpdateArgs>
    ): Prisma__Store_ReviewClient<Store_ReviewGetPayload<T>>

    /**
     * Delete zero or more Store_Reviews.
     * @param {Store_ReviewDeleteManyArgs} args - Arguments to filter Store_Reviews to delete.
     * @example
     * // Delete a few Store_Reviews
     * const { count } = await prisma.store_Review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Store_ReviewDeleteManyArgs>(
      args?: SelectSubset<T, Store_ReviewDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Store_Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Store_Reviews
     * const store_Review = await prisma.store_Review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Store_ReviewUpdateManyArgs>(
      args: SelectSubset<T, Store_ReviewUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Store_Review.
     * @param {Store_ReviewUpsertArgs} args - Arguments to update or create a Store_Review.
     * @example
     * // Update or create a Store_Review
     * const store_Review = await prisma.store_Review.upsert({
     *   create: {
     *     // ... data to create a Store_Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store_Review we want to update
     *   }
     * })
    **/
    upsert<T extends Store_ReviewUpsertArgs>(
      args: SelectSubset<T, Store_ReviewUpsertArgs>
    ): Prisma__Store_ReviewClient<Store_ReviewGetPayload<T>>

    /**
     * Count the number of Store_Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_ReviewCountArgs} args - Arguments to filter Store_Reviews to count.
     * @example
     * // Count the number of Store_Reviews
     * const count = await prisma.store_Review.count({
     *   where: {
     *     // ... the filter for the Store_Reviews we want to count
     *   }
     * })
    **/
    count<T extends Store_ReviewCountArgs>(
      args?: Subset<T, Store_ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Store_ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store_Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Store_ReviewAggregateArgs>(args: Subset<T, Store_ReviewAggregateArgs>): Prisma.PrismaPromise<GetStore_ReviewAggregateType<T>>

    /**
     * Group by Store_Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Store_ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Store_ReviewGroupByArgs['orderBy'] }
        : { orderBy?: Store_ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Store_ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStore_ReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Store_Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Store_ReviewClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Store<T extends StoreArgs= {}>(args?: Subset<T, StoreArgs>): Prisma__StoreClient<StoreGetPayload<T> | Null>;

    Customer<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Store_Review base type for findUnique actions
   */
  export type Store_ReviewFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Store_Review
     */
    select?: Store_ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ReviewInclude | null
    /**
     * Filter, which Store_Review to fetch.
     */
    where: Store_ReviewWhereUniqueInput
  }

  /**
   * Store_Review findUnique
   */
  export interface Store_ReviewFindUniqueArgs extends Store_ReviewFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Store_Review findUniqueOrThrow
   */
  export type Store_ReviewFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Store_Review
     */
    select?: Store_ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ReviewInclude | null
    /**
     * Filter, which Store_Review to fetch.
     */
    where: Store_ReviewWhereUniqueInput
  }


  /**
   * Store_Review base type for findFirst actions
   */
  export type Store_ReviewFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Store_Review
     */
    select?: Store_ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ReviewInclude | null
    /**
     * Filter, which Store_Review to fetch.
     */
    where?: Store_ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Reviews to fetch.
     */
    orderBy?: Enumerable<Store_ReviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Store_Reviews.
     */
    cursor?: Store_ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Store_Reviews.
     */
    distinct?: Enumerable<Store_ReviewScalarFieldEnum>
  }

  /**
   * Store_Review findFirst
   */
  export interface Store_ReviewFindFirstArgs extends Store_ReviewFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Store_Review findFirstOrThrow
   */
  export type Store_ReviewFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Store_Review
     */
    select?: Store_ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ReviewInclude | null
    /**
     * Filter, which Store_Review to fetch.
     */
    where?: Store_ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Reviews to fetch.
     */
    orderBy?: Enumerable<Store_ReviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Store_Reviews.
     */
    cursor?: Store_ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Store_Reviews.
     */
    distinct?: Enumerable<Store_ReviewScalarFieldEnum>
  }


  /**
   * Store_Review findMany
   */
  export type Store_ReviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the Store_Review
     */
    select?: Store_ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ReviewInclude | null
    /**
     * Filter, which Store_Reviews to fetch.
     */
    where?: Store_ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Reviews to fetch.
     */
    orderBy?: Enumerable<Store_ReviewOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Store_Reviews.
     */
    cursor?: Store_ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Reviews.
     */
    skip?: number
    distinct?: Enumerable<Store_ReviewScalarFieldEnum>
  }


  /**
   * Store_Review create
   */
  export type Store_ReviewCreateArgs = {
    /**
     * Select specific fields to fetch from the Store_Review
     */
    select?: Store_ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ReviewInclude | null
    /**
     * The data needed to create a Store_Review.
     */
    data: XOR<Store_ReviewCreateInput, Store_ReviewUncheckedCreateInput>
  }


  /**
   * Store_Review createMany
   */
  export type Store_ReviewCreateManyArgs = {
    /**
     * The data used to create many Store_Reviews.
     */
    data: Enumerable<Store_ReviewCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Store_Review update
   */
  export type Store_ReviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the Store_Review
     */
    select?: Store_ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ReviewInclude | null
    /**
     * The data needed to update a Store_Review.
     */
    data: XOR<Store_ReviewUpdateInput, Store_ReviewUncheckedUpdateInput>
    /**
     * Choose, which Store_Review to update.
     */
    where: Store_ReviewWhereUniqueInput
  }


  /**
   * Store_Review updateMany
   */
  export type Store_ReviewUpdateManyArgs = {
    /**
     * The data used to update Store_Reviews.
     */
    data: XOR<Store_ReviewUpdateManyMutationInput, Store_ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Store_Reviews to update
     */
    where?: Store_ReviewWhereInput
  }


  /**
   * Store_Review upsert
   */
  export type Store_ReviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the Store_Review
     */
    select?: Store_ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ReviewInclude | null
    /**
     * The filter to search for the Store_Review to update in case it exists.
     */
    where: Store_ReviewWhereUniqueInput
    /**
     * In case the Store_Review found by the `where` argument doesn't exist, create a new Store_Review with this data.
     */
    create: XOR<Store_ReviewCreateInput, Store_ReviewUncheckedCreateInput>
    /**
     * In case the Store_Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Store_ReviewUpdateInput, Store_ReviewUncheckedUpdateInput>
  }


  /**
   * Store_Review delete
   */
  export type Store_ReviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the Store_Review
     */
    select?: Store_ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ReviewInclude | null
    /**
     * Filter which Store_Review to delete.
     */
    where: Store_ReviewWhereUniqueInput
  }


  /**
   * Store_Review deleteMany
   */
  export type Store_ReviewDeleteManyArgs = {
    /**
     * Filter which Store_Reviews to delete
     */
    where?: Store_ReviewWhereInput
  }


  /**
   * Store_Review without action
   */
  export type Store_ReviewArgs = {
    /**
     * Select specific fields to fetch from the Store_Review
     */
    select?: Store_ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_ReviewInclude | null
  }



  /**
   * Model Notice
   */


  export type AggregateNotice = {
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  export type NoticeAvgAggregateOutputType = {
    id: number | null
  }

  export type NoticeSumAggregateOutputType = {
    id: number | null
  }

  export type NoticeMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    image: string | null
    timestamp: Date | null
  }

  export type NoticeMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    image: string | null
    timestamp: Date | null
  }

  export type NoticeCountAggregateOutputType = {
    id: number
    title: number
    content: number
    image: number
    timestamp: number
    _all: number
  }


  export type NoticeAvgAggregateInputType = {
    id?: true
  }

  export type NoticeSumAggregateInputType = {
    id?: true
  }

  export type NoticeMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    image?: true
    timestamp?: true
  }

  export type NoticeMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    image?: true
    timestamp?: true
  }

  export type NoticeCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    image?: true
    timestamp?: true
    _all?: true
  }

  export type NoticeAggregateArgs = {
    /**
     * Filter which Notice to aggregate.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: Enumerable<NoticeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notices
    **/
    _count?: true | NoticeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoticeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoticeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoticeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoticeMaxAggregateInputType
  }

  export type GetNoticeAggregateType<T extends NoticeAggregateArgs> = {
        [P in keyof T & keyof AggregateNotice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotice[P]>
      : GetScalarType<T[P], AggregateNotice[P]>
  }




  export type NoticeGroupByArgs = {
    where?: NoticeWhereInput
    orderBy?: Enumerable<NoticeOrderByWithAggregationInput>
    by: NoticeScalarFieldEnum[]
    having?: NoticeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoticeCountAggregateInputType | true
    _avg?: NoticeAvgAggregateInputType
    _sum?: NoticeSumAggregateInputType
    _min?: NoticeMinAggregateInputType
    _max?: NoticeMaxAggregateInputType
  }


  export type NoticeGroupByOutputType = {
    id: number
    title: string
    content: string
    image: string | null
    timestamp: Date
    _count: NoticeCountAggregateOutputType | null
    _avg: NoticeAvgAggregateOutputType | null
    _sum: NoticeSumAggregateOutputType | null
    _min: NoticeMinAggregateOutputType | null
    _max: NoticeMaxAggregateOutputType | null
  }

  type GetNoticeGroupByPayload<T extends NoticeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NoticeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoticeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoticeGroupByOutputType[P]>
            : GetScalarType<T[P], NoticeGroupByOutputType[P]>
        }
      >
    >


  export type NoticeSelect = {
    id?: boolean
    title?: boolean
    content?: boolean
    image?: boolean
    timestamp?: boolean
  }


  export type NoticeGetPayload<S extends boolean | null | undefined | NoticeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Notice :
    S extends undefined ? never :
    S extends { include: any } & (NoticeArgs | NoticeFindManyArgs)
    ? Notice 
    : S extends { select: any } & (NoticeArgs | NoticeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Notice ? Notice[P] : never
  } 
      : Notice


  type NoticeCountArgs = 
    Omit<NoticeFindManyArgs, 'select' | 'include'> & {
      select?: NoticeCountAggregateInputType | true
    }

  export interface NoticeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Notice that matches the filter.
     * @param {NoticeFindUniqueArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NoticeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NoticeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notice'> extends True ? Prisma__NoticeClient<NoticeGetPayload<T>> : Prisma__NoticeClient<NoticeGetPayload<T> | null, null>

    /**
     * Find one Notice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NoticeFindUniqueOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NoticeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NoticeFindUniqueOrThrowArgs>
    ): Prisma__NoticeClient<NoticeGetPayload<T>>

    /**
     * Find the first Notice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NoticeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NoticeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notice'> extends True ? Prisma__NoticeClient<NoticeGetPayload<T>> : Prisma__NoticeClient<NoticeGetPayload<T> | null, null>

    /**
     * Find the first Notice that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindFirstOrThrowArgs} args - Arguments to find a Notice
     * @example
     * // Get one Notice
     * const notice = await prisma.notice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NoticeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NoticeFindFirstOrThrowArgs>
    ): Prisma__NoticeClient<NoticeGetPayload<T>>

    /**
     * Find zero or more Notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notices
     * const notices = await prisma.notice.findMany()
     * 
     * // Get first 10 Notices
     * const notices = await prisma.notice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noticeWithIdOnly = await prisma.notice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NoticeFindManyArgs>(
      args?: SelectSubset<T, NoticeFindManyArgs>
    ): Prisma.PrismaPromise<Array<NoticeGetPayload<T>>>

    /**
     * Create a Notice.
     * @param {NoticeCreateArgs} args - Arguments to create a Notice.
     * @example
     * // Create one Notice
     * const Notice = await prisma.notice.create({
     *   data: {
     *     // ... data to create a Notice
     *   }
     * })
     * 
    **/
    create<T extends NoticeCreateArgs>(
      args: SelectSubset<T, NoticeCreateArgs>
    ): Prisma__NoticeClient<NoticeGetPayload<T>>

    /**
     * Create many Notices.
     *     @param {NoticeCreateManyArgs} args - Arguments to create many Notices.
     *     @example
     *     // Create many Notices
     *     const notice = await prisma.notice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NoticeCreateManyArgs>(
      args?: SelectSubset<T, NoticeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notice.
     * @param {NoticeDeleteArgs} args - Arguments to delete one Notice.
     * @example
     * // Delete one Notice
     * const Notice = await prisma.notice.delete({
     *   where: {
     *     // ... filter to delete one Notice
     *   }
     * })
     * 
    **/
    delete<T extends NoticeDeleteArgs>(
      args: SelectSubset<T, NoticeDeleteArgs>
    ): Prisma__NoticeClient<NoticeGetPayload<T>>

    /**
     * Update one Notice.
     * @param {NoticeUpdateArgs} args - Arguments to update one Notice.
     * @example
     * // Update one Notice
     * const notice = await prisma.notice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NoticeUpdateArgs>(
      args: SelectSubset<T, NoticeUpdateArgs>
    ): Prisma__NoticeClient<NoticeGetPayload<T>>

    /**
     * Delete zero or more Notices.
     * @param {NoticeDeleteManyArgs} args - Arguments to filter Notices to delete.
     * @example
     * // Delete a few Notices
     * const { count } = await prisma.notice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NoticeDeleteManyArgs>(
      args?: SelectSubset<T, NoticeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notices
     * const notice = await prisma.notice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NoticeUpdateManyArgs>(
      args: SelectSubset<T, NoticeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notice.
     * @param {NoticeUpsertArgs} args - Arguments to update or create a Notice.
     * @example
     * // Update or create a Notice
     * const notice = await prisma.notice.upsert({
     *   create: {
     *     // ... data to create a Notice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notice we want to update
     *   }
     * })
    **/
    upsert<T extends NoticeUpsertArgs>(
      args: SelectSubset<T, NoticeUpsertArgs>
    ): Prisma__NoticeClient<NoticeGetPayload<T>>

    /**
     * Count the number of Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeCountArgs} args - Arguments to filter Notices to count.
     * @example
     * // Count the number of Notices
     * const count = await prisma.notice.count({
     *   where: {
     *     // ... the filter for the Notices we want to count
     *   }
     * })
    **/
    count<T extends NoticeCountArgs>(
      args?: Subset<T, NoticeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticeAggregateArgs>(args: Subset<T, NoticeAggregateArgs>): Prisma.PrismaPromise<GetNoticeAggregateType<T>>

    /**
     * Group by Notice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoticeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoticeGroupByArgs['orderBy'] }
        : { orderBy?: NoticeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoticeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoticeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NoticeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notice base type for findUnique actions
   */
  export type NoticeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }

  /**
   * Notice findUnique
   */
  export interface NoticeFindUniqueArgs extends NoticeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notice findUniqueOrThrow
   */
  export type NoticeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect | null
    /**
     * Filter, which Notice to fetch.
     */
    where: NoticeWhereUniqueInput
  }


  /**
   * Notice base type for findFirst actions
   */
  export type NoticeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: Enumerable<NoticeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: Enumerable<NoticeScalarFieldEnum>
  }

  /**
   * Notice findFirst
   */
  export interface NoticeFindFirstArgs extends NoticeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notice findFirstOrThrow
   */
  export type NoticeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect | null
    /**
     * Filter, which Notice to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: Enumerable<NoticeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notices.
     */
    distinct?: Enumerable<NoticeScalarFieldEnum>
  }


  /**
   * Notice findMany
   */
  export type NoticeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect | null
    /**
     * Filter, which Notices to fetch.
     */
    where?: NoticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notices to fetch.
     */
    orderBy?: Enumerable<NoticeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notices.
     */
    cursor?: NoticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notices.
     */
    skip?: number
    distinct?: Enumerable<NoticeScalarFieldEnum>
  }


  /**
   * Notice create
   */
  export type NoticeCreateArgs = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect | null
    /**
     * The data needed to create a Notice.
     */
    data: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
  }


  /**
   * Notice createMany
   */
  export type NoticeCreateManyArgs = {
    /**
     * The data used to create many Notices.
     */
    data: Enumerable<NoticeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notice update
   */
  export type NoticeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect | null
    /**
     * The data needed to update a Notice.
     */
    data: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
    /**
     * Choose, which Notice to update.
     */
    where: NoticeWhereUniqueInput
  }


  /**
   * Notice updateMany
   */
  export type NoticeUpdateManyArgs = {
    /**
     * The data used to update Notices.
     */
    data: XOR<NoticeUpdateManyMutationInput, NoticeUncheckedUpdateManyInput>
    /**
     * Filter which Notices to update
     */
    where?: NoticeWhereInput
  }


  /**
   * Notice upsert
   */
  export type NoticeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect | null
    /**
     * The filter to search for the Notice to update in case it exists.
     */
    where: NoticeWhereUniqueInput
    /**
     * In case the Notice found by the `where` argument doesn't exist, create a new Notice with this data.
     */
    create: XOR<NoticeCreateInput, NoticeUncheckedCreateInput>
    /**
     * In case the Notice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoticeUpdateInput, NoticeUncheckedUpdateInput>
  }


  /**
   * Notice delete
   */
  export type NoticeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect | null
    /**
     * Filter which Notice to delete.
     */
    where: NoticeWhereUniqueInput
  }


  /**
   * Notice deleteMany
   */
  export type NoticeDeleteManyArgs = {
    /**
     * Filter which Notices to delete
     */
    where?: NoticeWhereInput
  }


  /**
   * Notice without action
   */
  export type NoticeArgs = {
    /**
     * Select specific fields to fetch from the Notice
     */
    select?: NoticeSelect | null
  }



  /**
   * Model Alim_Customer
   */


  export type AggregateAlim_Customer = {
    _count: Alim_CustomerCountAggregateOutputType | null
    _avg: Alim_CustomerAvgAggregateOutputType | null
    _sum: Alim_CustomerSumAggregateOutputType | null
    _min: Alim_CustomerMinAggregateOutputType | null
    _max: Alim_CustomerMaxAggregateOutputType | null
  }

  export type Alim_CustomerAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    requestId: number | null
  }

  export type Alim_CustomerSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    requestId: number | null
  }

  export type Alim_CustomerMinAggregateOutputType = {
    id: number | null
    loginId: string | null
    name: string | null
    phone: string | null
    customerId: number | null
    requestId: number | null
  }

  export type Alim_CustomerMaxAggregateOutputType = {
    id: number | null
    loginId: string | null
    name: string | null
    phone: string | null
    customerId: number | null
    requestId: number | null
  }

  export type Alim_CustomerCountAggregateOutputType = {
    id: number
    loginId: number
    name: number
    phone: number
    customerId: number
    requestId: number
    _all: number
  }


  export type Alim_CustomerAvgAggregateInputType = {
    id?: true
    customerId?: true
    requestId?: true
  }

  export type Alim_CustomerSumAggregateInputType = {
    id?: true
    customerId?: true
    requestId?: true
  }

  export type Alim_CustomerMinAggregateInputType = {
    id?: true
    loginId?: true
    name?: true
    phone?: true
    customerId?: true
    requestId?: true
  }

  export type Alim_CustomerMaxAggregateInputType = {
    id?: true
    loginId?: true
    name?: true
    phone?: true
    customerId?: true
    requestId?: true
  }

  export type Alim_CustomerCountAggregateInputType = {
    id?: true
    loginId?: true
    name?: true
    phone?: true
    customerId?: true
    requestId?: true
    _all?: true
  }

  export type Alim_CustomerAggregateArgs = {
    /**
     * Filter which Alim_Customer to aggregate.
     */
    where?: Alim_CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alim_Customers to fetch.
     */
    orderBy?: Enumerable<Alim_CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Alim_CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alim_Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alim_Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alim_Customers
    **/
    _count?: true | Alim_CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Alim_CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Alim_CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Alim_CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Alim_CustomerMaxAggregateInputType
  }

  export type GetAlim_CustomerAggregateType<T extends Alim_CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateAlim_Customer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlim_Customer[P]>
      : GetScalarType<T[P], AggregateAlim_Customer[P]>
  }




  export type Alim_CustomerGroupByArgs = {
    where?: Alim_CustomerWhereInput
    orderBy?: Enumerable<Alim_CustomerOrderByWithAggregationInput>
    by: Alim_CustomerScalarFieldEnum[]
    having?: Alim_CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Alim_CustomerCountAggregateInputType | true
    _avg?: Alim_CustomerAvgAggregateInputType
    _sum?: Alim_CustomerSumAggregateInputType
    _min?: Alim_CustomerMinAggregateInputType
    _max?: Alim_CustomerMaxAggregateInputType
  }


  export type Alim_CustomerGroupByOutputType = {
    id: number
    loginId: string
    name: string | null
    phone: string
    customerId: number
    requestId: number
    _count: Alim_CustomerCountAggregateOutputType | null
    _avg: Alim_CustomerAvgAggregateOutputType | null
    _sum: Alim_CustomerSumAggregateOutputType | null
    _min: Alim_CustomerMinAggregateOutputType | null
    _max: Alim_CustomerMaxAggregateOutputType | null
  }

  type GetAlim_CustomerGroupByPayload<T extends Alim_CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Alim_CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Alim_CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Alim_CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], Alim_CustomerGroupByOutputType[P]>
        }
      >
    >


  export type Alim_CustomerSelect = {
    id?: boolean
    loginId?: boolean
    name?: boolean
    phone?: boolean
    customerId?: boolean
    requestId?: boolean
    Customer?: boolean | CustomerArgs
    Alim_Request?: boolean | Alim_RequestArgs
  }


  export type Alim_CustomerInclude = {
    Customer?: boolean | CustomerArgs
    Alim_Request?: boolean | Alim_RequestArgs
  }

  export type Alim_CustomerGetPayload<S extends boolean | null | undefined | Alim_CustomerArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Alim_Customer :
    S extends undefined ? never :
    S extends { include: any } & (Alim_CustomerArgs | Alim_CustomerFindManyArgs)
    ? Alim_Customer  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Customer' ? CustomerGetPayload<S['include'][P]> :
        P extends 'Alim_Request' ? Alim_RequestGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (Alim_CustomerArgs | Alim_CustomerFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Customer' ? CustomerGetPayload<S['select'][P]> :
        P extends 'Alim_Request' ? Alim_RequestGetPayload<S['select'][P]> :  P extends keyof Alim_Customer ? Alim_Customer[P] : never
  } 
      : Alim_Customer


  type Alim_CustomerCountArgs = 
    Omit<Alim_CustomerFindManyArgs, 'select' | 'include'> & {
      select?: Alim_CustomerCountAggregateInputType | true
    }

  export interface Alim_CustomerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Alim_Customer that matches the filter.
     * @param {Alim_CustomerFindUniqueArgs} args - Arguments to find a Alim_Customer
     * @example
     * // Get one Alim_Customer
     * const alim_Customer = await prisma.alim_Customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Alim_CustomerFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Alim_CustomerFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Alim_Customer'> extends True ? Prisma__Alim_CustomerClient<Alim_CustomerGetPayload<T>> : Prisma__Alim_CustomerClient<Alim_CustomerGetPayload<T> | null, null>

    /**
     * Find one Alim_Customer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Alim_CustomerFindUniqueOrThrowArgs} args - Arguments to find a Alim_Customer
     * @example
     * // Get one Alim_Customer
     * const alim_Customer = await prisma.alim_Customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Alim_CustomerFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Alim_CustomerFindUniqueOrThrowArgs>
    ): Prisma__Alim_CustomerClient<Alim_CustomerGetPayload<T>>

    /**
     * Find the first Alim_Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alim_CustomerFindFirstArgs} args - Arguments to find a Alim_Customer
     * @example
     * // Get one Alim_Customer
     * const alim_Customer = await prisma.alim_Customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Alim_CustomerFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Alim_CustomerFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Alim_Customer'> extends True ? Prisma__Alim_CustomerClient<Alim_CustomerGetPayload<T>> : Prisma__Alim_CustomerClient<Alim_CustomerGetPayload<T> | null, null>

    /**
     * Find the first Alim_Customer that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alim_CustomerFindFirstOrThrowArgs} args - Arguments to find a Alim_Customer
     * @example
     * // Get one Alim_Customer
     * const alim_Customer = await prisma.alim_Customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Alim_CustomerFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Alim_CustomerFindFirstOrThrowArgs>
    ): Prisma__Alim_CustomerClient<Alim_CustomerGetPayload<T>>

    /**
     * Find zero or more Alim_Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alim_CustomerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alim_Customers
     * const alim_Customers = await prisma.alim_Customer.findMany()
     * 
     * // Get first 10 Alim_Customers
     * const alim_Customers = await prisma.alim_Customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alim_CustomerWithIdOnly = await prisma.alim_Customer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Alim_CustomerFindManyArgs>(
      args?: SelectSubset<T, Alim_CustomerFindManyArgs>
    ): Prisma.PrismaPromise<Array<Alim_CustomerGetPayload<T>>>

    /**
     * Create a Alim_Customer.
     * @param {Alim_CustomerCreateArgs} args - Arguments to create a Alim_Customer.
     * @example
     * // Create one Alim_Customer
     * const Alim_Customer = await prisma.alim_Customer.create({
     *   data: {
     *     // ... data to create a Alim_Customer
     *   }
     * })
     * 
    **/
    create<T extends Alim_CustomerCreateArgs>(
      args: SelectSubset<T, Alim_CustomerCreateArgs>
    ): Prisma__Alim_CustomerClient<Alim_CustomerGetPayload<T>>

    /**
     * Create many Alim_Customers.
     *     @param {Alim_CustomerCreateManyArgs} args - Arguments to create many Alim_Customers.
     *     @example
     *     // Create many Alim_Customers
     *     const alim_Customer = await prisma.alim_Customer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Alim_CustomerCreateManyArgs>(
      args?: SelectSubset<T, Alim_CustomerCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alim_Customer.
     * @param {Alim_CustomerDeleteArgs} args - Arguments to delete one Alim_Customer.
     * @example
     * // Delete one Alim_Customer
     * const Alim_Customer = await prisma.alim_Customer.delete({
     *   where: {
     *     // ... filter to delete one Alim_Customer
     *   }
     * })
     * 
    **/
    delete<T extends Alim_CustomerDeleteArgs>(
      args: SelectSubset<T, Alim_CustomerDeleteArgs>
    ): Prisma__Alim_CustomerClient<Alim_CustomerGetPayload<T>>

    /**
     * Update one Alim_Customer.
     * @param {Alim_CustomerUpdateArgs} args - Arguments to update one Alim_Customer.
     * @example
     * // Update one Alim_Customer
     * const alim_Customer = await prisma.alim_Customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Alim_CustomerUpdateArgs>(
      args: SelectSubset<T, Alim_CustomerUpdateArgs>
    ): Prisma__Alim_CustomerClient<Alim_CustomerGetPayload<T>>

    /**
     * Delete zero or more Alim_Customers.
     * @param {Alim_CustomerDeleteManyArgs} args - Arguments to filter Alim_Customers to delete.
     * @example
     * // Delete a few Alim_Customers
     * const { count } = await prisma.alim_Customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Alim_CustomerDeleteManyArgs>(
      args?: SelectSubset<T, Alim_CustomerDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alim_Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alim_CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alim_Customers
     * const alim_Customer = await prisma.alim_Customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Alim_CustomerUpdateManyArgs>(
      args: SelectSubset<T, Alim_CustomerUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alim_Customer.
     * @param {Alim_CustomerUpsertArgs} args - Arguments to update or create a Alim_Customer.
     * @example
     * // Update or create a Alim_Customer
     * const alim_Customer = await prisma.alim_Customer.upsert({
     *   create: {
     *     // ... data to create a Alim_Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alim_Customer we want to update
     *   }
     * })
    **/
    upsert<T extends Alim_CustomerUpsertArgs>(
      args: SelectSubset<T, Alim_CustomerUpsertArgs>
    ): Prisma__Alim_CustomerClient<Alim_CustomerGetPayload<T>>

    /**
     * Count the number of Alim_Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alim_CustomerCountArgs} args - Arguments to filter Alim_Customers to count.
     * @example
     * // Count the number of Alim_Customers
     * const count = await prisma.alim_Customer.count({
     *   where: {
     *     // ... the filter for the Alim_Customers we want to count
     *   }
     * })
    **/
    count<T extends Alim_CustomerCountArgs>(
      args?: Subset<T, Alim_CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Alim_CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alim_Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alim_CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Alim_CustomerAggregateArgs>(args: Subset<T, Alim_CustomerAggregateArgs>): Prisma.PrismaPromise<GetAlim_CustomerAggregateType<T>>

    /**
     * Group by Alim_Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alim_CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Alim_CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Alim_CustomerGroupByArgs['orderBy'] }
        : { orderBy?: Alim_CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Alim_CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlim_CustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Alim_Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Alim_CustomerClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Customer<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    Alim_Request<T extends Alim_RequestArgs= {}>(args?: Subset<T, Alim_RequestArgs>): Prisma__Alim_RequestClient<Alim_RequestGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Alim_Customer base type for findUnique actions
   */
  export type Alim_CustomerFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Alim_Customer
     */
    select?: Alim_CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_CustomerInclude | null
    /**
     * Filter, which Alim_Customer to fetch.
     */
    where: Alim_CustomerWhereUniqueInput
  }

  /**
   * Alim_Customer findUnique
   */
  export interface Alim_CustomerFindUniqueArgs extends Alim_CustomerFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Alim_Customer findUniqueOrThrow
   */
  export type Alim_CustomerFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Alim_Customer
     */
    select?: Alim_CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_CustomerInclude | null
    /**
     * Filter, which Alim_Customer to fetch.
     */
    where: Alim_CustomerWhereUniqueInput
  }


  /**
   * Alim_Customer base type for findFirst actions
   */
  export type Alim_CustomerFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Alim_Customer
     */
    select?: Alim_CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_CustomerInclude | null
    /**
     * Filter, which Alim_Customer to fetch.
     */
    where?: Alim_CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alim_Customers to fetch.
     */
    orderBy?: Enumerable<Alim_CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alim_Customers.
     */
    cursor?: Alim_CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alim_Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alim_Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alim_Customers.
     */
    distinct?: Enumerable<Alim_CustomerScalarFieldEnum>
  }

  /**
   * Alim_Customer findFirst
   */
  export interface Alim_CustomerFindFirstArgs extends Alim_CustomerFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Alim_Customer findFirstOrThrow
   */
  export type Alim_CustomerFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Alim_Customer
     */
    select?: Alim_CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_CustomerInclude | null
    /**
     * Filter, which Alim_Customer to fetch.
     */
    where?: Alim_CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alim_Customers to fetch.
     */
    orderBy?: Enumerable<Alim_CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alim_Customers.
     */
    cursor?: Alim_CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alim_Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alim_Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alim_Customers.
     */
    distinct?: Enumerable<Alim_CustomerScalarFieldEnum>
  }


  /**
   * Alim_Customer findMany
   */
  export type Alim_CustomerFindManyArgs = {
    /**
     * Select specific fields to fetch from the Alim_Customer
     */
    select?: Alim_CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_CustomerInclude | null
    /**
     * Filter, which Alim_Customers to fetch.
     */
    where?: Alim_CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alim_Customers to fetch.
     */
    orderBy?: Enumerable<Alim_CustomerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alim_Customers.
     */
    cursor?: Alim_CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alim_Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alim_Customers.
     */
    skip?: number
    distinct?: Enumerable<Alim_CustomerScalarFieldEnum>
  }


  /**
   * Alim_Customer create
   */
  export type Alim_CustomerCreateArgs = {
    /**
     * Select specific fields to fetch from the Alim_Customer
     */
    select?: Alim_CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_CustomerInclude | null
    /**
     * The data needed to create a Alim_Customer.
     */
    data: XOR<Alim_CustomerCreateInput, Alim_CustomerUncheckedCreateInput>
  }


  /**
   * Alim_Customer createMany
   */
  export type Alim_CustomerCreateManyArgs = {
    /**
     * The data used to create many Alim_Customers.
     */
    data: Enumerable<Alim_CustomerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Alim_Customer update
   */
  export type Alim_CustomerUpdateArgs = {
    /**
     * Select specific fields to fetch from the Alim_Customer
     */
    select?: Alim_CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_CustomerInclude | null
    /**
     * The data needed to update a Alim_Customer.
     */
    data: XOR<Alim_CustomerUpdateInput, Alim_CustomerUncheckedUpdateInput>
    /**
     * Choose, which Alim_Customer to update.
     */
    where: Alim_CustomerWhereUniqueInput
  }


  /**
   * Alim_Customer updateMany
   */
  export type Alim_CustomerUpdateManyArgs = {
    /**
     * The data used to update Alim_Customers.
     */
    data: XOR<Alim_CustomerUpdateManyMutationInput, Alim_CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Alim_Customers to update
     */
    where?: Alim_CustomerWhereInput
  }


  /**
   * Alim_Customer upsert
   */
  export type Alim_CustomerUpsertArgs = {
    /**
     * Select specific fields to fetch from the Alim_Customer
     */
    select?: Alim_CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_CustomerInclude | null
    /**
     * The filter to search for the Alim_Customer to update in case it exists.
     */
    where: Alim_CustomerWhereUniqueInput
    /**
     * In case the Alim_Customer found by the `where` argument doesn't exist, create a new Alim_Customer with this data.
     */
    create: XOR<Alim_CustomerCreateInput, Alim_CustomerUncheckedCreateInput>
    /**
     * In case the Alim_Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Alim_CustomerUpdateInput, Alim_CustomerUncheckedUpdateInput>
  }


  /**
   * Alim_Customer delete
   */
  export type Alim_CustomerDeleteArgs = {
    /**
     * Select specific fields to fetch from the Alim_Customer
     */
    select?: Alim_CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_CustomerInclude | null
    /**
     * Filter which Alim_Customer to delete.
     */
    where: Alim_CustomerWhereUniqueInput
  }


  /**
   * Alim_Customer deleteMany
   */
  export type Alim_CustomerDeleteManyArgs = {
    /**
     * Filter which Alim_Customers to delete
     */
    where?: Alim_CustomerWhereInput
  }


  /**
   * Alim_Customer without action
   */
  export type Alim_CustomerArgs = {
    /**
     * Select specific fields to fetch from the Alim_Customer
     */
    select?: Alim_CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_CustomerInclude | null
  }



  /**
   * Model Alim_Request
   */


  export type AggregateAlim_Request = {
    _count: Alim_RequestCountAggregateOutputType | null
    _avg: Alim_RequestAvgAggregateOutputType | null
    _sum: Alim_RequestSumAggregateOutputType | null
    _min: Alim_RequestMinAggregateOutputType | null
    _max: Alim_RequestMaxAggregateOutputType | null
  }

  export type Alim_RequestAvgAggregateOutputType = {
    id: number | null
    writerId: number | null
  }

  export type Alim_RequestSumAggregateOutputType = {
    id: number | null
    writerId: number | null
  }

  export type Alim_RequestMinAggregateOutputType = {
    id: number | null
    category: string | null
    content: string | null
    isMessage: boolean | null
    isKakao: boolean | null
    writerId: number | null
    timestamp: Date | null
  }

  export type Alim_RequestMaxAggregateOutputType = {
    id: number | null
    category: string | null
    content: string | null
    isMessage: boolean | null
    isKakao: boolean | null
    writerId: number | null
    timestamp: Date | null
  }

  export type Alim_RequestCountAggregateOutputType = {
    id: number
    category: number
    content: number
    isMessage: number
    isKakao: number
    writerId: number
    timestamp: number
    _all: number
  }


  export type Alim_RequestAvgAggregateInputType = {
    id?: true
    writerId?: true
  }

  export type Alim_RequestSumAggregateInputType = {
    id?: true
    writerId?: true
  }

  export type Alim_RequestMinAggregateInputType = {
    id?: true
    category?: true
    content?: true
    isMessage?: true
    isKakao?: true
    writerId?: true
    timestamp?: true
  }

  export type Alim_RequestMaxAggregateInputType = {
    id?: true
    category?: true
    content?: true
    isMessage?: true
    isKakao?: true
    writerId?: true
    timestamp?: true
  }

  export type Alim_RequestCountAggregateInputType = {
    id?: true
    category?: true
    content?: true
    isMessage?: true
    isKakao?: true
    writerId?: true
    timestamp?: true
    _all?: true
  }

  export type Alim_RequestAggregateArgs = {
    /**
     * Filter which Alim_Request to aggregate.
     */
    where?: Alim_RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alim_Requests to fetch.
     */
    orderBy?: Enumerable<Alim_RequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Alim_RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alim_Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alim_Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alim_Requests
    **/
    _count?: true | Alim_RequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Alim_RequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Alim_RequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Alim_RequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Alim_RequestMaxAggregateInputType
  }

  export type GetAlim_RequestAggregateType<T extends Alim_RequestAggregateArgs> = {
        [P in keyof T & keyof AggregateAlim_Request]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlim_Request[P]>
      : GetScalarType<T[P], AggregateAlim_Request[P]>
  }




  export type Alim_RequestGroupByArgs = {
    where?: Alim_RequestWhereInput
    orderBy?: Enumerable<Alim_RequestOrderByWithAggregationInput>
    by: Alim_RequestScalarFieldEnum[]
    having?: Alim_RequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Alim_RequestCountAggregateInputType | true
    _avg?: Alim_RequestAvgAggregateInputType
    _sum?: Alim_RequestSumAggregateInputType
    _min?: Alim_RequestMinAggregateInputType
    _max?: Alim_RequestMaxAggregateInputType
  }


  export type Alim_RequestGroupByOutputType = {
    id: number
    category: string
    content: string
    isMessage: boolean
    isKakao: boolean
    writerId: number
    timestamp: Date
    _count: Alim_RequestCountAggregateOutputType | null
    _avg: Alim_RequestAvgAggregateOutputType | null
    _sum: Alim_RequestSumAggregateOutputType | null
    _min: Alim_RequestMinAggregateOutputType | null
    _max: Alim_RequestMaxAggregateOutputType | null
  }

  type GetAlim_RequestGroupByPayload<T extends Alim_RequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Alim_RequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Alim_RequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Alim_RequestGroupByOutputType[P]>
            : GetScalarType<T[P], Alim_RequestGroupByOutputType[P]>
        }
      >
    >


  export type Alim_RequestSelect = {
    id?: boolean
    category?: boolean
    content?: boolean
    isMessage?: boolean
    isKakao?: boolean
    writerId?: boolean
    timestamp?: boolean
    Alim_Customer?: boolean | Alim_Request$Alim_CustomerArgs
    Store_Owner?: boolean | Store_OwnerArgs
    _count?: boolean | Alim_RequestCountOutputTypeArgs
  }


  export type Alim_RequestInclude = {
    Alim_Customer?: boolean | Alim_Request$Alim_CustomerArgs
    Store_Owner?: boolean | Store_OwnerArgs
    _count?: boolean | Alim_RequestCountOutputTypeArgs
  }

  export type Alim_RequestGetPayload<S extends boolean | null | undefined | Alim_RequestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Alim_Request :
    S extends undefined ? never :
    S extends { include: any } & (Alim_RequestArgs | Alim_RequestFindManyArgs)
    ? Alim_Request  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Alim_Customer' ? Array < Alim_CustomerGetPayload<S['include'][P]>>  :
        P extends 'Store_Owner' ? Store_OwnerGetPayload<S['include'][P]> :
        P extends '_count' ? Alim_RequestCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (Alim_RequestArgs | Alim_RequestFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Alim_Customer' ? Array < Alim_CustomerGetPayload<S['select'][P]>>  :
        P extends 'Store_Owner' ? Store_OwnerGetPayload<S['select'][P]> :
        P extends '_count' ? Alim_RequestCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Alim_Request ? Alim_Request[P] : never
  } 
      : Alim_Request


  type Alim_RequestCountArgs = 
    Omit<Alim_RequestFindManyArgs, 'select' | 'include'> & {
      select?: Alim_RequestCountAggregateInputType | true
    }

  export interface Alim_RequestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Alim_Request that matches the filter.
     * @param {Alim_RequestFindUniqueArgs} args - Arguments to find a Alim_Request
     * @example
     * // Get one Alim_Request
     * const alim_Request = await prisma.alim_Request.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Alim_RequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Alim_RequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Alim_Request'> extends True ? Prisma__Alim_RequestClient<Alim_RequestGetPayload<T>> : Prisma__Alim_RequestClient<Alim_RequestGetPayload<T> | null, null>

    /**
     * Find one Alim_Request that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Alim_RequestFindUniqueOrThrowArgs} args - Arguments to find a Alim_Request
     * @example
     * // Get one Alim_Request
     * const alim_Request = await prisma.alim_Request.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Alim_RequestFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Alim_RequestFindUniqueOrThrowArgs>
    ): Prisma__Alim_RequestClient<Alim_RequestGetPayload<T>>

    /**
     * Find the first Alim_Request that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alim_RequestFindFirstArgs} args - Arguments to find a Alim_Request
     * @example
     * // Get one Alim_Request
     * const alim_Request = await prisma.alim_Request.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Alim_RequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Alim_RequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Alim_Request'> extends True ? Prisma__Alim_RequestClient<Alim_RequestGetPayload<T>> : Prisma__Alim_RequestClient<Alim_RequestGetPayload<T> | null, null>

    /**
     * Find the first Alim_Request that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alim_RequestFindFirstOrThrowArgs} args - Arguments to find a Alim_Request
     * @example
     * // Get one Alim_Request
     * const alim_Request = await prisma.alim_Request.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Alim_RequestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Alim_RequestFindFirstOrThrowArgs>
    ): Prisma__Alim_RequestClient<Alim_RequestGetPayload<T>>

    /**
     * Find zero or more Alim_Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alim_RequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alim_Requests
     * const alim_Requests = await prisma.alim_Request.findMany()
     * 
     * // Get first 10 Alim_Requests
     * const alim_Requests = await prisma.alim_Request.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alim_RequestWithIdOnly = await prisma.alim_Request.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Alim_RequestFindManyArgs>(
      args?: SelectSubset<T, Alim_RequestFindManyArgs>
    ): Prisma.PrismaPromise<Array<Alim_RequestGetPayload<T>>>

    /**
     * Create a Alim_Request.
     * @param {Alim_RequestCreateArgs} args - Arguments to create a Alim_Request.
     * @example
     * // Create one Alim_Request
     * const Alim_Request = await prisma.alim_Request.create({
     *   data: {
     *     // ... data to create a Alim_Request
     *   }
     * })
     * 
    **/
    create<T extends Alim_RequestCreateArgs>(
      args: SelectSubset<T, Alim_RequestCreateArgs>
    ): Prisma__Alim_RequestClient<Alim_RequestGetPayload<T>>

    /**
     * Create many Alim_Requests.
     *     @param {Alim_RequestCreateManyArgs} args - Arguments to create many Alim_Requests.
     *     @example
     *     // Create many Alim_Requests
     *     const alim_Request = await prisma.alim_Request.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Alim_RequestCreateManyArgs>(
      args?: SelectSubset<T, Alim_RequestCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alim_Request.
     * @param {Alim_RequestDeleteArgs} args - Arguments to delete one Alim_Request.
     * @example
     * // Delete one Alim_Request
     * const Alim_Request = await prisma.alim_Request.delete({
     *   where: {
     *     // ... filter to delete one Alim_Request
     *   }
     * })
     * 
    **/
    delete<T extends Alim_RequestDeleteArgs>(
      args: SelectSubset<T, Alim_RequestDeleteArgs>
    ): Prisma__Alim_RequestClient<Alim_RequestGetPayload<T>>

    /**
     * Update one Alim_Request.
     * @param {Alim_RequestUpdateArgs} args - Arguments to update one Alim_Request.
     * @example
     * // Update one Alim_Request
     * const alim_Request = await prisma.alim_Request.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Alim_RequestUpdateArgs>(
      args: SelectSubset<T, Alim_RequestUpdateArgs>
    ): Prisma__Alim_RequestClient<Alim_RequestGetPayload<T>>

    /**
     * Delete zero or more Alim_Requests.
     * @param {Alim_RequestDeleteManyArgs} args - Arguments to filter Alim_Requests to delete.
     * @example
     * // Delete a few Alim_Requests
     * const { count } = await prisma.alim_Request.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Alim_RequestDeleteManyArgs>(
      args?: SelectSubset<T, Alim_RequestDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alim_Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alim_RequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alim_Requests
     * const alim_Request = await prisma.alim_Request.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Alim_RequestUpdateManyArgs>(
      args: SelectSubset<T, Alim_RequestUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alim_Request.
     * @param {Alim_RequestUpsertArgs} args - Arguments to update or create a Alim_Request.
     * @example
     * // Update or create a Alim_Request
     * const alim_Request = await prisma.alim_Request.upsert({
     *   create: {
     *     // ... data to create a Alim_Request
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alim_Request we want to update
     *   }
     * })
    **/
    upsert<T extends Alim_RequestUpsertArgs>(
      args: SelectSubset<T, Alim_RequestUpsertArgs>
    ): Prisma__Alim_RequestClient<Alim_RequestGetPayload<T>>

    /**
     * Count the number of Alim_Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alim_RequestCountArgs} args - Arguments to filter Alim_Requests to count.
     * @example
     * // Count the number of Alim_Requests
     * const count = await prisma.alim_Request.count({
     *   where: {
     *     // ... the filter for the Alim_Requests we want to count
     *   }
     * })
    **/
    count<T extends Alim_RequestCountArgs>(
      args?: Subset<T, Alim_RequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Alim_RequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alim_Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alim_RequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Alim_RequestAggregateArgs>(args: Subset<T, Alim_RequestAggregateArgs>): Prisma.PrismaPromise<GetAlim_RequestAggregateType<T>>

    /**
     * Group by Alim_Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alim_RequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Alim_RequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Alim_RequestGroupByArgs['orderBy'] }
        : { orderBy?: Alim_RequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Alim_RequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlim_RequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Alim_Request.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Alim_RequestClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Alim_Customer<T extends Alim_Request$Alim_CustomerArgs= {}>(args?: Subset<T, Alim_Request$Alim_CustomerArgs>): Prisma.PrismaPromise<Array<Alim_CustomerGetPayload<T>>| Null>;

    Store_Owner<T extends Store_OwnerArgs= {}>(args?: Subset<T, Store_OwnerArgs>): Prisma__Store_OwnerClient<Store_OwnerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Alim_Request base type for findUnique actions
   */
  export type Alim_RequestFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Alim_Request
     */
    select?: Alim_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_RequestInclude | null
    /**
     * Filter, which Alim_Request to fetch.
     */
    where: Alim_RequestWhereUniqueInput
  }

  /**
   * Alim_Request findUnique
   */
  export interface Alim_RequestFindUniqueArgs extends Alim_RequestFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Alim_Request findUniqueOrThrow
   */
  export type Alim_RequestFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Alim_Request
     */
    select?: Alim_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_RequestInclude | null
    /**
     * Filter, which Alim_Request to fetch.
     */
    where: Alim_RequestWhereUniqueInput
  }


  /**
   * Alim_Request base type for findFirst actions
   */
  export type Alim_RequestFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Alim_Request
     */
    select?: Alim_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_RequestInclude | null
    /**
     * Filter, which Alim_Request to fetch.
     */
    where?: Alim_RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alim_Requests to fetch.
     */
    orderBy?: Enumerable<Alim_RequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alim_Requests.
     */
    cursor?: Alim_RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alim_Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alim_Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alim_Requests.
     */
    distinct?: Enumerable<Alim_RequestScalarFieldEnum>
  }

  /**
   * Alim_Request findFirst
   */
  export interface Alim_RequestFindFirstArgs extends Alim_RequestFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Alim_Request findFirstOrThrow
   */
  export type Alim_RequestFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Alim_Request
     */
    select?: Alim_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_RequestInclude | null
    /**
     * Filter, which Alim_Request to fetch.
     */
    where?: Alim_RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alim_Requests to fetch.
     */
    orderBy?: Enumerable<Alim_RequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alim_Requests.
     */
    cursor?: Alim_RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alim_Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alim_Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alim_Requests.
     */
    distinct?: Enumerable<Alim_RequestScalarFieldEnum>
  }


  /**
   * Alim_Request findMany
   */
  export type Alim_RequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the Alim_Request
     */
    select?: Alim_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_RequestInclude | null
    /**
     * Filter, which Alim_Requests to fetch.
     */
    where?: Alim_RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alim_Requests to fetch.
     */
    orderBy?: Enumerable<Alim_RequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alim_Requests.
     */
    cursor?: Alim_RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alim_Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alim_Requests.
     */
    skip?: number
    distinct?: Enumerable<Alim_RequestScalarFieldEnum>
  }


  /**
   * Alim_Request create
   */
  export type Alim_RequestCreateArgs = {
    /**
     * Select specific fields to fetch from the Alim_Request
     */
    select?: Alim_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_RequestInclude | null
    /**
     * The data needed to create a Alim_Request.
     */
    data: XOR<Alim_RequestCreateInput, Alim_RequestUncheckedCreateInput>
  }


  /**
   * Alim_Request createMany
   */
  export type Alim_RequestCreateManyArgs = {
    /**
     * The data used to create many Alim_Requests.
     */
    data: Enumerable<Alim_RequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Alim_Request update
   */
  export type Alim_RequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the Alim_Request
     */
    select?: Alim_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_RequestInclude | null
    /**
     * The data needed to update a Alim_Request.
     */
    data: XOR<Alim_RequestUpdateInput, Alim_RequestUncheckedUpdateInput>
    /**
     * Choose, which Alim_Request to update.
     */
    where: Alim_RequestWhereUniqueInput
  }


  /**
   * Alim_Request updateMany
   */
  export type Alim_RequestUpdateManyArgs = {
    /**
     * The data used to update Alim_Requests.
     */
    data: XOR<Alim_RequestUpdateManyMutationInput, Alim_RequestUncheckedUpdateManyInput>
    /**
     * Filter which Alim_Requests to update
     */
    where?: Alim_RequestWhereInput
  }


  /**
   * Alim_Request upsert
   */
  export type Alim_RequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the Alim_Request
     */
    select?: Alim_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_RequestInclude | null
    /**
     * The filter to search for the Alim_Request to update in case it exists.
     */
    where: Alim_RequestWhereUniqueInput
    /**
     * In case the Alim_Request found by the `where` argument doesn't exist, create a new Alim_Request with this data.
     */
    create: XOR<Alim_RequestCreateInput, Alim_RequestUncheckedCreateInput>
    /**
     * In case the Alim_Request was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Alim_RequestUpdateInput, Alim_RequestUncheckedUpdateInput>
  }


  /**
   * Alim_Request delete
   */
  export type Alim_RequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the Alim_Request
     */
    select?: Alim_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_RequestInclude | null
    /**
     * Filter which Alim_Request to delete.
     */
    where: Alim_RequestWhereUniqueInput
  }


  /**
   * Alim_Request deleteMany
   */
  export type Alim_RequestDeleteManyArgs = {
    /**
     * Filter which Alim_Requests to delete
     */
    where?: Alim_RequestWhereInput
  }


  /**
   * Alim_Request.Alim_Customer
   */
  export type Alim_Request$Alim_CustomerArgs = {
    /**
     * Select specific fields to fetch from the Alim_Customer
     */
    select?: Alim_CustomerSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_CustomerInclude | null
    where?: Alim_CustomerWhereInput
    orderBy?: Enumerable<Alim_CustomerOrderByWithRelationInput>
    cursor?: Alim_CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Alim_CustomerScalarFieldEnum>
  }


  /**
   * Alim_Request without action
   */
  export type Alim_RequestArgs = {
    /**
     * Select specific fields to fetch from the Alim_Request
     */
    select?: Alim_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Alim_RequestInclude | null
  }



  /**
   * Model Stamp_Request
   */


  export type AggregateStamp_Request = {
    _count: Stamp_RequestCountAggregateOutputType | null
    _avg: Stamp_RequestAvgAggregateOutputType | null
    _sum: Stamp_RequestSumAggregateOutputType | null
    _min: Stamp_RequestMinAggregateOutputType | null
    _max: Stamp_RequestMaxAggregateOutputType | null
  }

  export type Stamp_RequestAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
  }

  export type Stamp_RequestSumAggregateOutputType = {
    id: number | null
    ownerId: number | null
  }

  export type Stamp_RequestMinAggregateOutputType = {
    id: number | null
    ownerId: number | null
    isGrant: boolean | null
  }

  export type Stamp_RequestMaxAggregateOutputType = {
    id: number | null
    ownerId: number | null
    isGrant: boolean | null
  }

  export type Stamp_RequestCountAggregateOutputType = {
    id: number
    ownerId: number
    isGrant: number
    _all: number
  }


  export type Stamp_RequestAvgAggregateInputType = {
    id?: true
    ownerId?: true
  }

  export type Stamp_RequestSumAggregateInputType = {
    id?: true
    ownerId?: true
  }

  export type Stamp_RequestMinAggregateInputType = {
    id?: true
    ownerId?: true
    isGrant?: true
  }

  export type Stamp_RequestMaxAggregateInputType = {
    id?: true
    ownerId?: true
    isGrant?: true
  }

  export type Stamp_RequestCountAggregateInputType = {
    id?: true
    ownerId?: true
    isGrant?: true
    _all?: true
  }

  export type Stamp_RequestAggregateArgs = {
    /**
     * Filter which Stamp_Request to aggregate.
     */
    where?: Stamp_RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stamp_Requests to fetch.
     */
    orderBy?: Enumerable<Stamp_RequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Stamp_RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stamp_Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stamp_Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stamp_Requests
    **/
    _count?: true | Stamp_RequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Stamp_RequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Stamp_RequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Stamp_RequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Stamp_RequestMaxAggregateInputType
  }

  export type GetStamp_RequestAggregateType<T extends Stamp_RequestAggregateArgs> = {
        [P in keyof T & keyof AggregateStamp_Request]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStamp_Request[P]>
      : GetScalarType<T[P], AggregateStamp_Request[P]>
  }




  export type Stamp_RequestGroupByArgs = {
    where?: Stamp_RequestWhereInput
    orderBy?: Enumerable<Stamp_RequestOrderByWithAggregationInput>
    by: Stamp_RequestScalarFieldEnum[]
    having?: Stamp_RequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Stamp_RequestCountAggregateInputType | true
    _avg?: Stamp_RequestAvgAggregateInputType
    _sum?: Stamp_RequestSumAggregateInputType
    _min?: Stamp_RequestMinAggregateInputType
    _max?: Stamp_RequestMaxAggregateInputType
  }


  export type Stamp_RequestGroupByOutputType = {
    id: number
    ownerId: number
    isGrant: boolean
    _count: Stamp_RequestCountAggregateOutputType | null
    _avg: Stamp_RequestAvgAggregateOutputType | null
    _sum: Stamp_RequestSumAggregateOutputType | null
    _min: Stamp_RequestMinAggregateOutputType | null
    _max: Stamp_RequestMaxAggregateOutputType | null
  }

  type GetStamp_RequestGroupByPayload<T extends Stamp_RequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Stamp_RequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Stamp_RequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Stamp_RequestGroupByOutputType[P]>
            : GetScalarType<T[P], Stamp_RequestGroupByOutputType[P]>
        }
      >
    >


  export type Stamp_RequestSelect = {
    id?: boolean
    ownerId?: boolean
    isGrant?: boolean
    Store_Owner?: boolean | Store_OwnerArgs
  }


  export type Stamp_RequestInclude = {
    Store_Owner?: boolean | Store_OwnerArgs
  }

  export type Stamp_RequestGetPayload<S extends boolean | null | undefined | Stamp_RequestArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Stamp_Request :
    S extends undefined ? never :
    S extends { include: any } & (Stamp_RequestArgs | Stamp_RequestFindManyArgs)
    ? Stamp_Request  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Store_Owner' ? Store_OwnerGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (Stamp_RequestArgs | Stamp_RequestFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Store_Owner' ? Store_OwnerGetPayload<S['select'][P]> :  P extends keyof Stamp_Request ? Stamp_Request[P] : never
  } 
      : Stamp_Request


  type Stamp_RequestCountArgs = 
    Omit<Stamp_RequestFindManyArgs, 'select' | 'include'> & {
      select?: Stamp_RequestCountAggregateInputType | true
    }

  export interface Stamp_RequestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Stamp_Request that matches the filter.
     * @param {Stamp_RequestFindUniqueArgs} args - Arguments to find a Stamp_Request
     * @example
     * // Get one Stamp_Request
     * const stamp_Request = await prisma.stamp_Request.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Stamp_RequestFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Stamp_RequestFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Stamp_Request'> extends True ? Prisma__Stamp_RequestClient<Stamp_RequestGetPayload<T>> : Prisma__Stamp_RequestClient<Stamp_RequestGetPayload<T> | null, null>

    /**
     * Find one Stamp_Request that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Stamp_RequestFindUniqueOrThrowArgs} args - Arguments to find a Stamp_Request
     * @example
     * // Get one Stamp_Request
     * const stamp_Request = await prisma.stamp_Request.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Stamp_RequestFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Stamp_RequestFindUniqueOrThrowArgs>
    ): Prisma__Stamp_RequestClient<Stamp_RequestGetPayload<T>>

    /**
     * Find the first Stamp_Request that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stamp_RequestFindFirstArgs} args - Arguments to find a Stamp_Request
     * @example
     * // Get one Stamp_Request
     * const stamp_Request = await prisma.stamp_Request.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Stamp_RequestFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Stamp_RequestFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Stamp_Request'> extends True ? Prisma__Stamp_RequestClient<Stamp_RequestGetPayload<T>> : Prisma__Stamp_RequestClient<Stamp_RequestGetPayload<T> | null, null>

    /**
     * Find the first Stamp_Request that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stamp_RequestFindFirstOrThrowArgs} args - Arguments to find a Stamp_Request
     * @example
     * // Get one Stamp_Request
     * const stamp_Request = await prisma.stamp_Request.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Stamp_RequestFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Stamp_RequestFindFirstOrThrowArgs>
    ): Prisma__Stamp_RequestClient<Stamp_RequestGetPayload<T>>

    /**
     * Find zero or more Stamp_Requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stamp_RequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stamp_Requests
     * const stamp_Requests = await prisma.stamp_Request.findMany()
     * 
     * // Get first 10 Stamp_Requests
     * const stamp_Requests = await prisma.stamp_Request.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stamp_RequestWithIdOnly = await prisma.stamp_Request.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Stamp_RequestFindManyArgs>(
      args?: SelectSubset<T, Stamp_RequestFindManyArgs>
    ): Prisma.PrismaPromise<Array<Stamp_RequestGetPayload<T>>>

    /**
     * Create a Stamp_Request.
     * @param {Stamp_RequestCreateArgs} args - Arguments to create a Stamp_Request.
     * @example
     * // Create one Stamp_Request
     * const Stamp_Request = await prisma.stamp_Request.create({
     *   data: {
     *     // ... data to create a Stamp_Request
     *   }
     * })
     * 
    **/
    create<T extends Stamp_RequestCreateArgs>(
      args: SelectSubset<T, Stamp_RequestCreateArgs>
    ): Prisma__Stamp_RequestClient<Stamp_RequestGetPayload<T>>

    /**
     * Create many Stamp_Requests.
     *     @param {Stamp_RequestCreateManyArgs} args - Arguments to create many Stamp_Requests.
     *     @example
     *     // Create many Stamp_Requests
     *     const stamp_Request = await prisma.stamp_Request.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Stamp_RequestCreateManyArgs>(
      args?: SelectSubset<T, Stamp_RequestCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stamp_Request.
     * @param {Stamp_RequestDeleteArgs} args - Arguments to delete one Stamp_Request.
     * @example
     * // Delete one Stamp_Request
     * const Stamp_Request = await prisma.stamp_Request.delete({
     *   where: {
     *     // ... filter to delete one Stamp_Request
     *   }
     * })
     * 
    **/
    delete<T extends Stamp_RequestDeleteArgs>(
      args: SelectSubset<T, Stamp_RequestDeleteArgs>
    ): Prisma__Stamp_RequestClient<Stamp_RequestGetPayload<T>>

    /**
     * Update one Stamp_Request.
     * @param {Stamp_RequestUpdateArgs} args - Arguments to update one Stamp_Request.
     * @example
     * // Update one Stamp_Request
     * const stamp_Request = await prisma.stamp_Request.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Stamp_RequestUpdateArgs>(
      args: SelectSubset<T, Stamp_RequestUpdateArgs>
    ): Prisma__Stamp_RequestClient<Stamp_RequestGetPayload<T>>

    /**
     * Delete zero or more Stamp_Requests.
     * @param {Stamp_RequestDeleteManyArgs} args - Arguments to filter Stamp_Requests to delete.
     * @example
     * // Delete a few Stamp_Requests
     * const { count } = await prisma.stamp_Request.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Stamp_RequestDeleteManyArgs>(
      args?: SelectSubset<T, Stamp_RequestDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stamp_Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stamp_RequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stamp_Requests
     * const stamp_Request = await prisma.stamp_Request.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Stamp_RequestUpdateManyArgs>(
      args: SelectSubset<T, Stamp_RequestUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stamp_Request.
     * @param {Stamp_RequestUpsertArgs} args - Arguments to update or create a Stamp_Request.
     * @example
     * // Update or create a Stamp_Request
     * const stamp_Request = await prisma.stamp_Request.upsert({
     *   create: {
     *     // ... data to create a Stamp_Request
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stamp_Request we want to update
     *   }
     * })
    **/
    upsert<T extends Stamp_RequestUpsertArgs>(
      args: SelectSubset<T, Stamp_RequestUpsertArgs>
    ): Prisma__Stamp_RequestClient<Stamp_RequestGetPayload<T>>

    /**
     * Count the number of Stamp_Requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stamp_RequestCountArgs} args - Arguments to filter Stamp_Requests to count.
     * @example
     * // Count the number of Stamp_Requests
     * const count = await prisma.stamp_Request.count({
     *   where: {
     *     // ... the filter for the Stamp_Requests we want to count
     *   }
     * })
    **/
    count<T extends Stamp_RequestCountArgs>(
      args?: Subset<T, Stamp_RequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Stamp_RequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stamp_Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stamp_RequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Stamp_RequestAggregateArgs>(args: Subset<T, Stamp_RequestAggregateArgs>): Prisma.PrismaPromise<GetStamp_RequestAggregateType<T>>

    /**
     * Group by Stamp_Request.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stamp_RequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Stamp_RequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Stamp_RequestGroupByArgs['orderBy'] }
        : { orderBy?: Stamp_RequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Stamp_RequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStamp_RequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Stamp_Request.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Stamp_RequestClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Store_Owner<T extends Store_OwnerArgs= {}>(args?: Subset<T, Store_OwnerArgs>): Prisma__Store_OwnerClient<Store_OwnerGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Stamp_Request base type for findUnique actions
   */
  export type Stamp_RequestFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Stamp_Request
     */
    select?: Stamp_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Stamp_RequestInclude | null
    /**
     * Filter, which Stamp_Request to fetch.
     */
    where: Stamp_RequestWhereUniqueInput
  }

  /**
   * Stamp_Request findUnique
   */
  export interface Stamp_RequestFindUniqueArgs extends Stamp_RequestFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Stamp_Request findUniqueOrThrow
   */
  export type Stamp_RequestFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Stamp_Request
     */
    select?: Stamp_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Stamp_RequestInclude | null
    /**
     * Filter, which Stamp_Request to fetch.
     */
    where: Stamp_RequestWhereUniqueInput
  }


  /**
   * Stamp_Request base type for findFirst actions
   */
  export type Stamp_RequestFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Stamp_Request
     */
    select?: Stamp_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Stamp_RequestInclude | null
    /**
     * Filter, which Stamp_Request to fetch.
     */
    where?: Stamp_RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stamp_Requests to fetch.
     */
    orderBy?: Enumerable<Stamp_RequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stamp_Requests.
     */
    cursor?: Stamp_RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stamp_Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stamp_Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stamp_Requests.
     */
    distinct?: Enumerable<Stamp_RequestScalarFieldEnum>
  }

  /**
   * Stamp_Request findFirst
   */
  export interface Stamp_RequestFindFirstArgs extends Stamp_RequestFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Stamp_Request findFirstOrThrow
   */
  export type Stamp_RequestFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Stamp_Request
     */
    select?: Stamp_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Stamp_RequestInclude | null
    /**
     * Filter, which Stamp_Request to fetch.
     */
    where?: Stamp_RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stamp_Requests to fetch.
     */
    orderBy?: Enumerable<Stamp_RequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stamp_Requests.
     */
    cursor?: Stamp_RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stamp_Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stamp_Requests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stamp_Requests.
     */
    distinct?: Enumerable<Stamp_RequestScalarFieldEnum>
  }


  /**
   * Stamp_Request findMany
   */
  export type Stamp_RequestFindManyArgs = {
    /**
     * Select specific fields to fetch from the Stamp_Request
     */
    select?: Stamp_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Stamp_RequestInclude | null
    /**
     * Filter, which Stamp_Requests to fetch.
     */
    where?: Stamp_RequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stamp_Requests to fetch.
     */
    orderBy?: Enumerable<Stamp_RequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stamp_Requests.
     */
    cursor?: Stamp_RequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stamp_Requests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stamp_Requests.
     */
    skip?: number
    distinct?: Enumerable<Stamp_RequestScalarFieldEnum>
  }


  /**
   * Stamp_Request create
   */
  export type Stamp_RequestCreateArgs = {
    /**
     * Select specific fields to fetch from the Stamp_Request
     */
    select?: Stamp_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Stamp_RequestInclude | null
    /**
     * The data needed to create a Stamp_Request.
     */
    data: XOR<Stamp_RequestCreateInput, Stamp_RequestUncheckedCreateInput>
  }


  /**
   * Stamp_Request createMany
   */
  export type Stamp_RequestCreateManyArgs = {
    /**
     * The data used to create many Stamp_Requests.
     */
    data: Enumerable<Stamp_RequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Stamp_Request update
   */
  export type Stamp_RequestUpdateArgs = {
    /**
     * Select specific fields to fetch from the Stamp_Request
     */
    select?: Stamp_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Stamp_RequestInclude | null
    /**
     * The data needed to update a Stamp_Request.
     */
    data: XOR<Stamp_RequestUpdateInput, Stamp_RequestUncheckedUpdateInput>
    /**
     * Choose, which Stamp_Request to update.
     */
    where: Stamp_RequestWhereUniqueInput
  }


  /**
   * Stamp_Request updateMany
   */
  export type Stamp_RequestUpdateManyArgs = {
    /**
     * The data used to update Stamp_Requests.
     */
    data: XOR<Stamp_RequestUpdateManyMutationInput, Stamp_RequestUncheckedUpdateManyInput>
    /**
     * Filter which Stamp_Requests to update
     */
    where?: Stamp_RequestWhereInput
  }


  /**
   * Stamp_Request upsert
   */
  export type Stamp_RequestUpsertArgs = {
    /**
     * Select specific fields to fetch from the Stamp_Request
     */
    select?: Stamp_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Stamp_RequestInclude | null
    /**
     * The filter to search for the Stamp_Request to update in case it exists.
     */
    where: Stamp_RequestWhereUniqueInput
    /**
     * In case the Stamp_Request found by the `where` argument doesn't exist, create a new Stamp_Request with this data.
     */
    create: XOR<Stamp_RequestCreateInput, Stamp_RequestUncheckedCreateInput>
    /**
     * In case the Stamp_Request was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Stamp_RequestUpdateInput, Stamp_RequestUncheckedUpdateInput>
  }


  /**
   * Stamp_Request delete
   */
  export type Stamp_RequestDeleteArgs = {
    /**
     * Select specific fields to fetch from the Stamp_Request
     */
    select?: Stamp_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Stamp_RequestInclude | null
    /**
     * Filter which Stamp_Request to delete.
     */
    where: Stamp_RequestWhereUniqueInput
  }


  /**
   * Stamp_Request deleteMany
   */
  export type Stamp_RequestDeleteManyArgs = {
    /**
     * Filter which Stamp_Requests to delete
     */
    where?: Stamp_RequestWhereInput
  }


  /**
   * Stamp_Request without action
   */
  export type Stamp_RequestArgs = {
    /**
     * Select specific fields to fetch from the Stamp_Request
     */
    select?: Stamp_RequestSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Stamp_RequestInclude | null
  }



  /**
   * Model Store_Like
   */


  export type AggregateStore_Like = {
    _count: Store_LikeCountAggregateOutputType | null
    _avg: Store_LikeAvgAggregateOutputType | null
    _sum: Store_LikeSumAggregateOutputType | null
    _min: Store_LikeMinAggregateOutputType | null
    _max: Store_LikeMaxAggregateOutputType | null
  }

  export type Store_LikeAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    storeId: number | null
  }

  export type Store_LikeSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    storeId: number | null
  }

  export type Store_LikeMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    storeId: number | null
  }

  export type Store_LikeMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    storeId: number | null
  }

  export type Store_LikeCountAggregateOutputType = {
    id: number
    customerId: number
    storeId: number
    _all: number
  }


  export type Store_LikeAvgAggregateInputType = {
    id?: true
    customerId?: true
    storeId?: true
  }

  export type Store_LikeSumAggregateInputType = {
    id?: true
    customerId?: true
    storeId?: true
  }

  export type Store_LikeMinAggregateInputType = {
    id?: true
    customerId?: true
    storeId?: true
  }

  export type Store_LikeMaxAggregateInputType = {
    id?: true
    customerId?: true
    storeId?: true
  }

  export type Store_LikeCountAggregateInputType = {
    id?: true
    customerId?: true
    storeId?: true
    _all?: true
  }

  export type Store_LikeAggregateArgs = {
    /**
     * Filter which Store_Like to aggregate.
     */
    where?: Store_LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Likes to fetch.
     */
    orderBy?: Enumerable<Store_LikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Store_LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Store_Likes
    **/
    _count?: true | Store_LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Store_LikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Store_LikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Store_LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Store_LikeMaxAggregateInputType
  }

  export type GetStore_LikeAggregateType<T extends Store_LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateStore_Like]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore_Like[P]>
      : GetScalarType<T[P], AggregateStore_Like[P]>
  }




  export type Store_LikeGroupByArgs = {
    where?: Store_LikeWhereInput
    orderBy?: Enumerable<Store_LikeOrderByWithAggregationInput>
    by: Store_LikeScalarFieldEnum[]
    having?: Store_LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Store_LikeCountAggregateInputType | true
    _avg?: Store_LikeAvgAggregateInputType
    _sum?: Store_LikeSumAggregateInputType
    _min?: Store_LikeMinAggregateInputType
    _max?: Store_LikeMaxAggregateInputType
  }


  export type Store_LikeGroupByOutputType = {
    id: number
    customerId: number
    storeId: number
    _count: Store_LikeCountAggregateOutputType | null
    _avg: Store_LikeAvgAggregateOutputType | null
    _sum: Store_LikeSumAggregateOutputType | null
    _min: Store_LikeMinAggregateOutputType | null
    _max: Store_LikeMaxAggregateOutputType | null
  }

  type GetStore_LikeGroupByPayload<T extends Store_LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Store_LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Store_LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Store_LikeGroupByOutputType[P]>
            : GetScalarType<T[P], Store_LikeGroupByOutputType[P]>
        }
      >
    >


  export type Store_LikeSelect = {
    id?: boolean
    customerId?: boolean
    storeId?: boolean
    Customer?: boolean | CustomerArgs
    Store?: boolean | StoreArgs
  }


  export type Store_LikeInclude = {
    Customer?: boolean | CustomerArgs
    Store?: boolean | StoreArgs
  }

  export type Store_LikeGetPayload<S extends boolean | null | undefined | Store_LikeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Store_Like :
    S extends undefined ? never :
    S extends { include: any } & (Store_LikeArgs | Store_LikeFindManyArgs)
    ? Store_Like  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Customer' ? CustomerGetPayload<S['include'][P]> :
        P extends 'Store' ? StoreGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (Store_LikeArgs | Store_LikeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Customer' ? CustomerGetPayload<S['select'][P]> :
        P extends 'Store' ? StoreGetPayload<S['select'][P]> :  P extends keyof Store_Like ? Store_Like[P] : never
  } 
      : Store_Like


  type Store_LikeCountArgs = 
    Omit<Store_LikeFindManyArgs, 'select' | 'include'> & {
      select?: Store_LikeCountAggregateInputType | true
    }

  export interface Store_LikeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Store_Like that matches the filter.
     * @param {Store_LikeFindUniqueArgs} args - Arguments to find a Store_Like
     * @example
     * // Get one Store_Like
     * const store_Like = await prisma.store_Like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Store_LikeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, Store_LikeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Store_Like'> extends True ? Prisma__Store_LikeClient<Store_LikeGetPayload<T>> : Prisma__Store_LikeClient<Store_LikeGetPayload<T> | null, null>

    /**
     * Find one Store_Like that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Store_LikeFindUniqueOrThrowArgs} args - Arguments to find a Store_Like
     * @example
     * // Get one Store_Like
     * const store_Like = await prisma.store_Like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Store_LikeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, Store_LikeFindUniqueOrThrowArgs>
    ): Prisma__Store_LikeClient<Store_LikeGetPayload<T>>

    /**
     * Find the first Store_Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_LikeFindFirstArgs} args - Arguments to find a Store_Like
     * @example
     * // Get one Store_Like
     * const store_Like = await prisma.store_Like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Store_LikeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, Store_LikeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Store_Like'> extends True ? Prisma__Store_LikeClient<Store_LikeGetPayload<T>> : Prisma__Store_LikeClient<Store_LikeGetPayload<T> | null, null>

    /**
     * Find the first Store_Like that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_LikeFindFirstOrThrowArgs} args - Arguments to find a Store_Like
     * @example
     * // Get one Store_Like
     * const store_Like = await prisma.store_Like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Store_LikeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, Store_LikeFindFirstOrThrowArgs>
    ): Prisma__Store_LikeClient<Store_LikeGetPayload<T>>

    /**
     * Find zero or more Store_Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_LikeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Store_Likes
     * const store_Likes = await prisma.store_Like.findMany()
     * 
     * // Get first 10 Store_Likes
     * const store_Likes = await prisma.store_Like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const store_LikeWithIdOnly = await prisma.store_Like.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Store_LikeFindManyArgs>(
      args?: SelectSubset<T, Store_LikeFindManyArgs>
    ): Prisma.PrismaPromise<Array<Store_LikeGetPayload<T>>>

    /**
     * Create a Store_Like.
     * @param {Store_LikeCreateArgs} args - Arguments to create a Store_Like.
     * @example
     * // Create one Store_Like
     * const Store_Like = await prisma.store_Like.create({
     *   data: {
     *     // ... data to create a Store_Like
     *   }
     * })
     * 
    **/
    create<T extends Store_LikeCreateArgs>(
      args: SelectSubset<T, Store_LikeCreateArgs>
    ): Prisma__Store_LikeClient<Store_LikeGetPayload<T>>

    /**
     * Create many Store_Likes.
     *     @param {Store_LikeCreateManyArgs} args - Arguments to create many Store_Likes.
     *     @example
     *     // Create many Store_Likes
     *     const store_Like = await prisma.store_Like.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Store_LikeCreateManyArgs>(
      args?: SelectSubset<T, Store_LikeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Store_Like.
     * @param {Store_LikeDeleteArgs} args - Arguments to delete one Store_Like.
     * @example
     * // Delete one Store_Like
     * const Store_Like = await prisma.store_Like.delete({
     *   where: {
     *     // ... filter to delete one Store_Like
     *   }
     * })
     * 
    **/
    delete<T extends Store_LikeDeleteArgs>(
      args: SelectSubset<T, Store_LikeDeleteArgs>
    ): Prisma__Store_LikeClient<Store_LikeGetPayload<T>>

    /**
     * Update one Store_Like.
     * @param {Store_LikeUpdateArgs} args - Arguments to update one Store_Like.
     * @example
     * // Update one Store_Like
     * const store_Like = await prisma.store_Like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Store_LikeUpdateArgs>(
      args: SelectSubset<T, Store_LikeUpdateArgs>
    ): Prisma__Store_LikeClient<Store_LikeGetPayload<T>>

    /**
     * Delete zero or more Store_Likes.
     * @param {Store_LikeDeleteManyArgs} args - Arguments to filter Store_Likes to delete.
     * @example
     * // Delete a few Store_Likes
     * const { count } = await prisma.store_Like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Store_LikeDeleteManyArgs>(
      args?: SelectSubset<T, Store_LikeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Store_Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Store_Likes
     * const store_Like = await prisma.store_Like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Store_LikeUpdateManyArgs>(
      args: SelectSubset<T, Store_LikeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Store_Like.
     * @param {Store_LikeUpsertArgs} args - Arguments to update or create a Store_Like.
     * @example
     * // Update or create a Store_Like
     * const store_Like = await prisma.store_Like.upsert({
     *   create: {
     *     // ... data to create a Store_Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store_Like we want to update
     *   }
     * })
    **/
    upsert<T extends Store_LikeUpsertArgs>(
      args: SelectSubset<T, Store_LikeUpsertArgs>
    ): Prisma__Store_LikeClient<Store_LikeGetPayload<T>>

    /**
     * Count the number of Store_Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_LikeCountArgs} args - Arguments to filter Store_Likes to count.
     * @example
     * // Count the number of Store_Likes
     * const count = await prisma.store_Like.count({
     *   where: {
     *     // ... the filter for the Store_Likes we want to count
     *   }
     * })
    **/
    count<T extends Store_LikeCountArgs>(
      args?: Subset<T, Store_LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Store_LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store_Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Store_LikeAggregateArgs>(args: Subset<T, Store_LikeAggregateArgs>): Prisma.PrismaPromise<GetStore_LikeAggregateType<T>>

    /**
     * Group by Store_Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Store_LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Store_LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Store_LikeGroupByArgs['orderBy'] }
        : { orderBy?: Store_LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Store_LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStore_LikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Store_Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Store_LikeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Customer<T extends CustomerArgs= {}>(args?: Subset<T, CustomerArgs>): Prisma__CustomerClient<CustomerGetPayload<T> | Null>;

    Store<T extends StoreArgs= {}>(args?: Subset<T, StoreArgs>): Prisma__StoreClient<StoreGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Store_Like base type for findUnique actions
   */
  export type Store_LikeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Store_Like
     */
    select?: Store_LikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_LikeInclude | null
    /**
     * Filter, which Store_Like to fetch.
     */
    where: Store_LikeWhereUniqueInput
  }

  /**
   * Store_Like findUnique
   */
  export interface Store_LikeFindUniqueArgs extends Store_LikeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Store_Like findUniqueOrThrow
   */
  export type Store_LikeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Store_Like
     */
    select?: Store_LikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_LikeInclude | null
    /**
     * Filter, which Store_Like to fetch.
     */
    where: Store_LikeWhereUniqueInput
  }


  /**
   * Store_Like base type for findFirst actions
   */
  export type Store_LikeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Store_Like
     */
    select?: Store_LikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_LikeInclude | null
    /**
     * Filter, which Store_Like to fetch.
     */
    where?: Store_LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Likes to fetch.
     */
    orderBy?: Enumerable<Store_LikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Store_Likes.
     */
    cursor?: Store_LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Store_Likes.
     */
    distinct?: Enumerable<Store_LikeScalarFieldEnum>
  }

  /**
   * Store_Like findFirst
   */
  export interface Store_LikeFindFirstArgs extends Store_LikeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Store_Like findFirstOrThrow
   */
  export type Store_LikeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Store_Like
     */
    select?: Store_LikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_LikeInclude | null
    /**
     * Filter, which Store_Like to fetch.
     */
    where?: Store_LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Likes to fetch.
     */
    orderBy?: Enumerable<Store_LikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Store_Likes.
     */
    cursor?: Store_LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Store_Likes.
     */
    distinct?: Enumerable<Store_LikeScalarFieldEnum>
  }


  /**
   * Store_Like findMany
   */
  export type Store_LikeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Store_Like
     */
    select?: Store_LikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_LikeInclude | null
    /**
     * Filter, which Store_Likes to fetch.
     */
    where?: Store_LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Store_Likes to fetch.
     */
    orderBy?: Enumerable<Store_LikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Store_Likes.
     */
    cursor?: Store_LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Store_Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Store_Likes.
     */
    skip?: number
    distinct?: Enumerable<Store_LikeScalarFieldEnum>
  }


  /**
   * Store_Like create
   */
  export type Store_LikeCreateArgs = {
    /**
     * Select specific fields to fetch from the Store_Like
     */
    select?: Store_LikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_LikeInclude | null
    /**
     * The data needed to create a Store_Like.
     */
    data: XOR<Store_LikeCreateInput, Store_LikeUncheckedCreateInput>
  }


  /**
   * Store_Like createMany
   */
  export type Store_LikeCreateManyArgs = {
    /**
     * The data used to create many Store_Likes.
     */
    data: Enumerable<Store_LikeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Store_Like update
   */
  export type Store_LikeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Store_Like
     */
    select?: Store_LikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_LikeInclude | null
    /**
     * The data needed to update a Store_Like.
     */
    data: XOR<Store_LikeUpdateInput, Store_LikeUncheckedUpdateInput>
    /**
     * Choose, which Store_Like to update.
     */
    where: Store_LikeWhereUniqueInput
  }


  /**
   * Store_Like updateMany
   */
  export type Store_LikeUpdateManyArgs = {
    /**
     * The data used to update Store_Likes.
     */
    data: XOR<Store_LikeUpdateManyMutationInput, Store_LikeUncheckedUpdateManyInput>
    /**
     * Filter which Store_Likes to update
     */
    where?: Store_LikeWhereInput
  }


  /**
   * Store_Like upsert
   */
  export type Store_LikeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Store_Like
     */
    select?: Store_LikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_LikeInclude | null
    /**
     * The filter to search for the Store_Like to update in case it exists.
     */
    where: Store_LikeWhereUniqueInput
    /**
     * In case the Store_Like found by the `where` argument doesn't exist, create a new Store_Like with this data.
     */
    create: XOR<Store_LikeCreateInput, Store_LikeUncheckedCreateInput>
    /**
     * In case the Store_Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Store_LikeUpdateInput, Store_LikeUncheckedUpdateInput>
  }


  /**
   * Store_Like delete
   */
  export type Store_LikeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Store_Like
     */
    select?: Store_LikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_LikeInclude | null
    /**
     * Filter which Store_Like to delete.
     */
    where: Store_LikeWhereUniqueInput
  }


  /**
   * Store_Like deleteMany
   */
  export type Store_LikeDeleteManyArgs = {
    /**
     * Filter which Store_Likes to delete
     */
    where?: Store_LikeWhereInput
  }


  /**
   * Store_Like without action
   */
  export type Store_LikeArgs = {
    /**
     * Select specific fields to fetch from the Store_Like
     */
    select?: Store_LikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Store_LikeInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const Alim_CustomerScalarFieldEnum: {
    id: 'id',
    loginId: 'loginId',
    name: 'name',
    phone: 'phone',
    customerId: 'customerId',
    requestId: 'requestId'
  };

  export type Alim_CustomerScalarFieldEnum = (typeof Alim_CustomerScalarFieldEnum)[keyof typeof Alim_CustomerScalarFieldEnum]


  export const Alim_RequestScalarFieldEnum: {
    id: 'id',
    category: 'category',
    content: 'content',
    isMessage: 'isMessage',
    isKakao: 'isKakao',
    writerId: 'writerId',
    timestamp: 'timestamp'
  };

  export type Alim_RequestScalarFieldEnum = (typeof Alim_RequestScalarFieldEnum)[keyof typeof Alim_RequestScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    loginId: 'loginId',
    password: 'password',
    name: 'name',
    email: 'email',
    phone: 'phone',
    termsAgree: 'termsAgree',
    marketingAgree: 'marketingAgree',
    storeId: 'storeId',
    image: 'image',
    stampCount: 'stampCount',
    couponCount: 'couponCount'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const DeliveryScalarFieldEnum: {
    id: 'id',
    reward: 'reward',
    customer: 'customer',
    phone: 'phone',
    address: 'address',
    detailAddress: 'detailAddress',
    message: 'message',
    isGrant: 'isGrant',
    customerId: 'customerId'
  };

  export type DeliveryScalarFieldEnum = (typeof DeliveryScalarFieldEnum)[keyof typeof DeliveryScalarFieldEnum]


  export const ManagerScalarFieldEnum: {
    id: 'id',
    loginId: 'loginId',
    password: 'password'
  };

  export type ManagerScalarFieldEnum = (typeof ManagerScalarFieldEnum)[keyof typeof ManagerScalarFieldEnum]


  export const NoticeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    image: 'image',
    timestamp: 'timestamp'
  };

  export type NoticeScalarFieldEnum = (typeof NoticeScalarFieldEnum)[keyof typeof NoticeScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const StampScalarFieldEnum: {
    id: 'id',
    randNum: 'randNum',
    timestamp: 'timestamp',
    customerId: 'customerId',
    storeId: 'storeId',
    store: 'store',
    tourId: 'tourId',
    tour: 'tour'
  };

  export type StampScalarFieldEnum = (typeof StampScalarFieldEnum)[keyof typeof StampScalarFieldEnum]


  export const Stamp_RequestScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    isGrant: 'isGrant'
  };

  export type Stamp_RequestScalarFieldEnum = (typeof Stamp_RequestScalarFieldEnum)[keyof typeof Stamp_RequestScalarFieldEnum]


  export const StoreScalarFieldEnum: {
    id: 'id',
    storeName: 'storeName',
    description: 'description',
    officeHour: 'officeHour',
    dayOff: 'dayOff',
    homepage: 'homepage',
    image: 'image',
    category: 'category',
    ownerId: 'ownerId',
    tourId: 'tourId',
    x: 'x',
    y: 'y'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const Store_LikeScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    storeId: 'storeId'
  };

  export type Store_LikeScalarFieldEnum = (typeof Store_LikeScalarFieldEnum)[keyof typeof Store_LikeScalarFieldEnum]


  export const Store_MenuScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    image: 'image',
    storeId: 'storeId'
  };

  export type Store_MenuScalarFieldEnum = (typeof Store_MenuScalarFieldEnum)[keyof typeof Store_MenuScalarFieldEnum]


  export const Store_NoticeScalarFieldEnum: {
    id: 'id',
    category: 'category',
    title: 'title',
    content: 'content',
    image: 'image',
    storeId: 'storeId',
    createdTime: 'createdTime'
  };

  export type Store_NoticeScalarFieldEnum = (typeof Store_NoticeScalarFieldEnum)[keyof typeof Store_NoticeScalarFieldEnum]


  export const Store_OwnerScalarFieldEnum: {
    id: 'id',
    loginId: 'loginId',
    password: 'password',
    store: 'store',
    director: 'director',
    phone: 'phone',
    email: 'email',
    address: 'address',
    detailAddress: 'detailAddress',
    licenseNumber: 'licenseNumber',
    licenseImage: 'licenseImage',
    authorized: 'authorized',
    termsAgree: 'termsAgree',
    marketingAgree: 'marketingAgree',
    storeId: 'storeId',
    stampAuthorized: 'stampAuthorized',
    profileImage: 'profileImage'
  };

  export type Store_OwnerScalarFieldEnum = (typeof Store_OwnerScalarFieldEnum)[keyof typeof Store_OwnerScalarFieldEnum]


  export const Store_ProductScalarFieldEnum: {
    id: 'id',
    category: 'category',
    name: 'name',
    price: 'price',
    discountPrice: 'discountPrice',
    url: 'url',
    image: 'image',
    storeId: 'storeId'
  };

  export type Store_ProductScalarFieldEnum = (typeof Store_ProductScalarFieldEnum)[keyof typeof Store_ProductScalarFieldEnum]


  export const Store_ReviewScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    image: 'image',
    timestamp: 'timestamp',
    writerId: 'writerId',
    storeId: 'storeId',
    writerName: 'writerName'
  };

  export type Store_ReviewScalarFieldEnum = (typeof Store_ReviewScalarFieldEnum)[keyof typeof Store_ReviewScalarFieldEnum]


  export const TourScalarFieldEnum: {
    id: 'id',
    keyword: 'keyword',
    title: 'title',
    reward: 'reward',
    image: 'image',
    cafeList: 'cafeList'
  };

  export type TourScalarFieldEnum = (typeof TourScalarFieldEnum)[keyof typeof TourScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  /**
   * Deep Input Types
   */


  export type CustomerWhereInput = {
    AND?: Enumerable<CustomerWhereInput>
    OR?: Enumerable<CustomerWhereInput>
    NOT?: Enumerable<CustomerWhereInput>
    id?: IntFilter | number
    loginId?: StringFilter | string
    password?: StringFilter | string
    name?: StringFilter | string
    email?: StringFilter | string
    phone?: StringFilter | string
    termsAgree?: BoolFilter | boolean
    marketingAgree?: BoolNullableFilter | boolean | null
    storeId?: IntNullableFilter | number | null
    image?: StringNullableFilter | string | null
    stampCount?: IntFilter | number
    couponCount?: IntFilter | number
    Alim_Customer?: Alim_CustomerListRelationFilter
    Store?: XOR<StoreRelationFilter, StoreWhereInput> | null
    Delivery?: DeliveryListRelationFilter
    Stamp?: StampListRelationFilter
    Store_Like?: Store_LikeListRelationFilter
    Store_Review?: Store_ReviewListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    termsAgree?: SortOrder
    marketingAgree?: SortOrder
    storeId?: SortOrder
    image?: SortOrder
    stampCount?: SortOrder
    couponCount?: SortOrder
    Alim_Customer?: Alim_CustomerOrderByRelationAggregateInput
    Store?: StoreOrderByWithRelationInput
    Delivery?: DeliveryOrderByRelationAggregateInput
    Stamp?: StampOrderByRelationAggregateInput
    Store_Like?: Store_LikeOrderByRelationAggregateInput
    Store_Review?: Store_ReviewOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = {
    id?: number
    loginId?: string
    name?: string
    email?: string
  }

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    termsAgree?: SortOrder
    marketingAgree?: SortOrder
    storeId?: SortOrder
    image?: SortOrder
    stampCount?: SortOrder
    couponCount?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    OR?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CustomerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    loginId?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    termsAgree?: BoolWithAggregatesFilter | boolean
    marketingAgree?: BoolNullableWithAggregatesFilter | boolean | null
    storeId?: IntNullableWithAggregatesFilter | number | null
    image?: StringNullableWithAggregatesFilter | string | null
    stampCount?: IntWithAggregatesFilter | number
    couponCount?: IntWithAggregatesFilter | number
  }

  export type DeliveryWhereInput = {
    AND?: Enumerable<DeliveryWhereInput>
    OR?: Enumerable<DeliveryWhereInput>
    NOT?: Enumerable<DeliveryWhereInput>
    id?: IntFilter | number
    reward?: StringFilter | string
    customer?: StringFilter | string
    phone?: StringFilter | string
    address?: StringFilter | string
    detailAddress?: StringNullableFilter | string | null
    message?: StringFilter | string
    isGrant?: BoolNullableFilter | boolean | null
    customerId?: IntFilter | number
    Customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
  }

  export type DeliveryOrderByWithRelationInput = {
    id?: SortOrder
    reward?: SortOrder
    customer?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    detailAddress?: SortOrder
    message?: SortOrder
    isGrant?: SortOrder
    customerId?: SortOrder
    Customer?: CustomerOrderByWithRelationInput
  }

  export type DeliveryWhereUniqueInput = {
    id?: number
  }

  export type DeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    reward?: SortOrder
    customer?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    detailAddress?: SortOrder
    message?: SortOrder
    isGrant?: SortOrder
    customerId?: SortOrder
    _count?: DeliveryCountOrderByAggregateInput
    _avg?: DeliveryAvgOrderByAggregateInput
    _max?: DeliveryMaxOrderByAggregateInput
    _min?: DeliveryMinOrderByAggregateInput
    _sum?: DeliverySumOrderByAggregateInput
  }

  export type DeliveryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DeliveryScalarWhereWithAggregatesInput>
    OR?: Enumerable<DeliveryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DeliveryScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    reward?: StringWithAggregatesFilter | string
    customer?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    detailAddress?: StringNullableWithAggregatesFilter | string | null
    message?: StringWithAggregatesFilter | string
    isGrant?: BoolNullableWithAggregatesFilter | boolean | null
    customerId?: IntWithAggregatesFilter | number
  }

  export type ManagerWhereInput = {
    AND?: Enumerable<ManagerWhereInput>
    OR?: Enumerable<ManagerWhereInput>
    NOT?: Enumerable<ManagerWhereInput>
    id?: IntFilter | number
    loginId?: StringFilter | string
    password?: StringFilter | string
  }

  export type ManagerOrderByWithRelationInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
  }

  export type ManagerWhereUniqueInput = {
    id?: number
    loginId?: string
  }

  export type ManagerOrderByWithAggregationInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    _count?: ManagerCountOrderByAggregateInput
    _avg?: ManagerAvgOrderByAggregateInput
    _max?: ManagerMaxOrderByAggregateInput
    _min?: ManagerMinOrderByAggregateInput
    _sum?: ManagerSumOrderByAggregateInput
  }

  export type ManagerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ManagerScalarWhereWithAggregatesInput>
    OR?: Enumerable<ManagerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ManagerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    loginId?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
  }

  export type StampWhereInput = {
    AND?: Enumerable<StampWhereInput>
    OR?: Enumerable<StampWhereInput>
    NOT?: Enumerable<StampWhereInput>
    id?: IntFilter | number
    randNum?: StringNullableFilter | string | null
    timestamp?: DateTimeNullableFilter | Date | string | null
    customerId?: IntNullableFilter | number | null
    storeId?: IntNullableFilter | number | null
    store?: StringNullableFilter | string | null
    tourId?: IntNullableFilter | number | null
    tour?: StringNullableFilter | string | null
    Customer?: XOR<CustomerRelationFilter, CustomerWhereInput> | null
    Store?: XOR<StoreRelationFilter, StoreWhereInput> | null
    Tour?: XOR<TourRelationFilter, TourWhereInput> | null
  }

  export type StampOrderByWithRelationInput = {
    id?: SortOrder
    randNum?: SortOrder
    timestamp?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
    store?: SortOrder
    tourId?: SortOrder
    tour?: SortOrder
    Customer?: CustomerOrderByWithRelationInput
    Store?: StoreOrderByWithRelationInput
    Tour?: TourOrderByWithRelationInput
  }

  export type StampWhereUniqueInput = {
    id?: number
    randNum?: string
  }

  export type StampOrderByWithAggregationInput = {
    id?: SortOrder
    randNum?: SortOrder
    timestamp?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
    store?: SortOrder
    tourId?: SortOrder
    tour?: SortOrder
    _count?: StampCountOrderByAggregateInput
    _avg?: StampAvgOrderByAggregateInput
    _max?: StampMaxOrderByAggregateInput
    _min?: StampMinOrderByAggregateInput
    _sum?: StampSumOrderByAggregateInput
  }

  export type StampScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StampScalarWhereWithAggregatesInput>
    OR?: Enumerable<StampScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StampScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    randNum?: StringNullableWithAggregatesFilter | string | null
    timestamp?: DateTimeNullableWithAggregatesFilter | Date | string | null
    customerId?: IntNullableWithAggregatesFilter | number | null
    storeId?: IntNullableWithAggregatesFilter | number | null
    store?: StringNullableWithAggregatesFilter | string | null
    tourId?: IntNullableWithAggregatesFilter | number | null
    tour?: StringNullableWithAggregatesFilter | string | null
  }

  export type StoreWhereInput = {
    AND?: Enumerable<StoreWhereInput>
    OR?: Enumerable<StoreWhereInput>
    NOT?: Enumerable<StoreWhereInput>
    id?: IntFilter | number
    storeName?: StringFilter | string
    description?: StringNullableFilter | string | null
    officeHour?: StringNullableFilter | string | null
    dayOff?: StringNullableFilter | string | null
    homepage?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    category?: StringNullableListFilter
    ownerId?: IntFilter | number
    tourId?: IntNullableFilter | number | null
    x?: StringNullableFilter | string | null
    y?: StringNullableFilter | string | null
    Customer?: CustomerListRelationFilter
    Stamp?: StampListRelationFilter
    Store_Owner_Store_ownerIdToStore_Owner?: XOR<Store_OwnerRelationFilter, Store_OwnerWhereInput>
    Tour?: XOR<TourRelationFilter, TourWhereInput> | null
    Store_Like?: Store_LikeListRelationFilter
    Store_Menu?: Store_MenuListRelationFilter
    Store_Notice?: Store_NoticeListRelationFilter
    Store_Owner_Store_Owner_storeIdToStore?: XOR<Store_OwnerRelationFilter, Store_OwnerWhereInput> | null
    Store_Product?: Store_ProductListRelationFilter
    Store_Review?: XOR<Store_ReviewRelationFilter, Store_ReviewWhereInput> | null
  }

  export type StoreOrderByWithRelationInput = {
    id?: SortOrder
    storeName?: SortOrder
    description?: SortOrder
    officeHour?: SortOrder
    dayOff?: SortOrder
    homepage?: SortOrder
    image?: SortOrder
    category?: SortOrder
    ownerId?: SortOrder
    tourId?: SortOrder
    x?: SortOrder
    y?: SortOrder
    Customer?: CustomerOrderByRelationAggregateInput
    Stamp?: StampOrderByRelationAggregateInput
    Store_Owner_Store_ownerIdToStore_Owner?: Store_OwnerOrderByWithRelationInput
    Tour?: TourOrderByWithRelationInput
    Store_Like?: Store_LikeOrderByRelationAggregateInput
    Store_Menu?: Store_MenuOrderByRelationAggregateInput
    Store_Notice?: Store_NoticeOrderByRelationAggregateInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerOrderByWithRelationInput
    Store_Product?: Store_ProductOrderByRelationAggregateInput
    Store_Review?: Store_ReviewOrderByWithRelationInput
  }

  export type StoreWhereUniqueInput = {
    id?: number
    ownerId?: number
  }

  export type StoreOrderByWithAggregationInput = {
    id?: SortOrder
    storeName?: SortOrder
    description?: SortOrder
    officeHour?: SortOrder
    dayOff?: SortOrder
    homepage?: SortOrder
    image?: SortOrder
    category?: SortOrder
    ownerId?: SortOrder
    tourId?: SortOrder
    x?: SortOrder
    y?: SortOrder
    _count?: StoreCountOrderByAggregateInput
    _avg?: StoreAvgOrderByAggregateInput
    _max?: StoreMaxOrderByAggregateInput
    _min?: StoreMinOrderByAggregateInput
    _sum?: StoreSumOrderByAggregateInput
  }

  export type StoreScalarWhereWithAggregatesInput = {
    AND?: Enumerable<StoreScalarWhereWithAggregatesInput>
    OR?: Enumerable<StoreScalarWhereWithAggregatesInput>
    NOT?: Enumerable<StoreScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    storeName?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
    officeHour?: StringNullableWithAggregatesFilter | string | null
    dayOff?: StringNullableWithAggregatesFilter | string | null
    homepage?: StringNullableWithAggregatesFilter | string | null
    image?: StringNullableWithAggregatesFilter | string | null
    category?: StringNullableListFilter
    ownerId?: IntWithAggregatesFilter | number
    tourId?: IntNullableWithAggregatesFilter | number | null
    x?: StringNullableWithAggregatesFilter | string | null
    y?: StringNullableWithAggregatesFilter | string | null
  }

  export type Store_MenuWhereInput = {
    AND?: Enumerable<Store_MenuWhereInput>
    OR?: Enumerable<Store_MenuWhereInput>
    NOT?: Enumerable<Store_MenuWhereInput>
    id?: IntFilter | number
    title?: StringNullableFilter | string | null
    content?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    storeId?: IntNullableFilter | number | null
    Store?: XOR<StoreRelationFilter, StoreWhereInput> | null
  }

  export type Store_MenuOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    storeId?: SortOrder
    Store?: StoreOrderByWithRelationInput
  }

  export type Store_MenuWhereUniqueInput = {
    id?: number
  }

  export type Store_MenuOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    storeId?: SortOrder
    _count?: Store_MenuCountOrderByAggregateInput
    _avg?: Store_MenuAvgOrderByAggregateInput
    _max?: Store_MenuMaxOrderByAggregateInput
    _min?: Store_MenuMinOrderByAggregateInput
    _sum?: Store_MenuSumOrderByAggregateInput
  }

  export type Store_MenuScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Store_MenuScalarWhereWithAggregatesInput>
    OR?: Enumerable<Store_MenuScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Store_MenuScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringNullableWithAggregatesFilter | string | null
    content?: StringNullableWithAggregatesFilter | string | null
    image?: StringNullableWithAggregatesFilter | string | null
    storeId?: IntNullableWithAggregatesFilter | number | null
  }

  export type Store_NoticeWhereInput = {
    AND?: Enumerable<Store_NoticeWhereInput>
    OR?: Enumerable<Store_NoticeWhereInput>
    NOT?: Enumerable<Store_NoticeWhereInput>
    id?: IntFilter | number
    category?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    content?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    storeId?: IntNullableFilter | number | null
    createdTime?: DateTimeNullableFilter | Date | string | null
    Store?: XOR<StoreRelationFilter, StoreWhereInput> | null
  }

  export type Store_NoticeOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    storeId?: SortOrder
    createdTime?: SortOrder
    Store?: StoreOrderByWithRelationInput
  }

  export type Store_NoticeWhereUniqueInput = {
    id?: number
  }

  export type Store_NoticeOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    storeId?: SortOrder
    createdTime?: SortOrder
    _count?: Store_NoticeCountOrderByAggregateInput
    _avg?: Store_NoticeAvgOrderByAggregateInput
    _max?: Store_NoticeMaxOrderByAggregateInput
    _min?: Store_NoticeMinOrderByAggregateInput
    _sum?: Store_NoticeSumOrderByAggregateInput
  }

  export type Store_NoticeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Store_NoticeScalarWhereWithAggregatesInput>
    OR?: Enumerable<Store_NoticeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Store_NoticeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    category?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    content?: StringNullableWithAggregatesFilter | string | null
    image?: StringNullableWithAggregatesFilter | string | null
    storeId?: IntNullableWithAggregatesFilter | number | null
    createdTime?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type Store_OwnerWhereInput = {
    AND?: Enumerable<Store_OwnerWhereInput>
    OR?: Enumerable<Store_OwnerWhereInput>
    NOT?: Enumerable<Store_OwnerWhereInput>
    id?: IntFilter | number
    loginId?: StringFilter | string
    password?: StringNullableFilter | string | null
    store?: StringNullableFilter | string | null
    director?: StringNullableFilter | string | null
    phone?: StringNullableFilter | string | null
    email?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    detailAddress?: StringNullableFilter | string | null
    licenseNumber?: StringNullableFilter | string | null
    licenseImage?: StringFilter | string
    authorized?: BoolNullableFilter | boolean | null
    termsAgree?: BoolNullableFilter | boolean | null
    marketingAgree?: BoolNullableFilter | boolean | null
    storeId?: IntNullableFilter | number | null
    stampAuthorized?: BoolNullableFilter | boolean | null
    profileImage?: StringNullableFilter | string | null
    Alim_Request?: Alim_RequestListRelationFilter
    Stamp_Request?: XOR<Stamp_RequestRelationFilter, Stamp_RequestWhereInput> | null
    Store_Store_ownerIdToStore_Owner?: XOR<StoreRelationFilter, StoreWhereInput> | null
    Store_Store_Owner_storeIdToStore?: XOR<StoreRelationFilter, StoreWhereInput> | null
  }

  export type Store_OwnerOrderByWithRelationInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    store?: SortOrder
    director?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    detailAddress?: SortOrder
    licenseNumber?: SortOrder
    licenseImage?: SortOrder
    authorized?: SortOrder
    termsAgree?: SortOrder
    marketingAgree?: SortOrder
    storeId?: SortOrder
    stampAuthorized?: SortOrder
    profileImage?: SortOrder
    Alim_Request?: Alim_RequestOrderByRelationAggregateInput
    Stamp_Request?: Stamp_RequestOrderByWithRelationInput
    Store_Store_ownerIdToStore_Owner?: StoreOrderByWithRelationInput
    Store_Store_Owner_storeIdToStore?: StoreOrderByWithRelationInput
  }

  export type Store_OwnerWhereUniqueInput = {
    id?: number
    loginId?: string
    email?: string
    storeId?: number
  }

  export type Store_OwnerOrderByWithAggregationInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    store?: SortOrder
    director?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    detailAddress?: SortOrder
    licenseNumber?: SortOrder
    licenseImage?: SortOrder
    authorized?: SortOrder
    termsAgree?: SortOrder
    marketingAgree?: SortOrder
    storeId?: SortOrder
    stampAuthorized?: SortOrder
    profileImage?: SortOrder
    _count?: Store_OwnerCountOrderByAggregateInput
    _avg?: Store_OwnerAvgOrderByAggregateInput
    _max?: Store_OwnerMaxOrderByAggregateInput
    _min?: Store_OwnerMinOrderByAggregateInput
    _sum?: Store_OwnerSumOrderByAggregateInput
  }

  export type Store_OwnerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Store_OwnerScalarWhereWithAggregatesInput>
    OR?: Enumerable<Store_OwnerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Store_OwnerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    loginId?: StringWithAggregatesFilter | string
    password?: StringNullableWithAggregatesFilter | string | null
    store?: StringNullableWithAggregatesFilter | string | null
    director?: StringNullableWithAggregatesFilter | string | null
    phone?: StringNullableWithAggregatesFilter | string | null
    email?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    detailAddress?: StringNullableWithAggregatesFilter | string | null
    licenseNumber?: StringNullableWithAggregatesFilter | string | null
    licenseImage?: StringWithAggregatesFilter | string
    authorized?: BoolNullableWithAggregatesFilter | boolean | null
    termsAgree?: BoolNullableWithAggregatesFilter | boolean | null
    marketingAgree?: BoolNullableWithAggregatesFilter | boolean | null
    storeId?: IntNullableWithAggregatesFilter | number | null
    stampAuthorized?: BoolNullableWithAggregatesFilter | boolean | null
    profileImage?: StringNullableWithAggregatesFilter | string | null
  }

  export type Store_ProductWhereInput = {
    AND?: Enumerable<Store_ProductWhereInput>
    OR?: Enumerable<Store_ProductWhereInput>
    NOT?: Enumerable<Store_ProductWhereInput>
    id?: IntFilter | number
    category?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    price?: StringNullableFilter | string | null
    discountPrice?: StringNullableFilter | string | null
    url?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    storeId?: IntNullableFilter | number | null
    Store?: XOR<StoreRelationFilter, StoreWhereInput> | null
  }

  export type Store_ProductOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    price?: SortOrder
    discountPrice?: SortOrder
    url?: SortOrder
    image?: SortOrder
    storeId?: SortOrder
    Store?: StoreOrderByWithRelationInput
  }

  export type Store_ProductWhereUniqueInput = {
    id?: number
  }

  export type Store_ProductOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    price?: SortOrder
    discountPrice?: SortOrder
    url?: SortOrder
    image?: SortOrder
    storeId?: SortOrder
    _count?: Store_ProductCountOrderByAggregateInput
    _avg?: Store_ProductAvgOrderByAggregateInput
    _max?: Store_ProductMaxOrderByAggregateInput
    _min?: Store_ProductMinOrderByAggregateInput
    _sum?: Store_ProductSumOrderByAggregateInput
  }

  export type Store_ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Store_ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<Store_ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Store_ProductScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    category?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    price?: StringNullableWithAggregatesFilter | string | null
    discountPrice?: StringNullableWithAggregatesFilter | string | null
    url?: StringNullableWithAggregatesFilter | string | null
    image?: StringNullableWithAggregatesFilter | string | null
    storeId?: IntNullableWithAggregatesFilter | number | null
  }

  export type TourWhereInput = {
    AND?: Enumerable<TourWhereInput>
    OR?: Enumerable<TourWhereInput>
    NOT?: Enumerable<TourWhereInput>
    id?: IntFilter | number
    keyword?: StringFilter | string
    title?: StringFilter | string
    reward?: StringFilter | string
    image?: StringNullableFilter | string | null
    cafeList?: StringNullableListFilter
    Stamp?: StampListRelationFilter
    Store?: StoreListRelationFilter
  }

  export type TourOrderByWithRelationInput = {
    id?: SortOrder
    keyword?: SortOrder
    title?: SortOrder
    reward?: SortOrder
    image?: SortOrder
    cafeList?: SortOrder
    Stamp?: StampOrderByRelationAggregateInput
    Store?: StoreOrderByRelationAggregateInput
  }

  export type TourWhereUniqueInput = {
    id?: number
  }

  export type TourOrderByWithAggregationInput = {
    id?: SortOrder
    keyword?: SortOrder
    title?: SortOrder
    reward?: SortOrder
    image?: SortOrder
    cafeList?: SortOrder
    _count?: TourCountOrderByAggregateInput
    _avg?: TourAvgOrderByAggregateInput
    _max?: TourMaxOrderByAggregateInput
    _min?: TourMinOrderByAggregateInput
    _sum?: TourSumOrderByAggregateInput
  }

  export type TourScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TourScalarWhereWithAggregatesInput>
    OR?: Enumerable<TourScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TourScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    keyword?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    reward?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    cafeList?: StringNullableListFilter
  }

  export type Store_ReviewWhereInput = {
    AND?: Enumerable<Store_ReviewWhereInput>
    OR?: Enumerable<Store_ReviewWhereInput>
    NOT?: Enumerable<Store_ReviewWhereInput>
    id?: IntFilter | number
    title?: StringNullableFilter | string | null
    content?: StringFilter | string
    image?: StringNullableFilter | string | null
    timestamp?: DateTimeFilter | Date | string
    writerId?: IntFilter | number
    storeId?: IntFilter | number
    writerName?: StringFilter | string
    Store?: XOR<StoreRelationFilter, StoreWhereInput>
    Customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
  }

  export type Store_ReviewOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    timestamp?: SortOrder
    writerId?: SortOrder
    storeId?: SortOrder
    writerName?: SortOrder
    Store?: StoreOrderByWithRelationInput
    Customer?: CustomerOrderByWithRelationInput
  }

  export type Store_ReviewWhereUniqueInput = {
    id?: number
    storeId?: number
  }

  export type Store_ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    timestamp?: SortOrder
    writerId?: SortOrder
    storeId?: SortOrder
    writerName?: SortOrder
    _count?: Store_ReviewCountOrderByAggregateInput
    _avg?: Store_ReviewAvgOrderByAggregateInput
    _max?: Store_ReviewMaxOrderByAggregateInput
    _min?: Store_ReviewMinOrderByAggregateInput
    _sum?: Store_ReviewSumOrderByAggregateInput
  }

  export type Store_ReviewScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Store_ReviewScalarWhereWithAggregatesInput>
    OR?: Enumerable<Store_ReviewScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Store_ReviewScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringNullableWithAggregatesFilter | string | null
    content?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    timestamp?: DateTimeWithAggregatesFilter | Date | string
    writerId?: IntWithAggregatesFilter | number
    storeId?: IntWithAggregatesFilter | number
    writerName?: StringWithAggregatesFilter | string
  }

  export type NoticeWhereInput = {
    AND?: Enumerable<NoticeWhereInput>
    OR?: Enumerable<NoticeWhereInput>
    NOT?: Enumerable<NoticeWhereInput>
    id?: IntFilter | number
    title?: StringFilter | string
    content?: StringFilter | string
    image?: StringNullableFilter | string | null
    timestamp?: DateTimeFilter | Date | string
  }

  export type NoticeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    timestamp?: SortOrder
  }

  export type NoticeWhereUniqueInput = {
    id?: number
  }

  export type NoticeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    timestamp?: SortOrder
    _count?: NoticeCountOrderByAggregateInput
    _avg?: NoticeAvgOrderByAggregateInput
    _max?: NoticeMaxOrderByAggregateInput
    _min?: NoticeMinOrderByAggregateInput
    _sum?: NoticeSumOrderByAggregateInput
  }

  export type NoticeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NoticeScalarWhereWithAggregatesInput>
    OR?: Enumerable<NoticeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NoticeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
    timestamp?: DateTimeWithAggregatesFilter | Date | string
  }

  export type Alim_CustomerWhereInput = {
    AND?: Enumerable<Alim_CustomerWhereInput>
    OR?: Enumerable<Alim_CustomerWhereInput>
    NOT?: Enumerable<Alim_CustomerWhereInput>
    id?: IntFilter | number
    loginId?: StringFilter | string
    name?: StringNullableFilter | string | null
    phone?: StringFilter | string
    customerId?: IntFilter | number
    requestId?: IntFilter | number
    Customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    Alim_Request?: XOR<Alim_RequestRelationFilter, Alim_RequestWhereInput>
  }

  export type Alim_CustomerOrderByWithRelationInput = {
    id?: SortOrder
    loginId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    customerId?: SortOrder
    requestId?: SortOrder
    Customer?: CustomerOrderByWithRelationInput
    Alim_Request?: Alim_RequestOrderByWithRelationInput
  }

  export type Alim_CustomerWhereUniqueInput = {
    id?: number
  }

  export type Alim_CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    loginId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    customerId?: SortOrder
    requestId?: SortOrder
    _count?: Alim_CustomerCountOrderByAggregateInput
    _avg?: Alim_CustomerAvgOrderByAggregateInput
    _max?: Alim_CustomerMaxOrderByAggregateInput
    _min?: Alim_CustomerMinOrderByAggregateInput
    _sum?: Alim_CustomerSumOrderByAggregateInput
  }

  export type Alim_CustomerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Alim_CustomerScalarWhereWithAggregatesInput>
    OR?: Enumerable<Alim_CustomerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Alim_CustomerScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    loginId?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    phone?: StringWithAggregatesFilter | string
    customerId?: IntWithAggregatesFilter | number
    requestId?: IntWithAggregatesFilter | number
  }

  export type Alim_RequestWhereInput = {
    AND?: Enumerable<Alim_RequestWhereInput>
    OR?: Enumerable<Alim_RequestWhereInput>
    NOT?: Enumerable<Alim_RequestWhereInput>
    id?: IntFilter | number
    category?: StringFilter | string
    content?: StringFilter | string
    isMessage?: BoolFilter | boolean
    isKakao?: BoolFilter | boolean
    writerId?: IntFilter | number
    timestamp?: DateTimeFilter | Date | string
    Alim_Customer?: Alim_CustomerListRelationFilter
    Store_Owner?: XOR<Store_OwnerRelationFilter, Store_OwnerWhereInput>
  }

  export type Alim_RequestOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    content?: SortOrder
    isMessage?: SortOrder
    isKakao?: SortOrder
    writerId?: SortOrder
    timestamp?: SortOrder
    Alim_Customer?: Alim_CustomerOrderByRelationAggregateInput
    Store_Owner?: Store_OwnerOrderByWithRelationInput
  }

  export type Alim_RequestWhereUniqueInput = {
    id?: number
  }

  export type Alim_RequestOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    content?: SortOrder
    isMessage?: SortOrder
    isKakao?: SortOrder
    writerId?: SortOrder
    timestamp?: SortOrder
    _count?: Alim_RequestCountOrderByAggregateInput
    _avg?: Alim_RequestAvgOrderByAggregateInput
    _max?: Alim_RequestMaxOrderByAggregateInput
    _min?: Alim_RequestMinOrderByAggregateInput
    _sum?: Alim_RequestSumOrderByAggregateInput
  }

  export type Alim_RequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Alim_RequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<Alim_RequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Alim_RequestScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    category?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    isMessage?: BoolWithAggregatesFilter | boolean
    isKakao?: BoolWithAggregatesFilter | boolean
    writerId?: IntWithAggregatesFilter | number
    timestamp?: DateTimeWithAggregatesFilter | Date | string
  }

  export type Stamp_RequestWhereInput = {
    AND?: Enumerable<Stamp_RequestWhereInput>
    OR?: Enumerable<Stamp_RequestWhereInput>
    NOT?: Enumerable<Stamp_RequestWhereInput>
    id?: IntFilter | number
    ownerId?: IntFilter | number
    isGrant?: BoolFilter | boolean
    Store_Owner?: XOR<Store_OwnerRelationFilter, Store_OwnerWhereInput>
  }

  export type Stamp_RequestOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    isGrant?: SortOrder
    Store_Owner?: Store_OwnerOrderByWithRelationInput
  }

  export type Stamp_RequestWhereUniqueInput = {
    id?: number
    ownerId?: number
  }

  export type Stamp_RequestOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    isGrant?: SortOrder
    _count?: Stamp_RequestCountOrderByAggregateInput
    _avg?: Stamp_RequestAvgOrderByAggregateInput
    _max?: Stamp_RequestMaxOrderByAggregateInput
    _min?: Stamp_RequestMinOrderByAggregateInput
    _sum?: Stamp_RequestSumOrderByAggregateInput
  }

  export type Stamp_RequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Stamp_RequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<Stamp_RequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Stamp_RequestScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    ownerId?: IntWithAggregatesFilter | number
    isGrant?: BoolWithAggregatesFilter | boolean
  }

  export type Store_LikeWhereInput = {
    AND?: Enumerable<Store_LikeWhereInput>
    OR?: Enumerable<Store_LikeWhereInput>
    NOT?: Enumerable<Store_LikeWhereInput>
    id?: IntFilter | number
    customerId?: IntFilter | number
    storeId?: IntFilter | number
    Customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    Store?: XOR<StoreRelationFilter, StoreWhereInput>
  }

  export type Store_LikeOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
    Customer?: CustomerOrderByWithRelationInput
    Store?: StoreOrderByWithRelationInput
  }

  export type Store_LikeWhereUniqueInput = {
    id?: number
  }

  export type Store_LikeOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
    _count?: Store_LikeCountOrderByAggregateInput
    _avg?: Store_LikeAvgOrderByAggregateInput
    _max?: Store_LikeMaxOrderByAggregateInput
    _min?: Store_LikeMinOrderByAggregateInput
    _sum?: Store_LikeSumOrderByAggregateInput
  }

  export type Store_LikeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<Store_LikeScalarWhereWithAggregatesInput>
    OR?: Enumerable<Store_LikeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<Store_LikeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    customerId?: IntWithAggregatesFilter | number
    storeId?: IntWithAggregatesFilter | number
  }

  export type CustomerCreateInput = {
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    image?: string | null
    stampCount?: number
    couponCount?: number
    Alim_Customer?: Alim_CustomerCreateNestedManyWithoutCustomerInput
    Store?: StoreCreateNestedOneWithoutCustomerInput
    Delivery?: DeliveryCreateNestedManyWithoutCustomerInput
    Stamp?: StampCreateNestedManyWithoutCustomerInput
    Store_Like?: Store_LikeCreateNestedManyWithoutCustomerInput
    Store_Review?: Store_ReviewCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    storeId?: number | null
    image?: string | null
    stampCount?: number
    couponCount?: number
    Alim_Customer?: Alim_CustomerUncheckedCreateNestedManyWithoutCustomerInput
    Delivery?: DeliveryUncheckedCreateNestedManyWithoutCustomerInput
    Stamp?: StampUncheckedCreateNestedManyWithoutCustomerInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutCustomerInput
    Store_Review?: Store_ReviewUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
    Alim_Customer?: Alim_CustomerUpdateManyWithoutCustomerNestedInput
    Store?: StoreUpdateOneWithoutCustomerNestedInput
    Delivery?: DeliveryUpdateManyWithoutCustomerNestedInput
    Stamp?: StampUpdateManyWithoutCustomerNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutCustomerNestedInput
    Store_Review?: Store_ReviewUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
    Alim_Customer?: Alim_CustomerUncheckedUpdateManyWithoutCustomerNestedInput
    Delivery?: DeliveryUncheckedUpdateManyWithoutCustomerNestedInput
    Stamp?: StampUncheckedUpdateManyWithoutCustomerNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutCustomerNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    storeId?: number | null
    image?: string | null
    stampCount?: number
    couponCount?: number
  }

  export type CustomerUpdateManyMutationInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryCreateInput = {
    reward: string
    customer: string
    phone: string
    address: string
    detailAddress?: string | null
    message: string
    isGrant?: boolean | null
    Customer: CustomerCreateNestedOneWithoutDeliveryInput
  }

  export type DeliveryUncheckedCreateInput = {
    id?: number
    reward: string
    customer: string
    phone: string
    address: string
    detailAddress?: string | null
    message: string
    isGrant?: boolean | null
    customerId: number
  }

  export type DeliveryUpdateInput = {
    reward?: StringFieldUpdateOperationsInput | string
    customer?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isGrant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Customer?: CustomerUpdateOneRequiredWithoutDeliveryNestedInput
  }

  export type DeliveryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reward?: StringFieldUpdateOperationsInput | string
    customer?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isGrant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerId?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryCreateManyInput = {
    id?: number
    reward: string
    customer: string
    phone: string
    address: string
    detailAddress?: string | null
    message: string
    isGrant?: boolean | null
    customerId: number
  }

  export type DeliveryUpdateManyMutationInput = {
    reward?: StringFieldUpdateOperationsInput | string
    customer?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isGrant?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeliveryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reward?: StringFieldUpdateOperationsInput | string
    customer?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isGrant?: NullableBoolFieldUpdateOperationsInput | boolean | null
    customerId?: IntFieldUpdateOperationsInput | number
  }

  export type ManagerCreateInput = {
    loginId: string
    password: string
  }

  export type ManagerUncheckedCreateInput = {
    id?: number
    loginId: string
    password: string
  }

  export type ManagerUpdateInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ManagerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ManagerCreateManyInput = {
    id?: number
    loginId: string
    password: string
  }

  export type ManagerUpdateManyMutationInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ManagerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type StampCreateInput = {
    randNum?: string | null
    timestamp?: Date | string | null
    store?: string | null
    tour?: string | null
    Customer?: CustomerCreateNestedOneWithoutStampInput
    Store?: StoreCreateNestedOneWithoutStampInput
    Tour?: TourCreateNestedOneWithoutStampInput
  }

  export type StampUncheckedCreateInput = {
    id?: number
    randNum?: string | null
    timestamp?: Date | string | null
    customerId?: number | null
    storeId?: number | null
    store?: string | null
    tourId?: number | null
    tour?: string | null
  }

  export type StampUpdateInput = {
    randNum?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    tour?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUpdateOneWithoutStampNestedInput
    Store?: StoreUpdateOneWithoutStampNestedInput
    Tour?: TourUpdateOneWithoutStampNestedInput
  }

  export type StampUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    randNum?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    tour?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StampCreateManyInput = {
    id?: number
    randNum?: string | null
    timestamp?: Date | string | null
    customerId?: number | null
    storeId?: number | null
    store?: string | null
    tourId?: number | null
    tour?: string | null
  }

  export type StampUpdateManyMutationInput = {
    randNum?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    tour?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StampUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    randNum?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    tour?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreCreateInput = {
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    x?: string | null
    y?: string | null
    Customer?: CustomerCreateNestedManyWithoutStoreInput
    Stamp?: StampCreateNestedManyWithoutStoreInput
    Store_Owner_Store_ownerIdToStore_Owner: Store_OwnerCreateNestedOneWithoutStore_Store_ownerIdToStore_OwnerInput
    Tour?: TourCreateNestedOneWithoutStoreInput
    Store_Like?: Store_LikeCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateInput = {
    id?: number
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    ownerId: number
    tourId?: number | null
    x?: string | null
    y?: string | null
    Customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    Stamp?: StampUncheckedCreateNestedManyWithoutStoreInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuUncheckedCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeUncheckedCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductUncheckedCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewUncheckedCreateNestedOneWithoutStoreInput
  }

  export type StoreUpdateInput = {
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUpdateManyWithoutStoreNestedInput
    Stamp?: StampUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_ownerIdToStore_Owner?: Store_OwnerUpdateOneRequiredWithoutStore_Store_ownerIdToStore_OwnerNestedInput
    Tour?: TourUpdateOneWithoutStoreNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUpdateOneWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    ownerId?: IntFieldUpdateOperationsInput | number
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    Stamp?: StampUncheckedUpdateManyWithoutStoreNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUncheckedUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUncheckedUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateOneWithoutStoreNestedInput
  }

  export type StoreCreateManyInput = {
    id?: number
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    ownerId: number
    tourId?: number | null
    x?: string | null
    y?: string | null
  }

  export type StoreUpdateManyMutationInput = {
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    ownerId?: IntFieldUpdateOperationsInput | number
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Store_MenuCreateInput = {
    title?: string | null
    content?: string | null
    image?: string | null
    Store?: StoreCreateNestedOneWithoutStore_MenuInput
  }

  export type Store_MenuUncheckedCreateInput = {
    id?: number
    title?: string | null
    content?: string | null
    image?: string | null
    storeId?: number | null
  }

  export type Store_MenuUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    Store?: StoreUpdateOneWithoutStore_MenuNestedInput
  }

  export type Store_MenuUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Store_MenuCreateManyInput = {
    id?: number
    title?: string | null
    content?: string | null
    image?: string | null
    storeId?: number | null
  }

  export type Store_MenuUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Store_MenuUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Store_NoticeCreateInput = {
    category?: string | null
    title?: string | null
    content?: string | null
    image?: string | null
    createdTime?: Date | string | null
    Store?: StoreCreateNestedOneWithoutStore_NoticeInput
  }

  export type Store_NoticeUncheckedCreateInput = {
    id?: number
    category?: string | null
    title?: string | null
    content?: string | null
    image?: string | null
    storeId?: number | null
    createdTime?: Date | string | null
  }

  export type Store_NoticeUpdateInput = {
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Store?: StoreUpdateOneWithoutStore_NoticeNestedInput
  }

  export type Store_NoticeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Store_NoticeCreateManyInput = {
    id?: number
    category?: string | null
    title?: string | null
    content?: string | null
    image?: string | null
    storeId?: number | null
    createdTime?: Date | string | null
  }

  export type Store_NoticeUpdateManyMutationInput = {
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Store_NoticeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    createdTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Store_OwnerCreateInput = {
    loginId: string
    password?: string | null
    store?: string | null
    director?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    detailAddress?: string | null
    licenseNumber?: string | null
    licenseImage: string
    authorized?: boolean | null
    termsAgree?: boolean | null
    marketingAgree?: boolean | null
    stampAuthorized?: boolean | null
    profileImage?: string | null
    Alim_Request?: Alim_RequestCreateNestedManyWithoutStore_OwnerInput
    Stamp_Request?: Stamp_RequestCreateNestedOneWithoutStore_OwnerInput
    Store_Store_ownerIdToStore_Owner?: StoreCreateNestedOneWithoutStore_Owner_Store_ownerIdToStore_OwnerInput
    Store_Store_Owner_storeIdToStore?: StoreCreateNestedOneWithoutStore_Owner_Store_Owner_storeIdToStoreInput
  }

  export type Store_OwnerUncheckedCreateInput = {
    id?: number
    loginId: string
    password?: string | null
    store?: string | null
    director?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    detailAddress?: string | null
    licenseNumber?: string | null
    licenseImage: string
    authorized?: boolean | null
    termsAgree?: boolean | null
    marketingAgree?: boolean | null
    storeId?: number | null
    stampAuthorized?: boolean | null
    profileImage?: string | null
    Alim_Request?: Alim_RequestUncheckedCreateNestedManyWithoutStore_OwnerInput
    Stamp_Request?: Stamp_RequestUncheckedCreateNestedOneWithoutStore_OwnerInput
    Store_Store_ownerIdToStore_Owner?: StoreUncheckedCreateNestedOneWithoutStore_Owner_Store_ownerIdToStore_OwnerInput
  }

  export type Store_OwnerUpdateInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    director?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseImage?: StringFieldUpdateOperationsInput | string
    authorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    termsAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stampAuthorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    Alim_Request?: Alim_RequestUpdateManyWithoutStore_OwnerNestedInput
    Stamp_Request?: Stamp_RequestUpdateOneWithoutStore_OwnerNestedInput
    Store_Store_ownerIdToStore_Owner?: StoreUpdateOneWithoutStore_Owner_Store_ownerIdToStore_OwnerNestedInput
    Store_Store_Owner_storeIdToStore?: StoreUpdateOneWithoutStore_Owner_Store_Owner_storeIdToStoreNestedInput
  }

  export type Store_OwnerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    director?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseImage?: StringFieldUpdateOperationsInput | string
    authorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    termsAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    stampAuthorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    Alim_Request?: Alim_RequestUncheckedUpdateManyWithoutStore_OwnerNestedInput
    Stamp_Request?: Stamp_RequestUncheckedUpdateOneWithoutStore_OwnerNestedInput
    Store_Store_ownerIdToStore_Owner?: StoreUncheckedUpdateOneWithoutStore_Owner_Store_ownerIdToStore_OwnerNestedInput
  }

  export type Store_OwnerCreateManyInput = {
    id?: number
    loginId: string
    password?: string | null
    store?: string | null
    director?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    detailAddress?: string | null
    licenseNumber?: string | null
    licenseImage: string
    authorized?: boolean | null
    termsAgree?: boolean | null
    marketingAgree?: boolean | null
    storeId?: number | null
    stampAuthorized?: boolean | null
    profileImage?: string | null
  }

  export type Store_OwnerUpdateManyMutationInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    director?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseImage?: StringFieldUpdateOperationsInput | string
    authorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    termsAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stampAuthorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Store_OwnerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    director?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseImage?: StringFieldUpdateOperationsInput | string
    authorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    termsAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    stampAuthorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Store_ProductCreateInput = {
    category?: string | null
    name?: string | null
    price?: string | null
    discountPrice?: string | null
    url?: string | null
    image?: string | null
    Store?: StoreCreateNestedOneWithoutStore_ProductInput
  }

  export type Store_ProductUncheckedCreateInput = {
    id?: number
    category?: string | null
    name?: string | null
    price?: string | null
    discountPrice?: string | null
    url?: string | null
    image?: string | null
    storeId?: number | null
  }

  export type Store_ProductUpdateInput = {
    category?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    Store?: StoreUpdateOneWithoutStore_ProductNestedInput
  }

  export type Store_ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type Store_ProductCreateManyInput = {
    id?: number
    category?: string | null
    name?: string | null
    price?: string | null
    discountPrice?: string | null
    url?: string | null
    image?: string | null
    storeId?: number | null
  }

  export type Store_ProductUpdateManyMutationInput = {
    category?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Store_ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TourCreateInput = {
    keyword: string
    title: string
    reward: string
    image?: string | null
    cafeList?: TourCreatecafeListInput | Enumerable<string>
    Stamp?: StampCreateNestedManyWithoutTourInput
    Store?: StoreCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateInput = {
    id?: number
    keyword: string
    title: string
    reward: string
    image?: string | null
    cafeList?: TourCreatecafeListInput | Enumerable<string>
    Stamp?: StampUncheckedCreateNestedManyWithoutTourInput
    Store?: StoreUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourUpdateInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cafeList?: TourUpdatecafeListInput | Enumerable<string>
    Stamp?: StampUpdateManyWithoutTourNestedInput
    Store?: StoreUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cafeList?: TourUpdatecafeListInput | Enumerable<string>
    Stamp?: StampUncheckedUpdateManyWithoutTourNestedInput
    Store?: StoreUncheckedUpdateManyWithoutTourNestedInput
  }

  export type TourCreateManyInput = {
    id?: number
    keyword: string
    title: string
    reward: string
    image?: string | null
    cafeList?: TourCreatecafeListInput | Enumerable<string>
  }

  export type TourUpdateManyMutationInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cafeList?: TourUpdatecafeListInput | Enumerable<string>
  }

  export type TourUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cafeList?: TourUpdatecafeListInput | Enumerable<string>
  }

  export type Store_ReviewCreateInput = {
    id?: number
    title?: string | null
    content: string
    image?: string | null
    timestamp: Date | string
    writerName: string
    Store: StoreCreateNestedOneWithoutStore_ReviewInput
    Customer: CustomerCreateNestedOneWithoutStore_ReviewInput
  }

  export type Store_ReviewUncheckedCreateInput = {
    id?: number
    title?: string | null
    content: string
    image?: string | null
    timestamp: Date | string
    writerId: number
    storeId: number
    writerName: string
  }

  export type Store_ReviewUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    writerName?: StringFieldUpdateOperationsInput | string
    Store?: StoreUpdateOneRequiredWithoutStore_ReviewNestedInput
    Customer?: CustomerUpdateOneRequiredWithoutStore_ReviewNestedInput
  }

  export type Store_ReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    writerId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    writerName?: StringFieldUpdateOperationsInput | string
  }

  export type Store_ReviewCreateManyInput = {
    id?: number
    title?: string | null
    content: string
    image?: string | null
    timestamp: Date | string
    writerId: number
    storeId: number
    writerName: string
  }

  export type Store_ReviewUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    writerName?: StringFieldUpdateOperationsInput | string
  }

  export type Store_ReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    writerId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    writerName?: StringFieldUpdateOperationsInput | string
  }

  export type NoticeCreateInput = {
    title: string
    content: string
    image?: string | null
    timestamp: Date | string
  }

  export type NoticeUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    image?: string | null
    timestamp: Date | string
  }

  export type NoticeUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeCreateManyInput = {
    id?: number
    title: string
    content: string
    image?: string | null
    timestamp: Date | string
  }

  export type NoticeUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Alim_CustomerCreateInput = {
    loginId: string
    name?: string | null
    phone: string
    Customer: CustomerCreateNestedOneWithoutAlim_CustomerInput
    Alim_Request: Alim_RequestCreateNestedOneWithoutAlim_CustomerInput
  }

  export type Alim_CustomerUncheckedCreateInput = {
    id?: number
    loginId: string
    name?: string | null
    phone: string
    customerId: number
    requestId: number
  }

  export type Alim_CustomerUpdateInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    Customer?: CustomerUpdateOneRequiredWithoutAlim_CustomerNestedInput
    Alim_Request?: Alim_RequestUpdateOneRequiredWithoutAlim_CustomerNestedInput
  }

  export type Alim_CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    requestId?: IntFieldUpdateOperationsInput | number
  }

  export type Alim_CustomerCreateManyInput = {
    id?: number
    loginId: string
    name?: string | null
    phone: string
    customerId: number
    requestId: number
  }

  export type Alim_CustomerUpdateManyMutationInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
  }

  export type Alim_CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    requestId?: IntFieldUpdateOperationsInput | number
  }

  export type Alim_RequestCreateInput = {
    category: string
    content: string
    isMessage: boolean
    isKakao: boolean
    timestamp: Date | string
    Alim_Customer?: Alim_CustomerCreateNestedManyWithoutAlim_RequestInput
    Store_Owner: Store_OwnerCreateNestedOneWithoutAlim_RequestInput
  }

  export type Alim_RequestUncheckedCreateInput = {
    id?: number
    category: string
    content: string
    isMessage: boolean
    isKakao: boolean
    writerId: number
    timestamp: Date | string
    Alim_Customer?: Alim_CustomerUncheckedCreateNestedManyWithoutAlim_RequestInput
  }

  export type Alim_RequestUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isMessage?: BoolFieldUpdateOperationsInput | boolean
    isKakao?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    Alim_Customer?: Alim_CustomerUpdateManyWithoutAlim_RequestNestedInput
    Store_Owner?: Store_OwnerUpdateOneRequiredWithoutAlim_RequestNestedInput
  }

  export type Alim_RequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isMessage?: BoolFieldUpdateOperationsInput | boolean
    isKakao?: BoolFieldUpdateOperationsInput | boolean
    writerId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    Alim_Customer?: Alim_CustomerUncheckedUpdateManyWithoutAlim_RequestNestedInput
  }

  export type Alim_RequestCreateManyInput = {
    id?: number
    category: string
    content: string
    isMessage: boolean
    isKakao: boolean
    writerId: number
    timestamp: Date | string
  }

  export type Alim_RequestUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isMessage?: BoolFieldUpdateOperationsInput | boolean
    isKakao?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Alim_RequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isMessage?: BoolFieldUpdateOperationsInput | boolean
    isKakao?: BoolFieldUpdateOperationsInput | boolean
    writerId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Stamp_RequestCreateInput = {
    isGrant?: boolean
    Store_Owner: Store_OwnerCreateNestedOneWithoutStamp_RequestInput
  }

  export type Stamp_RequestUncheckedCreateInput = {
    id?: number
    ownerId: number
    isGrant?: boolean
  }

  export type Stamp_RequestUpdateInput = {
    isGrant?: BoolFieldUpdateOperationsInput | boolean
    Store_Owner?: Store_OwnerUpdateOneRequiredWithoutStamp_RequestNestedInput
  }

  export type Stamp_RequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    isGrant?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Stamp_RequestCreateManyInput = {
    id?: number
    ownerId: number
    isGrant?: boolean
  }

  export type Stamp_RequestUpdateManyMutationInput = {
    isGrant?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Stamp_RequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ownerId?: IntFieldUpdateOperationsInput | number
    isGrant?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Store_LikeCreateInput = {
    Customer: CustomerCreateNestedOneWithoutStore_LikeInput
    Store: StoreCreateNestedOneWithoutStore_LikeInput
  }

  export type Store_LikeUncheckedCreateInput = {
    id?: number
    customerId: number
    storeId: number
  }

  export type Store_LikeUpdateInput = {
    Customer?: CustomerUpdateOneRequiredWithoutStore_LikeNestedInput
    Store?: StoreUpdateOneRequiredWithoutStore_LikeNestedInput
  }

  export type Store_LikeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type Store_LikeCreateManyInput = {
    id?: number
    customerId: number
    storeId: number
  }

  export type Store_LikeUpdateManyMutationInput = {

  }

  export type Store_LikeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type Alim_CustomerListRelationFilter = {
    every?: Alim_CustomerWhereInput
    some?: Alim_CustomerWhereInput
    none?: Alim_CustomerWhereInput
  }

  export type StoreRelationFilter = {
    is?: StoreWhereInput | null
    isNot?: StoreWhereInput | null
  }

  export type DeliveryListRelationFilter = {
    every?: DeliveryWhereInput
    some?: DeliveryWhereInput
    none?: DeliveryWhereInput
  }

  export type StampListRelationFilter = {
    every?: StampWhereInput
    some?: StampWhereInput
    none?: StampWhereInput
  }

  export type Store_LikeListRelationFilter = {
    every?: Store_LikeWhereInput
    some?: Store_LikeWhereInput
    none?: Store_LikeWhereInput
  }

  export type Store_ReviewListRelationFilter = {
    every?: Store_ReviewWhereInput
    some?: Store_ReviewWhereInput
    none?: Store_ReviewWhereInput
  }

  export type Alim_CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StampOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Store_LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Store_ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    termsAgree?: SortOrder
    marketingAgree?: SortOrder
    storeId?: SortOrder
    image?: SortOrder
    stampCount?: SortOrder
    couponCount?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    stampCount?: SortOrder
    couponCount?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    termsAgree?: SortOrder
    marketingAgree?: SortOrder
    storeId?: SortOrder
    image?: SortOrder
    stampCount?: SortOrder
    couponCount?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    termsAgree?: SortOrder
    marketingAgree?: SortOrder
    storeId?: SortOrder
    image?: SortOrder
    stampCount?: SortOrder
    couponCount?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    stampCount?: SortOrder
    couponCount?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type DeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    reward?: SortOrder
    customer?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    detailAddress?: SortOrder
    message?: SortOrder
    isGrant?: SortOrder
    customerId?: SortOrder
  }

  export type DeliveryAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type DeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    reward?: SortOrder
    customer?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    detailAddress?: SortOrder
    message?: SortOrder
    isGrant?: SortOrder
    customerId?: SortOrder
  }

  export type DeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    reward?: SortOrder
    customer?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    detailAddress?: SortOrder
    message?: SortOrder
    isGrant?: SortOrder
    customerId?: SortOrder
  }

  export type DeliverySumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type ManagerCountOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
  }

  export type ManagerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
  }

  export type ManagerMinOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
  }

  export type ManagerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type TourRelationFilter = {
    is?: TourWhereInput | null
    isNot?: TourWhereInput | null
  }

  export type StampCountOrderByAggregateInput = {
    id?: SortOrder
    randNum?: SortOrder
    timestamp?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
    store?: SortOrder
    tourId?: SortOrder
    tour?: SortOrder
  }

  export type StampAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
    tourId?: SortOrder
  }

  export type StampMaxOrderByAggregateInput = {
    id?: SortOrder
    randNum?: SortOrder
    timestamp?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
    store?: SortOrder
    tourId?: SortOrder
    tour?: SortOrder
  }

  export type StampMinOrderByAggregateInput = {
    id?: SortOrder
    randNum?: SortOrder
    timestamp?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
    store?: SortOrder
    tourId?: SortOrder
    tour?: SortOrder
  }

  export type StampSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
    tourId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type Store_OwnerRelationFilter = {
    is?: Store_OwnerWhereInput
    isNot?: Store_OwnerWhereInput
  }

  export type Store_MenuListRelationFilter = {
    every?: Store_MenuWhereInput
    some?: Store_MenuWhereInput
    none?: Store_MenuWhereInput
  }

  export type Store_NoticeListRelationFilter = {
    every?: Store_NoticeWhereInput
    some?: Store_NoticeWhereInput
    none?: Store_NoticeWhereInput
  }

  export type Store_ProductListRelationFilter = {
    every?: Store_ProductWhereInput
    some?: Store_ProductWhereInput
    none?: Store_ProductWhereInput
  }

  export type Store_ReviewRelationFilter = {
    is?: Store_ReviewWhereInput | null
    isNot?: Store_ReviewWhereInput | null
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Store_MenuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Store_NoticeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Store_ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreCountOrderByAggregateInput = {
    id?: SortOrder
    storeName?: SortOrder
    description?: SortOrder
    officeHour?: SortOrder
    dayOff?: SortOrder
    homepage?: SortOrder
    image?: SortOrder
    category?: SortOrder
    ownerId?: SortOrder
    tourId?: SortOrder
    x?: SortOrder
    y?: SortOrder
  }

  export type StoreAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    tourId?: SortOrder
  }

  export type StoreMaxOrderByAggregateInput = {
    id?: SortOrder
    storeName?: SortOrder
    description?: SortOrder
    officeHour?: SortOrder
    dayOff?: SortOrder
    homepage?: SortOrder
    image?: SortOrder
    ownerId?: SortOrder
    tourId?: SortOrder
    x?: SortOrder
    y?: SortOrder
  }

  export type StoreMinOrderByAggregateInput = {
    id?: SortOrder
    storeName?: SortOrder
    description?: SortOrder
    officeHour?: SortOrder
    dayOff?: SortOrder
    homepage?: SortOrder
    image?: SortOrder
    ownerId?: SortOrder
    tourId?: SortOrder
    x?: SortOrder
    y?: SortOrder
  }

  export type StoreSumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    tourId?: SortOrder
  }

  export type Store_MenuCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    storeId?: SortOrder
  }

  export type Store_MenuAvgOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
  }

  export type Store_MenuMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    storeId?: SortOrder
  }

  export type Store_MenuMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    storeId?: SortOrder
  }

  export type Store_MenuSumOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
  }

  export type Store_NoticeCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    storeId?: SortOrder
    createdTime?: SortOrder
  }

  export type Store_NoticeAvgOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
  }

  export type Store_NoticeMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    storeId?: SortOrder
    createdTime?: SortOrder
  }

  export type Store_NoticeMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    storeId?: SortOrder
    createdTime?: SortOrder
  }

  export type Store_NoticeSumOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
  }

  export type Alim_RequestListRelationFilter = {
    every?: Alim_RequestWhereInput
    some?: Alim_RequestWhereInput
    none?: Alim_RequestWhereInput
  }

  export type Stamp_RequestRelationFilter = {
    is?: Stamp_RequestWhereInput | null
    isNot?: Stamp_RequestWhereInput | null
  }

  export type Alim_RequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Store_OwnerCountOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    store?: SortOrder
    director?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    detailAddress?: SortOrder
    licenseNumber?: SortOrder
    licenseImage?: SortOrder
    authorized?: SortOrder
    termsAgree?: SortOrder
    marketingAgree?: SortOrder
    storeId?: SortOrder
    stampAuthorized?: SortOrder
    profileImage?: SortOrder
  }

  export type Store_OwnerAvgOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
  }

  export type Store_OwnerMaxOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    store?: SortOrder
    director?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    detailAddress?: SortOrder
    licenseNumber?: SortOrder
    licenseImage?: SortOrder
    authorized?: SortOrder
    termsAgree?: SortOrder
    marketingAgree?: SortOrder
    storeId?: SortOrder
    stampAuthorized?: SortOrder
    profileImage?: SortOrder
  }

  export type Store_OwnerMinOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    store?: SortOrder
    director?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    detailAddress?: SortOrder
    licenseNumber?: SortOrder
    licenseImage?: SortOrder
    authorized?: SortOrder
    termsAgree?: SortOrder
    marketingAgree?: SortOrder
    storeId?: SortOrder
    stampAuthorized?: SortOrder
    profileImage?: SortOrder
  }

  export type Store_OwnerSumOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
  }

  export type Store_ProductCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    price?: SortOrder
    discountPrice?: SortOrder
    url?: SortOrder
    image?: SortOrder
    storeId?: SortOrder
  }

  export type Store_ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
  }

  export type Store_ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    price?: SortOrder
    discountPrice?: SortOrder
    url?: SortOrder
    image?: SortOrder
    storeId?: SortOrder
  }

  export type Store_ProductMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    name?: SortOrder
    price?: SortOrder
    discountPrice?: SortOrder
    url?: SortOrder
    image?: SortOrder
    storeId?: SortOrder
  }

  export type Store_ProductSumOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
  }

  export type StoreListRelationFilter = {
    every?: StoreWhereInput
    some?: StoreWhereInput
    none?: StoreWhereInput
  }

  export type StoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TourCountOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    title?: SortOrder
    reward?: SortOrder
    image?: SortOrder
    cafeList?: SortOrder
  }

  export type TourAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TourMaxOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    title?: SortOrder
    reward?: SortOrder
    image?: SortOrder
  }

  export type TourMinOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    title?: SortOrder
    reward?: SortOrder
    image?: SortOrder
  }

  export type TourSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type Store_ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    timestamp?: SortOrder
    writerId?: SortOrder
    storeId?: SortOrder
    writerName?: SortOrder
  }

  export type Store_ReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    writerId?: SortOrder
    storeId?: SortOrder
  }

  export type Store_ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    timestamp?: SortOrder
    writerId?: SortOrder
    storeId?: SortOrder
    writerName?: SortOrder
  }

  export type Store_ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    timestamp?: SortOrder
    writerId?: SortOrder
    storeId?: SortOrder
    writerName?: SortOrder
  }

  export type Store_ReviewSumOrderByAggregateInput = {
    id?: SortOrder
    writerId?: SortOrder
    storeId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NoticeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    timestamp?: SortOrder
  }

  export type NoticeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NoticeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    timestamp?: SortOrder
  }

  export type NoticeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    image?: SortOrder
    timestamp?: SortOrder
  }

  export type NoticeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Alim_RequestRelationFilter = {
    is?: Alim_RequestWhereInput
    isNot?: Alim_RequestWhereInput
  }

  export type Alim_CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    customerId?: SortOrder
    requestId?: SortOrder
  }

  export type Alim_CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    requestId?: SortOrder
  }

  export type Alim_CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    customerId?: SortOrder
    requestId?: SortOrder
  }

  export type Alim_CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    customerId?: SortOrder
    requestId?: SortOrder
  }

  export type Alim_CustomerSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    requestId?: SortOrder
  }

  export type Alim_RequestCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    content?: SortOrder
    isMessage?: SortOrder
    isKakao?: SortOrder
    writerId?: SortOrder
    timestamp?: SortOrder
  }

  export type Alim_RequestAvgOrderByAggregateInput = {
    id?: SortOrder
    writerId?: SortOrder
  }

  export type Alim_RequestMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    content?: SortOrder
    isMessage?: SortOrder
    isKakao?: SortOrder
    writerId?: SortOrder
    timestamp?: SortOrder
  }

  export type Alim_RequestMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    content?: SortOrder
    isMessage?: SortOrder
    isKakao?: SortOrder
    writerId?: SortOrder
    timestamp?: SortOrder
  }

  export type Alim_RequestSumOrderByAggregateInput = {
    id?: SortOrder
    writerId?: SortOrder
  }

  export type Stamp_RequestCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    isGrant?: SortOrder
  }

  export type Stamp_RequestAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
  }

  export type Stamp_RequestMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    isGrant?: SortOrder
  }

  export type Stamp_RequestMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    isGrant?: SortOrder
  }

  export type Stamp_RequestSumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
  }

  export type Store_LikeCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
  }

  export type Store_LikeAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
  }

  export type Store_LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
  }

  export type Store_LikeMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
  }

  export type Store_LikeSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    storeId?: SortOrder
  }

  export type Alim_CustomerCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<Alim_CustomerCreateWithoutCustomerInput>, Enumerable<Alim_CustomerUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<Alim_CustomerCreateOrConnectWithoutCustomerInput>
    createMany?: Alim_CustomerCreateManyCustomerInputEnvelope
    connect?: Enumerable<Alim_CustomerWhereUniqueInput>
  }

  export type StoreCreateNestedOneWithoutCustomerInput = {
    create?: XOR<StoreCreateWithoutCustomerInput, StoreUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: StoreCreateOrConnectWithoutCustomerInput
    connect?: StoreWhereUniqueInput
  }

  export type DeliveryCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<DeliveryCreateWithoutCustomerInput>, Enumerable<DeliveryUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<DeliveryCreateOrConnectWithoutCustomerInput>
    createMany?: DeliveryCreateManyCustomerInputEnvelope
    connect?: Enumerable<DeliveryWhereUniqueInput>
  }

  export type StampCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<StampCreateWithoutCustomerInput>, Enumerable<StampUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<StampCreateOrConnectWithoutCustomerInput>
    createMany?: StampCreateManyCustomerInputEnvelope
    connect?: Enumerable<StampWhereUniqueInput>
  }

  export type Store_LikeCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<Store_LikeCreateWithoutCustomerInput>, Enumerable<Store_LikeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<Store_LikeCreateOrConnectWithoutCustomerInput>
    createMany?: Store_LikeCreateManyCustomerInputEnvelope
    connect?: Enumerable<Store_LikeWhereUniqueInput>
  }

  export type Store_ReviewCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<Store_ReviewCreateWithoutCustomerInput>, Enumerable<Store_ReviewUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<Store_ReviewCreateOrConnectWithoutCustomerInput>
    createMany?: Store_ReviewCreateManyCustomerInputEnvelope
    connect?: Enumerable<Store_ReviewWhereUniqueInput>
  }

  export type Alim_CustomerUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<Alim_CustomerCreateWithoutCustomerInput>, Enumerable<Alim_CustomerUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<Alim_CustomerCreateOrConnectWithoutCustomerInput>
    createMany?: Alim_CustomerCreateManyCustomerInputEnvelope
    connect?: Enumerable<Alim_CustomerWhereUniqueInput>
  }

  export type DeliveryUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<DeliveryCreateWithoutCustomerInput>, Enumerable<DeliveryUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<DeliveryCreateOrConnectWithoutCustomerInput>
    createMany?: DeliveryCreateManyCustomerInputEnvelope
    connect?: Enumerable<DeliveryWhereUniqueInput>
  }

  export type StampUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<StampCreateWithoutCustomerInput>, Enumerable<StampUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<StampCreateOrConnectWithoutCustomerInput>
    createMany?: StampCreateManyCustomerInputEnvelope
    connect?: Enumerable<StampWhereUniqueInput>
  }

  export type Store_LikeUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<Store_LikeCreateWithoutCustomerInput>, Enumerable<Store_LikeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<Store_LikeCreateOrConnectWithoutCustomerInput>
    createMany?: Store_LikeCreateManyCustomerInputEnvelope
    connect?: Enumerable<Store_LikeWhereUniqueInput>
  }

  export type Store_ReviewUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<Enumerable<Store_ReviewCreateWithoutCustomerInput>, Enumerable<Store_ReviewUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<Store_ReviewCreateOrConnectWithoutCustomerInput>
    createMany?: Store_ReviewCreateManyCustomerInputEnvelope
    connect?: Enumerable<Store_ReviewWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Alim_CustomerUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<Alim_CustomerCreateWithoutCustomerInput>, Enumerable<Alim_CustomerUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<Alim_CustomerCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<Alim_CustomerUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: Alim_CustomerCreateManyCustomerInputEnvelope
    set?: Enumerable<Alim_CustomerWhereUniqueInput>
    disconnect?: Enumerable<Alim_CustomerWhereUniqueInput>
    delete?: Enumerable<Alim_CustomerWhereUniqueInput>
    connect?: Enumerable<Alim_CustomerWhereUniqueInput>
    update?: Enumerable<Alim_CustomerUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<Alim_CustomerUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<Alim_CustomerScalarWhereInput>
  }

  export type StoreUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<StoreCreateWithoutCustomerInput, StoreUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: StoreCreateOrConnectWithoutCustomerInput
    upsert?: StoreUpsertWithoutCustomerInput
    disconnect?: boolean
    delete?: boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<StoreUpdateWithoutCustomerInput, StoreUncheckedUpdateWithoutCustomerInput>
  }

  export type DeliveryUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<DeliveryCreateWithoutCustomerInput>, Enumerable<DeliveryUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<DeliveryCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<DeliveryUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: DeliveryCreateManyCustomerInputEnvelope
    set?: Enumerable<DeliveryWhereUniqueInput>
    disconnect?: Enumerable<DeliveryWhereUniqueInput>
    delete?: Enumerable<DeliveryWhereUniqueInput>
    connect?: Enumerable<DeliveryWhereUniqueInput>
    update?: Enumerable<DeliveryUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<DeliveryUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<DeliveryScalarWhereInput>
  }

  export type StampUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<StampCreateWithoutCustomerInput>, Enumerable<StampUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<StampCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<StampUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: StampCreateManyCustomerInputEnvelope
    set?: Enumerable<StampWhereUniqueInput>
    disconnect?: Enumerable<StampWhereUniqueInput>
    delete?: Enumerable<StampWhereUniqueInput>
    connect?: Enumerable<StampWhereUniqueInput>
    update?: Enumerable<StampUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<StampUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<StampScalarWhereInput>
  }

  export type Store_LikeUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<Store_LikeCreateWithoutCustomerInput>, Enumerable<Store_LikeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<Store_LikeCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<Store_LikeUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: Store_LikeCreateManyCustomerInputEnvelope
    set?: Enumerable<Store_LikeWhereUniqueInput>
    disconnect?: Enumerable<Store_LikeWhereUniqueInput>
    delete?: Enumerable<Store_LikeWhereUniqueInput>
    connect?: Enumerable<Store_LikeWhereUniqueInput>
    update?: Enumerable<Store_LikeUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<Store_LikeUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<Store_LikeScalarWhereInput>
  }

  export type Store_ReviewUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<Store_ReviewCreateWithoutCustomerInput>, Enumerable<Store_ReviewUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<Store_ReviewCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<Store_ReviewUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: Store_ReviewCreateManyCustomerInputEnvelope
    set?: Enumerable<Store_ReviewWhereUniqueInput>
    disconnect?: Enumerable<Store_ReviewWhereUniqueInput>
    delete?: Enumerable<Store_ReviewWhereUniqueInput>
    connect?: Enumerable<Store_ReviewWhereUniqueInput>
    update?: Enumerable<Store_ReviewUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<Store_ReviewUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<Store_ReviewScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Alim_CustomerUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<Alim_CustomerCreateWithoutCustomerInput>, Enumerable<Alim_CustomerUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<Alim_CustomerCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<Alim_CustomerUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: Alim_CustomerCreateManyCustomerInputEnvelope
    set?: Enumerable<Alim_CustomerWhereUniqueInput>
    disconnect?: Enumerable<Alim_CustomerWhereUniqueInput>
    delete?: Enumerable<Alim_CustomerWhereUniqueInput>
    connect?: Enumerable<Alim_CustomerWhereUniqueInput>
    update?: Enumerable<Alim_CustomerUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<Alim_CustomerUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<Alim_CustomerScalarWhereInput>
  }

  export type DeliveryUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<DeliveryCreateWithoutCustomerInput>, Enumerable<DeliveryUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<DeliveryCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<DeliveryUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: DeliveryCreateManyCustomerInputEnvelope
    set?: Enumerable<DeliveryWhereUniqueInput>
    disconnect?: Enumerable<DeliveryWhereUniqueInput>
    delete?: Enumerable<DeliveryWhereUniqueInput>
    connect?: Enumerable<DeliveryWhereUniqueInput>
    update?: Enumerable<DeliveryUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<DeliveryUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<DeliveryScalarWhereInput>
  }

  export type StampUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<StampCreateWithoutCustomerInput>, Enumerable<StampUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<StampCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<StampUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: StampCreateManyCustomerInputEnvelope
    set?: Enumerable<StampWhereUniqueInput>
    disconnect?: Enumerable<StampWhereUniqueInput>
    delete?: Enumerable<StampWhereUniqueInput>
    connect?: Enumerable<StampWhereUniqueInput>
    update?: Enumerable<StampUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<StampUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<StampScalarWhereInput>
  }

  export type Store_LikeUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<Store_LikeCreateWithoutCustomerInput>, Enumerable<Store_LikeUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<Store_LikeCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<Store_LikeUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: Store_LikeCreateManyCustomerInputEnvelope
    set?: Enumerable<Store_LikeWhereUniqueInput>
    disconnect?: Enumerable<Store_LikeWhereUniqueInput>
    delete?: Enumerable<Store_LikeWhereUniqueInput>
    connect?: Enumerable<Store_LikeWhereUniqueInput>
    update?: Enumerable<Store_LikeUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<Store_LikeUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<Store_LikeScalarWhereInput>
  }

  export type Store_ReviewUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<Enumerable<Store_ReviewCreateWithoutCustomerInput>, Enumerable<Store_ReviewUncheckedCreateWithoutCustomerInput>>
    connectOrCreate?: Enumerable<Store_ReviewCreateOrConnectWithoutCustomerInput>
    upsert?: Enumerable<Store_ReviewUpsertWithWhereUniqueWithoutCustomerInput>
    createMany?: Store_ReviewCreateManyCustomerInputEnvelope
    set?: Enumerable<Store_ReviewWhereUniqueInput>
    disconnect?: Enumerable<Store_ReviewWhereUniqueInput>
    delete?: Enumerable<Store_ReviewWhereUniqueInput>
    connect?: Enumerable<Store_ReviewWhereUniqueInput>
    update?: Enumerable<Store_ReviewUpdateWithWhereUniqueWithoutCustomerInput>
    updateMany?: Enumerable<Store_ReviewUpdateManyWithWhereWithoutCustomerInput>
    deleteMany?: Enumerable<Store_ReviewScalarWhereInput>
  }

  export type CustomerCreateNestedOneWithoutDeliveryInput = {
    create?: XOR<CustomerCreateWithoutDeliveryInput, CustomerUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutDeliveryInput
    connect?: CustomerWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutDeliveryNestedInput = {
    create?: XOR<CustomerCreateWithoutDeliveryInput, CustomerUncheckedCreateWithoutDeliveryInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutDeliveryInput
    upsert?: CustomerUpsertWithoutDeliveryInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutDeliveryInput, CustomerUncheckedUpdateWithoutDeliveryInput>
  }

  export type CustomerCreateNestedOneWithoutStampInput = {
    create?: XOR<CustomerCreateWithoutStampInput, CustomerUncheckedCreateWithoutStampInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutStampInput
    connect?: CustomerWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutStampInput = {
    create?: XOR<StoreCreateWithoutStampInput, StoreUncheckedCreateWithoutStampInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStampInput
    connect?: StoreWhereUniqueInput
  }

  export type TourCreateNestedOneWithoutStampInput = {
    create?: XOR<TourCreateWithoutStampInput, TourUncheckedCreateWithoutStampInput>
    connectOrCreate?: TourCreateOrConnectWithoutStampInput
    connect?: TourWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CustomerUpdateOneWithoutStampNestedInput = {
    create?: XOR<CustomerCreateWithoutStampInput, CustomerUncheckedCreateWithoutStampInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutStampInput
    upsert?: CustomerUpsertWithoutStampInput
    disconnect?: boolean
    delete?: boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutStampInput, CustomerUncheckedUpdateWithoutStampInput>
  }

  export type StoreUpdateOneWithoutStampNestedInput = {
    create?: XOR<StoreCreateWithoutStampInput, StoreUncheckedCreateWithoutStampInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStampInput
    upsert?: StoreUpsertWithoutStampInput
    disconnect?: boolean
    delete?: boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<StoreUpdateWithoutStampInput, StoreUncheckedUpdateWithoutStampInput>
  }

  export type TourUpdateOneWithoutStampNestedInput = {
    create?: XOR<TourCreateWithoutStampInput, TourUncheckedCreateWithoutStampInput>
    connectOrCreate?: TourCreateOrConnectWithoutStampInput
    upsert?: TourUpsertWithoutStampInput
    disconnect?: boolean
    delete?: boolean
    connect?: TourWhereUniqueInput
    update?: XOR<TourUpdateWithoutStampInput, TourUncheckedUpdateWithoutStampInput>
  }

  export type StoreCreatecategoryInput = {
    set: Enumerable<string>
  }

  export type CustomerCreateNestedManyWithoutStoreInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutStoreInput>, Enumerable<CustomerUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutStoreInput>
    createMany?: CustomerCreateManyStoreInputEnvelope
    connect?: Enumerable<CustomerWhereUniqueInput>
  }

  export type StampCreateNestedManyWithoutStoreInput = {
    create?: XOR<Enumerable<StampCreateWithoutStoreInput>, Enumerable<StampUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<StampCreateOrConnectWithoutStoreInput>
    createMany?: StampCreateManyStoreInputEnvelope
    connect?: Enumerable<StampWhereUniqueInput>
  }

  export type Store_OwnerCreateNestedOneWithoutStore_Store_ownerIdToStore_OwnerInput = {
    create?: XOR<Store_OwnerCreateWithoutStore_Store_ownerIdToStore_OwnerInput, Store_OwnerUncheckedCreateWithoutStore_Store_ownerIdToStore_OwnerInput>
    connectOrCreate?: Store_OwnerCreateOrConnectWithoutStore_Store_ownerIdToStore_OwnerInput
    connect?: Store_OwnerWhereUniqueInput
  }

  export type TourCreateNestedOneWithoutStoreInput = {
    create?: XOR<TourCreateWithoutStoreInput, TourUncheckedCreateWithoutStoreInput>
    connectOrCreate?: TourCreateOrConnectWithoutStoreInput
    connect?: TourWhereUniqueInput
  }

  export type Store_LikeCreateNestedManyWithoutStoreInput = {
    create?: XOR<Enumerable<Store_LikeCreateWithoutStoreInput>, Enumerable<Store_LikeUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_LikeCreateOrConnectWithoutStoreInput>
    createMany?: Store_LikeCreateManyStoreInputEnvelope
    connect?: Enumerable<Store_LikeWhereUniqueInput>
  }

  export type Store_MenuCreateNestedManyWithoutStoreInput = {
    create?: XOR<Enumerable<Store_MenuCreateWithoutStoreInput>, Enumerable<Store_MenuUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_MenuCreateOrConnectWithoutStoreInput>
    createMany?: Store_MenuCreateManyStoreInputEnvelope
    connect?: Enumerable<Store_MenuWhereUniqueInput>
  }

  export type Store_NoticeCreateNestedManyWithoutStoreInput = {
    create?: XOR<Enumerable<Store_NoticeCreateWithoutStoreInput>, Enumerable<Store_NoticeUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_NoticeCreateOrConnectWithoutStoreInput>
    createMany?: Store_NoticeCreateManyStoreInputEnvelope
    connect?: Enumerable<Store_NoticeWhereUniqueInput>
  }

  export type Store_OwnerCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput = {
    create?: XOR<Store_OwnerCreateWithoutStore_Store_Owner_storeIdToStoreInput, Store_OwnerUncheckedCreateWithoutStore_Store_Owner_storeIdToStoreInput>
    connectOrCreate?: Store_OwnerCreateOrConnectWithoutStore_Store_Owner_storeIdToStoreInput
    connect?: Store_OwnerWhereUniqueInput
  }

  export type Store_ProductCreateNestedManyWithoutStoreInput = {
    create?: XOR<Enumerable<Store_ProductCreateWithoutStoreInput>, Enumerable<Store_ProductUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_ProductCreateOrConnectWithoutStoreInput>
    createMany?: Store_ProductCreateManyStoreInputEnvelope
    connect?: Enumerable<Store_ProductWhereUniqueInput>
  }

  export type Store_ReviewCreateNestedOneWithoutStoreInput = {
    create?: XOR<Store_ReviewCreateWithoutStoreInput, Store_ReviewUncheckedCreateWithoutStoreInput>
    connectOrCreate?: Store_ReviewCreateOrConnectWithoutStoreInput
    connect?: Store_ReviewWhereUniqueInput
  }

  export type CustomerUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutStoreInput>, Enumerable<CustomerUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutStoreInput>
    createMany?: CustomerCreateManyStoreInputEnvelope
    connect?: Enumerable<CustomerWhereUniqueInput>
  }

  export type StampUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<Enumerable<StampCreateWithoutStoreInput>, Enumerable<StampUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<StampCreateOrConnectWithoutStoreInput>
    createMany?: StampCreateManyStoreInputEnvelope
    connect?: Enumerable<StampWhereUniqueInput>
  }

  export type Store_LikeUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<Enumerable<Store_LikeCreateWithoutStoreInput>, Enumerable<Store_LikeUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_LikeCreateOrConnectWithoutStoreInput>
    createMany?: Store_LikeCreateManyStoreInputEnvelope
    connect?: Enumerable<Store_LikeWhereUniqueInput>
  }

  export type Store_MenuUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<Enumerable<Store_MenuCreateWithoutStoreInput>, Enumerable<Store_MenuUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_MenuCreateOrConnectWithoutStoreInput>
    createMany?: Store_MenuCreateManyStoreInputEnvelope
    connect?: Enumerable<Store_MenuWhereUniqueInput>
  }

  export type Store_NoticeUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<Enumerable<Store_NoticeCreateWithoutStoreInput>, Enumerable<Store_NoticeUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_NoticeCreateOrConnectWithoutStoreInput>
    createMany?: Store_NoticeCreateManyStoreInputEnvelope
    connect?: Enumerable<Store_NoticeWhereUniqueInput>
  }

  export type Store_OwnerUncheckedCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput = {
    create?: XOR<Store_OwnerCreateWithoutStore_Store_Owner_storeIdToStoreInput, Store_OwnerUncheckedCreateWithoutStore_Store_Owner_storeIdToStoreInput>
    connectOrCreate?: Store_OwnerCreateOrConnectWithoutStore_Store_Owner_storeIdToStoreInput
    connect?: Store_OwnerWhereUniqueInput
  }

  export type Store_ProductUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<Enumerable<Store_ProductCreateWithoutStoreInput>, Enumerable<Store_ProductUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_ProductCreateOrConnectWithoutStoreInput>
    createMany?: Store_ProductCreateManyStoreInputEnvelope
    connect?: Enumerable<Store_ProductWhereUniqueInput>
  }

  export type Store_ReviewUncheckedCreateNestedOneWithoutStoreInput = {
    create?: XOR<Store_ReviewCreateWithoutStoreInput, Store_ReviewUncheckedCreateWithoutStoreInput>
    connectOrCreate?: Store_ReviewCreateOrConnectWithoutStoreInput
    connect?: Store_ReviewWhereUniqueInput
  }

  export type StoreUpdatecategoryInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type CustomerUpdateManyWithoutStoreNestedInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutStoreInput>, Enumerable<CustomerUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutStoreInput>
    upsert?: Enumerable<CustomerUpsertWithWhereUniqueWithoutStoreInput>
    createMany?: CustomerCreateManyStoreInputEnvelope
    set?: Enumerable<CustomerWhereUniqueInput>
    disconnect?: Enumerable<CustomerWhereUniqueInput>
    delete?: Enumerable<CustomerWhereUniqueInput>
    connect?: Enumerable<CustomerWhereUniqueInput>
    update?: Enumerable<CustomerUpdateWithWhereUniqueWithoutStoreInput>
    updateMany?: Enumerable<CustomerUpdateManyWithWhereWithoutStoreInput>
    deleteMany?: Enumerable<CustomerScalarWhereInput>
  }

  export type StampUpdateManyWithoutStoreNestedInput = {
    create?: XOR<Enumerable<StampCreateWithoutStoreInput>, Enumerable<StampUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<StampCreateOrConnectWithoutStoreInput>
    upsert?: Enumerable<StampUpsertWithWhereUniqueWithoutStoreInput>
    createMany?: StampCreateManyStoreInputEnvelope
    set?: Enumerable<StampWhereUniqueInput>
    disconnect?: Enumerable<StampWhereUniqueInput>
    delete?: Enumerable<StampWhereUniqueInput>
    connect?: Enumerable<StampWhereUniqueInput>
    update?: Enumerable<StampUpdateWithWhereUniqueWithoutStoreInput>
    updateMany?: Enumerable<StampUpdateManyWithWhereWithoutStoreInput>
    deleteMany?: Enumerable<StampScalarWhereInput>
  }

  export type Store_OwnerUpdateOneRequiredWithoutStore_Store_ownerIdToStore_OwnerNestedInput = {
    create?: XOR<Store_OwnerCreateWithoutStore_Store_ownerIdToStore_OwnerInput, Store_OwnerUncheckedCreateWithoutStore_Store_ownerIdToStore_OwnerInput>
    connectOrCreate?: Store_OwnerCreateOrConnectWithoutStore_Store_ownerIdToStore_OwnerInput
    upsert?: Store_OwnerUpsertWithoutStore_Store_ownerIdToStore_OwnerInput
    connect?: Store_OwnerWhereUniqueInput
    update?: XOR<Store_OwnerUpdateWithoutStore_Store_ownerIdToStore_OwnerInput, Store_OwnerUncheckedUpdateWithoutStore_Store_ownerIdToStore_OwnerInput>
  }

  export type TourUpdateOneWithoutStoreNestedInput = {
    create?: XOR<TourCreateWithoutStoreInput, TourUncheckedCreateWithoutStoreInput>
    connectOrCreate?: TourCreateOrConnectWithoutStoreInput
    upsert?: TourUpsertWithoutStoreInput
    disconnect?: boolean
    delete?: boolean
    connect?: TourWhereUniqueInput
    update?: XOR<TourUpdateWithoutStoreInput, TourUncheckedUpdateWithoutStoreInput>
  }

  export type Store_LikeUpdateManyWithoutStoreNestedInput = {
    create?: XOR<Enumerable<Store_LikeCreateWithoutStoreInput>, Enumerable<Store_LikeUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_LikeCreateOrConnectWithoutStoreInput>
    upsert?: Enumerable<Store_LikeUpsertWithWhereUniqueWithoutStoreInput>
    createMany?: Store_LikeCreateManyStoreInputEnvelope
    set?: Enumerable<Store_LikeWhereUniqueInput>
    disconnect?: Enumerable<Store_LikeWhereUniqueInput>
    delete?: Enumerable<Store_LikeWhereUniqueInput>
    connect?: Enumerable<Store_LikeWhereUniqueInput>
    update?: Enumerable<Store_LikeUpdateWithWhereUniqueWithoutStoreInput>
    updateMany?: Enumerable<Store_LikeUpdateManyWithWhereWithoutStoreInput>
    deleteMany?: Enumerable<Store_LikeScalarWhereInput>
  }

  export type Store_MenuUpdateManyWithoutStoreNestedInput = {
    create?: XOR<Enumerable<Store_MenuCreateWithoutStoreInput>, Enumerable<Store_MenuUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_MenuCreateOrConnectWithoutStoreInput>
    upsert?: Enumerable<Store_MenuUpsertWithWhereUniqueWithoutStoreInput>
    createMany?: Store_MenuCreateManyStoreInputEnvelope
    set?: Enumerable<Store_MenuWhereUniqueInput>
    disconnect?: Enumerable<Store_MenuWhereUniqueInput>
    delete?: Enumerable<Store_MenuWhereUniqueInput>
    connect?: Enumerable<Store_MenuWhereUniqueInput>
    update?: Enumerable<Store_MenuUpdateWithWhereUniqueWithoutStoreInput>
    updateMany?: Enumerable<Store_MenuUpdateManyWithWhereWithoutStoreInput>
    deleteMany?: Enumerable<Store_MenuScalarWhereInput>
  }

  export type Store_NoticeUpdateManyWithoutStoreNestedInput = {
    create?: XOR<Enumerable<Store_NoticeCreateWithoutStoreInput>, Enumerable<Store_NoticeUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_NoticeCreateOrConnectWithoutStoreInput>
    upsert?: Enumerable<Store_NoticeUpsertWithWhereUniqueWithoutStoreInput>
    createMany?: Store_NoticeCreateManyStoreInputEnvelope
    set?: Enumerable<Store_NoticeWhereUniqueInput>
    disconnect?: Enumerable<Store_NoticeWhereUniqueInput>
    delete?: Enumerable<Store_NoticeWhereUniqueInput>
    connect?: Enumerable<Store_NoticeWhereUniqueInput>
    update?: Enumerable<Store_NoticeUpdateWithWhereUniqueWithoutStoreInput>
    updateMany?: Enumerable<Store_NoticeUpdateManyWithWhereWithoutStoreInput>
    deleteMany?: Enumerable<Store_NoticeScalarWhereInput>
  }

  export type Store_OwnerUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput = {
    create?: XOR<Store_OwnerCreateWithoutStore_Store_Owner_storeIdToStoreInput, Store_OwnerUncheckedCreateWithoutStore_Store_Owner_storeIdToStoreInput>
    connectOrCreate?: Store_OwnerCreateOrConnectWithoutStore_Store_Owner_storeIdToStoreInput
    upsert?: Store_OwnerUpsertWithoutStore_Store_Owner_storeIdToStoreInput
    disconnect?: boolean
    delete?: boolean
    connect?: Store_OwnerWhereUniqueInput
    update?: XOR<Store_OwnerUpdateWithoutStore_Store_Owner_storeIdToStoreInput, Store_OwnerUncheckedUpdateWithoutStore_Store_Owner_storeIdToStoreInput>
  }

  export type Store_ProductUpdateManyWithoutStoreNestedInput = {
    create?: XOR<Enumerable<Store_ProductCreateWithoutStoreInput>, Enumerable<Store_ProductUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_ProductCreateOrConnectWithoutStoreInput>
    upsert?: Enumerable<Store_ProductUpsertWithWhereUniqueWithoutStoreInput>
    createMany?: Store_ProductCreateManyStoreInputEnvelope
    set?: Enumerable<Store_ProductWhereUniqueInput>
    disconnect?: Enumerable<Store_ProductWhereUniqueInput>
    delete?: Enumerable<Store_ProductWhereUniqueInput>
    connect?: Enumerable<Store_ProductWhereUniqueInput>
    update?: Enumerable<Store_ProductUpdateWithWhereUniqueWithoutStoreInput>
    updateMany?: Enumerable<Store_ProductUpdateManyWithWhereWithoutStoreInput>
    deleteMany?: Enumerable<Store_ProductScalarWhereInput>
  }

  export type Store_ReviewUpdateOneWithoutStoreNestedInput = {
    create?: XOR<Store_ReviewCreateWithoutStoreInput, Store_ReviewUncheckedCreateWithoutStoreInput>
    connectOrCreate?: Store_ReviewCreateOrConnectWithoutStoreInput
    upsert?: Store_ReviewUpsertWithoutStoreInput
    disconnect?: boolean
    delete?: boolean
    connect?: Store_ReviewWhereUniqueInput
    update?: XOR<Store_ReviewUpdateWithoutStoreInput, Store_ReviewUncheckedUpdateWithoutStoreInput>
  }

  export type CustomerUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<Enumerable<CustomerCreateWithoutStoreInput>, Enumerable<CustomerUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<CustomerCreateOrConnectWithoutStoreInput>
    upsert?: Enumerable<CustomerUpsertWithWhereUniqueWithoutStoreInput>
    createMany?: CustomerCreateManyStoreInputEnvelope
    set?: Enumerable<CustomerWhereUniqueInput>
    disconnect?: Enumerable<CustomerWhereUniqueInput>
    delete?: Enumerable<CustomerWhereUniqueInput>
    connect?: Enumerable<CustomerWhereUniqueInput>
    update?: Enumerable<CustomerUpdateWithWhereUniqueWithoutStoreInput>
    updateMany?: Enumerable<CustomerUpdateManyWithWhereWithoutStoreInput>
    deleteMany?: Enumerable<CustomerScalarWhereInput>
  }

  export type StampUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<Enumerable<StampCreateWithoutStoreInput>, Enumerable<StampUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<StampCreateOrConnectWithoutStoreInput>
    upsert?: Enumerable<StampUpsertWithWhereUniqueWithoutStoreInput>
    createMany?: StampCreateManyStoreInputEnvelope
    set?: Enumerable<StampWhereUniqueInput>
    disconnect?: Enumerable<StampWhereUniqueInput>
    delete?: Enumerable<StampWhereUniqueInput>
    connect?: Enumerable<StampWhereUniqueInput>
    update?: Enumerable<StampUpdateWithWhereUniqueWithoutStoreInput>
    updateMany?: Enumerable<StampUpdateManyWithWhereWithoutStoreInput>
    deleteMany?: Enumerable<StampScalarWhereInput>
  }

  export type Store_LikeUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<Enumerable<Store_LikeCreateWithoutStoreInput>, Enumerable<Store_LikeUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_LikeCreateOrConnectWithoutStoreInput>
    upsert?: Enumerable<Store_LikeUpsertWithWhereUniqueWithoutStoreInput>
    createMany?: Store_LikeCreateManyStoreInputEnvelope
    set?: Enumerable<Store_LikeWhereUniqueInput>
    disconnect?: Enumerable<Store_LikeWhereUniqueInput>
    delete?: Enumerable<Store_LikeWhereUniqueInput>
    connect?: Enumerable<Store_LikeWhereUniqueInput>
    update?: Enumerable<Store_LikeUpdateWithWhereUniqueWithoutStoreInput>
    updateMany?: Enumerable<Store_LikeUpdateManyWithWhereWithoutStoreInput>
    deleteMany?: Enumerable<Store_LikeScalarWhereInput>
  }

  export type Store_MenuUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<Enumerable<Store_MenuCreateWithoutStoreInput>, Enumerable<Store_MenuUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_MenuCreateOrConnectWithoutStoreInput>
    upsert?: Enumerable<Store_MenuUpsertWithWhereUniqueWithoutStoreInput>
    createMany?: Store_MenuCreateManyStoreInputEnvelope
    set?: Enumerable<Store_MenuWhereUniqueInput>
    disconnect?: Enumerable<Store_MenuWhereUniqueInput>
    delete?: Enumerable<Store_MenuWhereUniqueInput>
    connect?: Enumerable<Store_MenuWhereUniqueInput>
    update?: Enumerable<Store_MenuUpdateWithWhereUniqueWithoutStoreInput>
    updateMany?: Enumerable<Store_MenuUpdateManyWithWhereWithoutStoreInput>
    deleteMany?: Enumerable<Store_MenuScalarWhereInput>
  }

  export type Store_NoticeUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<Enumerable<Store_NoticeCreateWithoutStoreInput>, Enumerable<Store_NoticeUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_NoticeCreateOrConnectWithoutStoreInput>
    upsert?: Enumerable<Store_NoticeUpsertWithWhereUniqueWithoutStoreInput>
    createMany?: Store_NoticeCreateManyStoreInputEnvelope
    set?: Enumerable<Store_NoticeWhereUniqueInput>
    disconnect?: Enumerable<Store_NoticeWhereUniqueInput>
    delete?: Enumerable<Store_NoticeWhereUniqueInput>
    connect?: Enumerable<Store_NoticeWhereUniqueInput>
    update?: Enumerable<Store_NoticeUpdateWithWhereUniqueWithoutStoreInput>
    updateMany?: Enumerable<Store_NoticeUpdateManyWithWhereWithoutStoreInput>
    deleteMany?: Enumerable<Store_NoticeScalarWhereInput>
  }

  export type Store_OwnerUncheckedUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput = {
    create?: XOR<Store_OwnerCreateWithoutStore_Store_Owner_storeIdToStoreInput, Store_OwnerUncheckedCreateWithoutStore_Store_Owner_storeIdToStoreInput>
    connectOrCreate?: Store_OwnerCreateOrConnectWithoutStore_Store_Owner_storeIdToStoreInput
    upsert?: Store_OwnerUpsertWithoutStore_Store_Owner_storeIdToStoreInput
    disconnect?: boolean
    delete?: boolean
    connect?: Store_OwnerWhereUniqueInput
    update?: XOR<Store_OwnerUpdateWithoutStore_Store_Owner_storeIdToStoreInput, Store_OwnerUncheckedUpdateWithoutStore_Store_Owner_storeIdToStoreInput>
  }

  export type Store_ProductUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<Enumerable<Store_ProductCreateWithoutStoreInput>, Enumerable<Store_ProductUncheckedCreateWithoutStoreInput>>
    connectOrCreate?: Enumerable<Store_ProductCreateOrConnectWithoutStoreInput>
    upsert?: Enumerable<Store_ProductUpsertWithWhereUniqueWithoutStoreInput>
    createMany?: Store_ProductCreateManyStoreInputEnvelope
    set?: Enumerable<Store_ProductWhereUniqueInput>
    disconnect?: Enumerable<Store_ProductWhereUniqueInput>
    delete?: Enumerable<Store_ProductWhereUniqueInput>
    connect?: Enumerable<Store_ProductWhereUniqueInput>
    update?: Enumerable<Store_ProductUpdateWithWhereUniqueWithoutStoreInput>
    updateMany?: Enumerable<Store_ProductUpdateManyWithWhereWithoutStoreInput>
    deleteMany?: Enumerable<Store_ProductScalarWhereInput>
  }

  export type Store_ReviewUncheckedUpdateOneWithoutStoreNestedInput = {
    create?: XOR<Store_ReviewCreateWithoutStoreInput, Store_ReviewUncheckedCreateWithoutStoreInput>
    connectOrCreate?: Store_ReviewCreateOrConnectWithoutStoreInput
    upsert?: Store_ReviewUpsertWithoutStoreInput
    disconnect?: boolean
    delete?: boolean
    connect?: Store_ReviewWhereUniqueInput
    update?: XOR<Store_ReviewUpdateWithoutStoreInput, Store_ReviewUncheckedUpdateWithoutStoreInput>
  }

  export type StoreCreateNestedOneWithoutStore_MenuInput = {
    create?: XOR<StoreCreateWithoutStore_MenuInput, StoreUncheckedCreateWithoutStore_MenuInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_MenuInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreUpdateOneWithoutStore_MenuNestedInput = {
    create?: XOR<StoreCreateWithoutStore_MenuInput, StoreUncheckedCreateWithoutStore_MenuInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_MenuInput
    upsert?: StoreUpsertWithoutStore_MenuInput
    disconnect?: boolean
    delete?: boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<StoreUpdateWithoutStore_MenuInput, StoreUncheckedUpdateWithoutStore_MenuInput>
  }

  export type StoreCreateNestedOneWithoutStore_NoticeInput = {
    create?: XOR<StoreCreateWithoutStore_NoticeInput, StoreUncheckedCreateWithoutStore_NoticeInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_NoticeInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreUpdateOneWithoutStore_NoticeNestedInput = {
    create?: XOR<StoreCreateWithoutStore_NoticeInput, StoreUncheckedCreateWithoutStore_NoticeInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_NoticeInput
    upsert?: StoreUpsertWithoutStore_NoticeInput
    disconnect?: boolean
    delete?: boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<StoreUpdateWithoutStore_NoticeInput, StoreUncheckedUpdateWithoutStore_NoticeInput>
  }

  export type Alim_RequestCreateNestedManyWithoutStore_OwnerInput = {
    create?: XOR<Enumerable<Alim_RequestCreateWithoutStore_OwnerInput>, Enumerable<Alim_RequestUncheckedCreateWithoutStore_OwnerInput>>
    connectOrCreate?: Enumerable<Alim_RequestCreateOrConnectWithoutStore_OwnerInput>
    createMany?: Alim_RequestCreateManyStore_OwnerInputEnvelope
    connect?: Enumerable<Alim_RequestWhereUniqueInput>
  }

  export type Stamp_RequestCreateNestedOneWithoutStore_OwnerInput = {
    create?: XOR<Stamp_RequestCreateWithoutStore_OwnerInput, Stamp_RequestUncheckedCreateWithoutStore_OwnerInput>
    connectOrCreate?: Stamp_RequestCreateOrConnectWithoutStore_OwnerInput
    connect?: Stamp_RequestWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutStore_Owner_Store_ownerIdToStore_OwnerInput = {
    create?: XOR<StoreCreateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput, StoreUncheckedCreateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_Owner_Store_ownerIdToStore_OwnerInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutStore_Owner_Store_Owner_storeIdToStoreInput = {
    create?: XOR<StoreCreateWithoutStore_Owner_Store_Owner_storeIdToStoreInput, StoreUncheckedCreateWithoutStore_Owner_Store_Owner_storeIdToStoreInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_Owner_Store_Owner_storeIdToStoreInput
    connect?: StoreWhereUniqueInput
  }

  export type Alim_RequestUncheckedCreateNestedManyWithoutStore_OwnerInput = {
    create?: XOR<Enumerable<Alim_RequestCreateWithoutStore_OwnerInput>, Enumerable<Alim_RequestUncheckedCreateWithoutStore_OwnerInput>>
    connectOrCreate?: Enumerable<Alim_RequestCreateOrConnectWithoutStore_OwnerInput>
    createMany?: Alim_RequestCreateManyStore_OwnerInputEnvelope
    connect?: Enumerable<Alim_RequestWhereUniqueInput>
  }

  export type Stamp_RequestUncheckedCreateNestedOneWithoutStore_OwnerInput = {
    create?: XOR<Stamp_RequestCreateWithoutStore_OwnerInput, Stamp_RequestUncheckedCreateWithoutStore_OwnerInput>
    connectOrCreate?: Stamp_RequestCreateOrConnectWithoutStore_OwnerInput
    connect?: Stamp_RequestWhereUniqueInput
  }

  export type StoreUncheckedCreateNestedOneWithoutStore_Owner_Store_ownerIdToStore_OwnerInput = {
    create?: XOR<StoreCreateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput, StoreUncheckedCreateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_Owner_Store_ownerIdToStore_OwnerInput
    connect?: StoreWhereUniqueInput
  }

  export type Alim_RequestUpdateManyWithoutStore_OwnerNestedInput = {
    create?: XOR<Enumerable<Alim_RequestCreateWithoutStore_OwnerInput>, Enumerable<Alim_RequestUncheckedCreateWithoutStore_OwnerInput>>
    connectOrCreate?: Enumerable<Alim_RequestCreateOrConnectWithoutStore_OwnerInput>
    upsert?: Enumerable<Alim_RequestUpsertWithWhereUniqueWithoutStore_OwnerInput>
    createMany?: Alim_RequestCreateManyStore_OwnerInputEnvelope
    set?: Enumerable<Alim_RequestWhereUniqueInput>
    disconnect?: Enumerable<Alim_RequestWhereUniqueInput>
    delete?: Enumerable<Alim_RequestWhereUniqueInput>
    connect?: Enumerable<Alim_RequestWhereUniqueInput>
    update?: Enumerable<Alim_RequestUpdateWithWhereUniqueWithoutStore_OwnerInput>
    updateMany?: Enumerable<Alim_RequestUpdateManyWithWhereWithoutStore_OwnerInput>
    deleteMany?: Enumerable<Alim_RequestScalarWhereInput>
  }

  export type Stamp_RequestUpdateOneWithoutStore_OwnerNestedInput = {
    create?: XOR<Stamp_RequestCreateWithoutStore_OwnerInput, Stamp_RequestUncheckedCreateWithoutStore_OwnerInput>
    connectOrCreate?: Stamp_RequestCreateOrConnectWithoutStore_OwnerInput
    upsert?: Stamp_RequestUpsertWithoutStore_OwnerInput
    disconnect?: boolean
    delete?: boolean
    connect?: Stamp_RequestWhereUniqueInput
    update?: XOR<Stamp_RequestUpdateWithoutStore_OwnerInput, Stamp_RequestUncheckedUpdateWithoutStore_OwnerInput>
  }

  export type StoreUpdateOneWithoutStore_Owner_Store_ownerIdToStore_OwnerNestedInput = {
    create?: XOR<StoreCreateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput, StoreUncheckedCreateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_Owner_Store_ownerIdToStore_OwnerInput
    upsert?: StoreUpsertWithoutStore_Owner_Store_ownerIdToStore_OwnerInput
    disconnect?: boolean
    delete?: boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<StoreUpdateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput, StoreUncheckedUpdateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput>
  }

  export type StoreUpdateOneWithoutStore_Owner_Store_Owner_storeIdToStoreNestedInput = {
    create?: XOR<StoreCreateWithoutStore_Owner_Store_Owner_storeIdToStoreInput, StoreUncheckedCreateWithoutStore_Owner_Store_Owner_storeIdToStoreInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_Owner_Store_Owner_storeIdToStoreInput
    upsert?: StoreUpsertWithoutStore_Owner_Store_Owner_storeIdToStoreInput
    disconnect?: boolean
    delete?: boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<StoreUpdateWithoutStore_Owner_Store_Owner_storeIdToStoreInput, StoreUncheckedUpdateWithoutStore_Owner_Store_Owner_storeIdToStoreInput>
  }

  export type Alim_RequestUncheckedUpdateManyWithoutStore_OwnerNestedInput = {
    create?: XOR<Enumerable<Alim_RequestCreateWithoutStore_OwnerInput>, Enumerable<Alim_RequestUncheckedCreateWithoutStore_OwnerInput>>
    connectOrCreate?: Enumerable<Alim_RequestCreateOrConnectWithoutStore_OwnerInput>
    upsert?: Enumerable<Alim_RequestUpsertWithWhereUniqueWithoutStore_OwnerInput>
    createMany?: Alim_RequestCreateManyStore_OwnerInputEnvelope
    set?: Enumerable<Alim_RequestWhereUniqueInput>
    disconnect?: Enumerable<Alim_RequestWhereUniqueInput>
    delete?: Enumerable<Alim_RequestWhereUniqueInput>
    connect?: Enumerable<Alim_RequestWhereUniqueInput>
    update?: Enumerable<Alim_RequestUpdateWithWhereUniqueWithoutStore_OwnerInput>
    updateMany?: Enumerable<Alim_RequestUpdateManyWithWhereWithoutStore_OwnerInput>
    deleteMany?: Enumerable<Alim_RequestScalarWhereInput>
  }

  export type Stamp_RequestUncheckedUpdateOneWithoutStore_OwnerNestedInput = {
    create?: XOR<Stamp_RequestCreateWithoutStore_OwnerInput, Stamp_RequestUncheckedCreateWithoutStore_OwnerInput>
    connectOrCreate?: Stamp_RequestCreateOrConnectWithoutStore_OwnerInput
    upsert?: Stamp_RequestUpsertWithoutStore_OwnerInput
    disconnect?: boolean
    delete?: boolean
    connect?: Stamp_RequestWhereUniqueInput
    update?: XOR<Stamp_RequestUpdateWithoutStore_OwnerInput, Stamp_RequestUncheckedUpdateWithoutStore_OwnerInput>
  }

  export type StoreUncheckedUpdateOneWithoutStore_Owner_Store_ownerIdToStore_OwnerNestedInput = {
    create?: XOR<StoreCreateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput, StoreUncheckedCreateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_Owner_Store_ownerIdToStore_OwnerInput
    upsert?: StoreUpsertWithoutStore_Owner_Store_ownerIdToStore_OwnerInput
    disconnect?: boolean
    delete?: boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<StoreUpdateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput, StoreUncheckedUpdateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput>
  }

  export type StoreCreateNestedOneWithoutStore_ProductInput = {
    create?: XOR<StoreCreateWithoutStore_ProductInput, StoreUncheckedCreateWithoutStore_ProductInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_ProductInput
    connect?: StoreWhereUniqueInput
  }

  export type StoreUpdateOneWithoutStore_ProductNestedInput = {
    create?: XOR<StoreCreateWithoutStore_ProductInput, StoreUncheckedCreateWithoutStore_ProductInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_ProductInput
    upsert?: StoreUpsertWithoutStore_ProductInput
    disconnect?: boolean
    delete?: boolean
    connect?: StoreWhereUniqueInput
    update?: XOR<StoreUpdateWithoutStore_ProductInput, StoreUncheckedUpdateWithoutStore_ProductInput>
  }

  export type TourCreatecafeListInput = {
    set: Enumerable<string>
  }

  export type StampCreateNestedManyWithoutTourInput = {
    create?: XOR<Enumerable<StampCreateWithoutTourInput>, Enumerable<StampUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<StampCreateOrConnectWithoutTourInput>
    createMany?: StampCreateManyTourInputEnvelope
    connect?: Enumerable<StampWhereUniqueInput>
  }

  export type StoreCreateNestedManyWithoutTourInput = {
    create?: XOR<Enumerable<StoreCreateWithoutTourInput>, Enumerable<StoreUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<StoreCreateOrConnectWithoutTourInput>
    createMany?: StoreCreateManyTourInputEnvelope
    connect?: Enumerable<StoreWhereUniqueInput>
  }

  export type StampUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<Enumerable<StampCreateWithoutTourInput>, Enumerable<StampUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<StampCreateOrConnectWithoutTourInput>
    createMany?: StampCreateManyTourInputEnvelope
    connect?: Enumerable<StampWhereUniqueInput>
  }

  export type StoreUncheckedCreateNestedManyWithoutTourInput = {
    create?: XOR<Enumerable<StoreCreateWithoutTourInput>, Enumerable<StoreUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<StoreCreateOrConnectWithoutTourInput>
    createMany?: StoreCreateManyTourInputEnvelope
    connect?: Enumerable<StoreWhereUniqueInput>
  }

  export type TourUpdatecafeListInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type StampUpdateManyWithoutTourNestedInput = {
    create?: XOR<Enumerable<StampCreateWithoutTourInput>, Enumerable<StampUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<StampCreateOrConnectWithoutTourInput>
    upsert?: Enumerable<StampUpsertWithWhereUniqueWithoutTourInput>
    createMany?: StampCreateManyTourInputEnvelope
    set?: Enumerable<StampWhereUniqueInput>
    disconnect?: Enumerable<StampWhereUniqueInput>
    delete?: Enumerable<StampWhereUniqueInput>
    connect?: Enumerable<StampWhereUniqueInput>
    update?: Enumerable<StampUpdateWithWhereUniqueWithoutTourInput>
    updateMany?: Enumerable<StampUpdateManyWithWhereWithoutTourInput>
    deleteMany?: Enumerable<StampScalarWhereInput>
  }

  export type StoreUpdateManyWithoutTourNestedInput = {
    create?: XOR<Enumerable<StoreCreateWithoutTourInput>, Enumerable<StoreUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<StoreCreateOrConnectWithoutTourInput>
    upsert?: Enumerable<StoreUpsertWithWhereUniqueWithoutTourInput>
    createMany?: StoreCreateManyTourInputEnvelope
    set?: Enumerable<StoreWhereUniqueInput>
    disconnect?: Enumerable<StoreWhereUniqueInput>
    delete?: Enumerable<StoreWhereUniqueInput>
    connect?: Enumerable<StoreWhereUniqueInput>
    update?: Enumerable<StoreUpdateWithWhereUniqueWithoutTourInput>
    updateMany?: Enumerable<StoreUpdateManyWithWhereWithoutTourInput>
    deleteMany?: Enumerable<StoreScalarWhereInput>
  }

  export type StampUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<Enumerable<StampCreateWithoutTourInput>, Enumerable<StampUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<StampCreateOrConnectWithoutTourInput>
    upsert?: Enumerable<StampUpsertWithWhereUniqueWithoutTourInput>
    createMany?: StampCreateManyTourInputEnvelope
    set?: Enumerable<StampWhereUniqueInput>
    disconnect?: Enumerable<StampWhereUniqueInput>
    delete?: Enumerable<StampWhereUniqueInput>
    connect?: Enumerable<StampWhereUniqueInput>
    update?: Enumerable<StampUpdateWithWhereUniqueWithoutTourInput>
    updateMany?: Enumerable<StampUpdateManyWithWhereWithoutTourInput>
    deleteMany?: Enumerable<StampScalarWhereInput>
  }

  export type StoreUncheckedUpdateManyWithoutTourNestedInput = {
    create?: XOR<Enumerable<StoreCreateWithoutTourInput>, Enumerable<StoreUncheckedCreateWithoutTourInput>>
    connectOrCreate?: Enumerable<StoreCreateOrConnectWithoutTourInput>
    upsert?: Enumerable<StoreUpsertWithWhereUniqueWithoutTourInput>
    createMany?: StoreCreateManyTourInputEnvelope
    set?: Enumerable<StoreWhereUniqueInput>
    disconnect?: Enumerable<StoreWhereUniqueInput>
    delete?: Enumerable<StoreWhereUniqueInput>
    connect?: Enumerable<StoreWhereUniqueInput>
    update?: Enumerable<StoreUpdateWithWhereUniqueWithoutTourInput>
    updateMany?: Enumerable<StoreUpdateManyWithWhereWithoutTourInput>
    deleteMany?: Enumerable<StoreScalarWhereInput>
  }

  export type StoreCreateNestedOneWithoutStore_ReviewInput = {
    create?: XOR<StoreCreateWithoutStore_ReviewInput, StoreUncheckedCreateWithoutStore_ReviewInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_ReviewInput
    connect?: StoreWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutStore_ReviewInput = {
    create?: XOR<CustomerCreateWithoutStore_ReviewInput, CustomerUncheckedCreateWithoutStore_ReviewInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutStore_ReviewInput
    connect?: CustomerWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StoreUpdateOneRequiredWithoutStore_ReviewNestedInput = {
    create?: XOR<StoreCreateWithoutStore_ReviewInput, StoreUncheckedCreateWithoutStore_ReviewInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_ReviewInput
    upsert?: StoreUpsertWithoutStore_ReviewInput
    connect?: StoreWhereUniqueInput
    update?: XOR<StoreUpdateWithoutStore_ReviewInput, StoreUncheckedUpdateWithoutStore_ReviewInput>
  }

  export type CustomerUpdateOneRequiredWithoutStore_ReviewNestedInput = {
    create?: XOR<CustomerCreateWithoutStore_ReviewInput, CustomerUncheckedCreateWithoutStore_ReviewInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutStore_ReviewInput
    upsert?: CustomerUpsertWithoutStore_ReviewInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutStore_ReviewInput, CustomerUncheckedUpdateWithoutStore_ReviewInput>
  }

  export type CustomerCreateNestedOneWithoutAlim_CustomerInput = {
    create?: XOR<CustomerCreateWithoutAlim_CustomerInput, CustomerUncheckedCreateWithoutAlim_CustomerInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAlim_CustomerInput
    connect?: CustomerWhereUniqueInput
  }

  export type Alim_RequestCreateNestedOneWithoutAlim_CustomerInput = {
    create?: XOR<Alim_RequestCreateWithoutAlim_CustomerInput, Alim_RequestUncheckedCreateWithoutAlim_CustomerInput>
    connectOrCreate?: Alim_RequestCreateOrConnectWithoutAlim_CustomerInput
    connect?: Alim_RequestWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutAlim_CustomerNestedInput = {
    create?: XOR<CustomerCreateWithoutAlim_CustomerInput, CustomerUncheckedCreateWithoutAlim_CustomerInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAlim_CustomerInput
    upsert?: CustomerUpsertWithoutAlim_CustomerInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutAlim_CustomerInput, CustomerUncheckedUpdateWithoutAlim_CustomerInput>
  }

  export type Alim_RequestUpdateOneRequiredWithoutAlim_CustomerNestedInput = {
    create?: XOR<Alim_RequestCreateWithoutAlim_CustomerInput, Alim_RequestUncheckedCreateWithoutAlim_CustomerInput>
    connectOrCreate?: Alim_RequestCreateOrConnectWithoutAlim_CustomerInput
    upsert?: Alim_RequestUpsertWithoutAlim_CustomerInput
    connect?: Alim_RequestWhereUniqueInput
    update?: XOR<Alim_RequestUpdateWithoutAlim_CustomerInput, Alim_RequestUncheckedUpdateWithoutAlim_CustomerInput>
  }

  export type Alim_CustomerCreateNestedManyWithoutAlim_RequestInput = {
    create?: XOR<Enumerable<Alim_CustomerCreateWithoutAlim_RequestInput>, Enumerable<Alim_CustomerUncheckedCreateWithoutAlim_RequestInput>>
    connectOrCreate?: Enumerable<Alim_CustomerCreateOrConnectWithoutAlim_RequestInput>
    createMany?: Alim_CustomerCreateManyAlim_RequestInputEnvelope
    connect?: Enumerable<Alim_CustomerWhereUniqueInput>
  }

  export type Store_OwnerCreateNestedOneWithoutAlim_RequestInput = {
    create?: XOR<Store_OwnerCreateWithoutAlim_RequestInput, Store_OwnerUncheckedCreateWithoutAlim_RequestInput>
    connectOrCreate?: Store_OwnerCreateOrConnectWithoutAlim_RequestInput
    connect?: Store_OwnerWhereUniqueInput
  }

  export type Alim_CustomerUncheckedCreateNestedManyWithoutAlim_RequestInput = {
    create?: XOR<Enumerable<Alim_CustomerCreateWithoutAlim_RequestInput>, Enumerable<Alim_CustomerUncheckedCreateWithoutAlim_RequestInput>>
    connectOrCreate?: Enumerable<Alim_CustomerCreateOrConnectWithoutAlim_RequestInput>
    createMany?: Alim_CustomerCreateManyAlim_RequestInputEnvelope
    connect?: Enumerable<Alim_CustomerWhereUniqueInput>
  }

  export type Alim_CustomerUpdateManyWithoutAlim_RequestNestedInput = {
    create?: XOR<Enumerable<Alim_CustomerCreateWithoutAlim_RequestInput>, Enumerable<Alim_CustomerUncheckedCreateWithoutAlim_RequestInput>>
    connectOrCreate?: Enumerable<Alim_CustomerCreateOrConnectWithoutAlim_RequestInput>
    upsert?: Enumerable<Alim_CustomerUpsertWithWhereUniqueWithoutAlim_RequestInput>
    createMany?: Alim_CustomerCreateManyAlim_RequestInputEnvelope
    set?: Enumerable<Alim_CustomerWhereUniqueInput>
    disconnect?: Enumerable<Alim_CustomerWhereUniqueInput>
    delete?: Enumerable<Alim_CustomerWhereUniqueInput>
    connect?: Enumerable<Alim_CustomerWhereUniqueInput>
    update?: Enumerable<Alim_CustomerUpdateWithWhereUniqueWithoutAlim_RequestInput>
    updateMany?: Enumerable<Alim_CustomerUpdateManyWithWhereWithoutAlim_RequestInput>
    deleteMany?: Enumerable<Alim_CustomerScalarWhereInput>
  }

  export type Store_OwnerUpdateOneRequiredWithoutAlim_RequestNestedInput = {
    create?: XOR<Store_OwnerCreateWithoutAlim_RequestInput, Store_OwnerUncheckedCreateWithoutAlim_RequestInput>
    connectOrCreate?: Store_OwnerCreateOrConnectWithoutAlim_RequestInput
    upsert?: Store_OwnerUpsertWithoutAlim_RequestInput
    connect?: Store_OwnerWhereUniqueInput
    update?: XOR<Store_OwnerUpdateWithoutAlim_RequestInput, Store_OwnerUncheckedUpdateWithoutAlim_RequestInput>
  }

  export type Alim_CustomerUncheckedUpdateManyWithoutAlim_RequestNestedInput = {
    create?: XOR<Enumerable<Alim_CustomerCreateWithoutAlim_RequestInput>, Enumerable<Alim_CustomerUncheckedCreateWithoutAlim_RequestInput>>
    connectOrCreate?: Enumerable<Alim_CustomerCreateOrConnectWithoutAlim_RequestInput>
    upsert?: Enumerable<Alim_CustomerUpsertWithWhereUniqueWithoutAlim_RequestInput>
    createMany?: Alim_CustomerCreateManyAlim_RequestInputEnvelope
    set?: Enumerable<Alim_CustomerWhereUniqueInput>
    disconnect?: Enumerable<Alim_CustomerWhereUniqueInput>
    delete?: Enumerable<Alim_CustomerWhereUniqueInput>
    connect?: Enumerable<Alim_CustomerWhereUniqueInput>
    update?: Enumerable<Alim_CustomerUpdateWithWhereUniqueWithoutAlim_RequestInput>
    updateMany?: Enumerable<Alim_CustomerUpdateManyWithWhereWithoutAlim_RequestInput>
    deleteMany?: Enumerable<Alim_CustomerScalarWhereInput>
  }

  export type Store_OwnerCreateNestedOneWithoutStamp_RequestInput = {
    create?: XOR<Store_OwnerCreateWithoutStamp_RequestInput, Store_OwnerUncheckedCreateWithoutStamp_RequestInput>
    connectOrCreate?: Store_OwnerCreateOrConnectWithoutStamp_RequestInput
    connect?: Store_OwnerWhereUniqueInput
  }

  export type Store_OwnerUpdateOneRequiredWithoutStamp_RequestNestedInput = {
    create?: XOR<Store_OwnerCreateWithoutStamp_RequestInput, Store_OwnerUncheckedCreateWithoutStamp_RequestInput>
    connectOrCreate?: Store_OwnerCreateOrConnectWithoutStamp_RequestInput
    upsert?: Store_OwnerUpsertWithoutStamp_RequestInput
    connect?: Store_OwnerWhereUniqueInput
    update?: XOR<Store_OwnerUpdateWithoutStamp_RequestInput, Store_OwnerUncheckedUpdateWithoutStamp_RequestInput>
  }

  export type CustomerCreateNestedOneWithoutStore_LikeInput = {
    create?: XOR<CustomerCreateWithoutStore_LikeInput, CustomerUncheckedCreateWithoutStore_LikeInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutStore_LikeInput
    connect?: CustomerWhereUniqueInput
  }

  export type StoreCreateNestedOneWithoutStore_LikeInput = {
    create?: XOR<StoreCreateWithoutStore_LikeInput, StoreUncheckedCreateWithoutStore_LikeInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_LikeInput
    connect?: StoreWhereUniqueInput
  }

  export type CustomerUpdateOneRequiredWithoutStore_LikeNestedInput = {
    create?: XOR<CustomerCreateWithoutStore_LikeInput, CustomerUncheckedCreateWithoutStore_LikeInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutStore_LikeInput
    upsert?: CustomerUpsertWithoutStore_LikeInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<CustomerUpdateWithoutStore_LikeInput, CustomerUncheckedUpdateWithoutStore_LikeInput>
  }

  export type StoreUpdateOneRequiredWithoutStore_LikeNestedInput = {
    create?: XOR<StoreCreateWithoutStore_LikeInput, StoreUncheckedCreateWithoutStore_LikeInput>
    connectOrCreate?: StoreCreateOrConnectWithoutStore_LikeInput
    upsert?: StoreUpsertWithoutStore_LikeInput
    connect?: StoreWhereUniqueInput
    update?: XOR<StoreUpdateWithoutStore_LikeInput, StoreUncheckedUpdateWithoutStore_LikeInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type Alim_CustomerCreateWithoutCustomerInput = {
    loginId: string
    name?: string | null
    phone: string
    Alim_Request: Alim_RequestCreateNestedOneWithoutAlim_CustomerInput
  }

  export type Alim_CustomerUncheckedCreateWithoutCustomerInput = {
    id?: number
    loginId: string
    name?: string | null
    phone: string
    requestId: number
  }

  export type Alim_CustomerCreateOrConnectWithoutCustomerInput = {
    where: Alim_CustomerWhereUniqueInput
    create: XOR<Alim_CustomerCreateWithoutCustomerInput, Alim_CustomerUncheckedCreateWithoutCustomerInput>
  }

  export type Alim_CustomerCreateManyCustomerInputEnvelope = {
    data: Enumerable<Alim_CustomerCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type StoreCreateWithoutCustomerInput = {
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    x?: string | null
    y?: string | null
    Stamp?: StampCreateNestedManyWithoutStoreInput
    Store_Owner_Store_ownerIdToStore_Owner: Store_OwnerCreateNestedOneWithoutStore_Store_ownerIdToStore_OwnerInput
    Tour?: TourCreateNestedOneWithoutStoreInput
    Store_Like?: Store_LikeCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutCustomerInput = {
    id?: number
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    ownerId: number
    tourId?: number | null
    x?: string | null
    y?: string | null
    Stamp?: StampUncheckedCreateNestedManyWithoutStoreInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuUncheckedCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeUncheckedCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductUncheckedCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewUncheckedCreateNestedOneWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutCustomerInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutCustomerInput, StoreUncheckedCreateWithoutCustomerInput>
  }

  export type DeliveryCreateWithoutCustomerInput = {
    reward: string
    customer: string
    phone: string
    address: string
    detailAddress?: string | null
    message: string
    isGrant?: boolean | null
  }

  export type DeliveryUncheckedCreateWithoutCustomerInput = {
    id?: number
    reward: string
    customer: string
    phone: string
    address: string
    detailAddress?: string | null
    message: string
    isGrant?: boolean | null
  }

  export type DeliveryCreateOrConnectWithoutCustomerInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutCustomerInput, DeliveryUncheckedCreateWithoutCustomerInput>
  }

  export type DeliveryCreateManyCustomerInputEnvelope = {
    data: Enumerable<DeliveryCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type StampCreateWithoutCustomerInput = {
    randNum?: string | null
    timestamp?: Date | string | null
    store?: string | null
    tour?: string | null
    Store?: StoreCreateNestedOneWithoutStampInput
    Tour?: TourCreateNestedOneWithoutStampInput
  }

  export type StampUncheckedCreateWithoutCustomerInput = {
    id?: number
    randNum?: string | null
    timestamp?: Date | string | null
    storeId?: number | null
    store?: string | null
    tourId?: number | null
    tour?: string | null
  }

  export type StampCreateOrConnectWithoutCustomerInput = {
    where: StampWhereUniqueInput
    create: XOR<StampCreateWithoutCustomerInput, StampUncheckedCreateWithoutCustomerInput>
  }

  export type StampCreateManyCustomerInputEnvelope = {
    data: Enumerable<StampCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type Store_LikeCreateWithoutCustomerInput = {
    Store: StoreCreateNestedOneWithoutStore_LikeInput
  }

  export type Store_LikeUncheckedCreateWithoutCustomerInput = {
    id?: number
    storeId: number
  }

  export type Store_LikeCreateOrConnectWithoutCustomerInput = {
    where: Store_LikeWhereUniqueInput
    create: XOR<Store_LikeCreateWithoutCustomerInput, Store_LikeUncheckedCreateWithoutCustomerInput>
  }

  export type Store_LikeCreateManyCustomerInputEnvelope = {
    data: Enumerable<Store_LikeCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type Store_ReviewCreateWithoutCustomerInput = {
    id?: number
    title?: string | null
    content: string
    image?: string | null
    timestamp: Date | string
    writerName: string
    Store: StoreCreateNestedOneWithoutStore_ReviewInput
  }

  export type Store_ReviewUncheckedCreateWithoutCustomerInput = {
    id?: number
    title?: string | null
    content: string
    image?: string | null
    timestamp: Date | string
    storeId: number
    writerName: string
  }

  export type Store_ReviewCreateOrConnectWithoutCustomerInput = {
    where: Store_ReviewWhereUniqueInput
    create: XOR<Store_ReviewCreateWithoutCustomerInput, Store_ReviewUncheckedCreateWithoutCustomerInput>
  }

  export type Store_ReviewCreateManyCustomerInputEnvelope = {
    data: Enumerable<Store_ReviewCreateManyCustomerInput>
    skipDuplicates?: boolean
  }

  export type Alim_CustomerUpsertWithWhereUniqueWithoutCustomerInput = {
    where: Alim_CustomerWhereUniqueInput
    update: XOR<Alim_CustomerUpdateWithoutCustomerInput, Alim_CustomerUncheckedUpdateWithoutCustomerInput>
    create: XOR<Alim_CustomerCreateWithoutCustomerInput, Alim_CustomerUncheckedCreateWithoutCustomerInput>
  }

  export type Alim_CustomerUpdateWithWhereUniqueWithoutCustomerInput = {
    where: Alim_CustomerWhereUniqueInput
    data: XOR<Alim_CustomerUpdateWithoutCustomerInput, Alim_CustomerUncheckedUpdateWithoutCustomerInput>
  }

  export type Alim_CustomerUpdateManyWithWhereWithoutCustomerInput = {
    where: Alim_CustomerScalarWhereInput
    data: XOR<Alim_CustomerUpdateManyMutationInput, Alim_CustomerUncheckedUpdateManyWithoutAlim_CustomerInput>
  }

  export type Alim_CustomerScalarWhereInput = {
    AND?: Enumerable<Alim_CustomerScalarWhereInput>
    OR?: Enumerable<Alim_CustomerScalarWhereInput>
    NOT?: Enumerable<Alim_CustomerScalarWhereInput>
    id?: IntFilter | number
    loginId?: StringFilter | string
    name?: StringNullableFilter | string | null
    phone?: StringFilter | string
    customerId?: IntFilter | number
    requestId?: IntFilter | number
  }

  export type StoreUpsertWithoutCustomerInput = {
    update: XOR<StoreUpdateWithoutCustomerInput, StoreUncheckedUpdateWithoutCustomerInput>
    create: XOR<StoreCreateWithoutCustomerInput, StoreUncheckedCreateWithoutCustomerInput>
  }

  export type StoreUpdateWithoutCustomerInput = {
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Stamp?: StampUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_ownerIdToStore_Owner?: Store_OwnerUpdateOneRequiredWithoutStore_Store_ownerIdToStore_OwnerNestedInput
    Tour?: TourUpdateOneWithoutStoreNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUpdateOneWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    ownerId?: IntFieldUpdateOperationsInput | number
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Stamp?: StampUncheckedUpdateManyWithoutStoreNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUncheckedUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUncheckedUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateOneWithoutStoreNestedInput
  }

  export type DeliveryUpsertWithWhereUniqueWithoutCustomerInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutCustomerInput, DeliveryUncheckedUpdateWithoutCustomerInput>
    create: XOR<DeliveryCreateWithoutCustomerInput, DeliveryUncheckedCreateWithoutCustomerInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutCustomerInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutCustomerInput, DeliveryUncheckedUpdateWithoutCustomerInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutCustomerInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutDeliveryInput>
  }

  export type DeliveryScalarWhereInput = {
    AND?: Enumerable<DeliveryScalarWhereInput>
    OR?: Enumerable<DeliveryScalarWhereInput>
    NOT?: Enumerable<DeliveryScalarWhereInput>
    id?: IntFilter | number
    reward?: StringFilter | string
    customer?: StringFilter | string
    phone?: StringFilter | string
    address?: StringFilter | string
    detailAddress?: StringNullableFilter | string | null
    message?: StringFilter | string
    isGrant?: BoolNullableFilter | boolean | null
    customerId?: IntFilter | number
  }

  export type StampUpsertWithWhereUniqueWithoutCustomerInput = {
    where: StampWhereUniqueInput
    update: XOR<StampUpdateWithoutCustomerInput, StampUncheckedUpdateWithoutCustomerInput>
    create: XOR<StampCreateWithoutCustomerInput, StampUncheckedCreateWithoutCustomerInput>
  }

  export type StampUpdateWithWhereUniqueWithoutCustomerInput = {
    where: StampWhereUniqueInput
    data: XOR<StampUpdateWithoutCustomerInput, StampUncheckedUpdateWithoutCustomerInput>
  }

  export type StampUpdateManyWithWhereWithoutCustomerInput = {
    where: StampScalarWhereInput
    data: XOR<StampUpdateManyMutationInput, StampUncheckedUpdateManyWithoutStampInput>
  }

  export type StampScalarWhereInput = {
    AND?: Enumerable<StampScalarWhereInput>
    OR?: Enumerable<StampScalarWhereInput>
    NOT?: Enumerable<StampScalarWhereInput>
    id?: IntFilter | number
    randNum?: StringNullableFilter | string | null
    timestamp?: DateTimeNullableFilter | Date | string | null
    customerId?: IntNullableFilter | number | null
    storeId?: IntNullableFilter | number | null
    store?: StringNullableFilter | string | null
    tourId?: IntNullableFilter | number | null
    tour?: StringNullableFilter | string | null
  }

  export type Store_LikeUpsertWithWhereUniqueWithoutCustomerInput = {
    where: Store_LikeWhereUniqueInput
    update: XOR<Store_LikeUpdateWithoutCustomerInput, Store_LikeUncheckedUpdateWithoutCustomerInput>
    create: XOR<Store_LikeCreateWithoutCustomerInput, Store_LikeUncheckedCreateWithoutCustomerInput>
  }

  export type Store_LikeUpdateWithWhereUniqueWithoutCustomerInput = {
    where: Store_LikeWhereUniqueInput
    data: XOR<Store_LikeUpdateWithoutCustomerInput, Store_LikeUncheckedUpdateWithoutCustomerInput>
  }

  export type Store_LikeUpdateManyWithWhereWithoutCustomerInput = {
    where: Store_LikeScalarWhereInput
    data: XOR<Store_LikeUpdateManyMutationInput, Store_LikeUncheckedUpdateManyWithoutStore_LikeInput>
  }

  export type Store_LikeScalarWhereInput = {
    AND?: Enumerable<Store_LikeScalarWhereInput>
    OR?: Enumerable<Store_LikeScalarWhereInput>
    NOT?: Enumerable<Store_LikeScalarWhereInput>
    id?: IntFilter | number
    customerId?: IntFilter | number
    storeId?: IntFilter | number
  }

  export type Store_ReviewUpsertWithWhereUniqueWithoutCustomerInput = {
    where: Store_ReviewWhereUniqueInput
    update: XOR<Store_ReviewUpdateWithoutCustomerInput, Store_ReviewUncheckedUpdateWithoutCustomerInput>
    create: XOR<Store_ReviewCreateWithoutCustomerInput, Store_ReviewUncheckedCreateWithoutCustomerInput>
  }

  export type Store_ReviewUpdateWithWhereUniqueWithoutCustomerInput = {
    where: Store_ReviewWhereUniqueInput
    data: XOR<Store_ReviewUpdateWithoutCustomerInput, Store_ReviewUncheckedUpdateWithoutCustomerInput>
  }

  export type Store_ReviewUpdateManyWithWhereWithoutCustomerInput = {
    where: Store_ReviewScalarWhereInput
    data: XOR<Store_ReviewUpdateManyMutationInput, Store_ReviewUncheckedUpdateManyWithoutStore_ReviewInput>
  }

  export type Store_ReviewScalarWhereInput = {
    AND?: Enumerable<Store_ReviewScalarWhereInput>
    OR?: Enumerable<Store_ReviewScalarWhereInput>
    NOT?: Enumerable<Store_ReviewScalarWhereInput>
    id?: IntFilter | number
    title?: StringNullableFilter | string | null
    content?: StringFilter | string
    image?: StringNullableFilter | string | null
    timestamp?: DateTimeFilter | Date | string
    writerId?: IntFilter | number
    storeId?: IntFilter | number
    writerName?: StringFilter | string
  }

  export type CustomerCreateWithoutDeliveryInput = {
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    image?: string | null
    stampCount?: number
    couponCount?: number
    Alim_Customer?: Alim_CustomerCreateNestedManyWithoutCustomerInput
    Store?: StoreCreateNestedOneWithoutCustomerInput
    Stamp?: StampCreateNestedManyWithoutCustomerInput
    Store_Like?: Store_LikeCreateNestedManyWithoutCustomerInput
    Store_Review?: Store_ReviewCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutDeliveryInput = {
    id?: number
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    storeId?: number | null
    image?: string | null
    stampCount?: number
    couponCount?: number
    Alim_Customer?: Alim_CustomerUncheckedCreateNestedManyWithoutCustomerInput
    Stamp?: StampUncheckedCreateNestedManyWithoutCustomerInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutCustomerInput
    Store_Review?: Store_ReviewUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutDeliveryInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutDeliveryInput, CustomerUncheckedCreateWithoutDeliveryInput>
  }

  export type CustomerUpsertWithoutDeliveryInput = {
    update: XOR<CustomerUpdateWithoutDeliveryInput, CustomerUncheckedUpdateWithoutDeliveryInput>
    create: XOR<CustomerCreateWithoutDeliveryInput, CustomerUncheckedCreateWithoutDeliveryInput>
  }

  export type CustomerUpdateWithoutDeliveryInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
    Alim_Customer?: Alim_CustomerUpdateManyWithoutCustomerNestedInput
    Store?: StoreUpdateOneWithoutCustomerNestedInput
    Stamp?: StampUpdateManyWithoutCustomerNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutCustomerNestedInput
    Store_Review?: Store_ReviewUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
    Alim_Customer?: Alim_CustomerUncheckedUpdateManyWithoutCustomerNestedInput
    Stamp?: StampUncheckedUpdateManyWithoutCustomerNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutCustomerNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutStampInput = {
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    image?: string | null
    stampCount?: number
    couponCount?: number
    Alim_Customer?: Alim_CustomerCreateNestedManyWithoutCustomerInput
    Store?: StoreCreateNestedOneWithoutCustomerInput
    Delivery?: DeliveryCreateNestedManyWithoutCustomerInput
    Store_Like?: Store_LikeCreateNestedManyWithoutCustomerInput
    Store_Review?: Store_ReviewCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutStampInput = {
    id?: number
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    storeId?: number | null
    image?: string | null
    stampCount?: number
    couponCount?: number
    Alim_Customer?: Alim_CustomerUncheckedCreateNestedManyWithoutCustomerInput
    Delivery?: DeliveryUncheckedCreateNestedManyWithoutCustomerInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutCustomerInput
    Store_Review?: Store_ReviewUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutStampInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutStampInput, CustomerUncheckedCreateWithoutStampInput>
  }

  export type StoreCreateWithoutStampInput = {
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    x?: string | null
    y?: string | null
    Customer?: CustomerCreateNestedManyWithoutStoreInput
    Store_Owner_Store_ownerIdToStore_Owner: Store_OwnerCreateNestedOneWithoutStore_Store_ownerIdToStore_OwnerInput
    Tour?: TourCreateNestedOneWithoutStoreInput
    Store_Like?: Store_LikeCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutStampInput = {
    id?: number
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    ownerId: number
    tourId?: number | null
    x?: string | null
    y?: string | null
    Customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuUncheckedCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeUncheckedCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductUncheckedCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewUncheckedCreateNestedOneWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutStampInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStampInput, StoreUncheckedCreateWithoutStampInput>
  }

  export type TourCreateWithoutStampInput = {
    keyword: string
    title: string
    reward: string
    image?: string | null
    cafeList?: TourCreatecafeListInput | Enumerable<string>
    Store?: StoreCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateWithoutStampInput = {
    id?: number
    keyword: string
    title: string
    reward: string
    image?: string | null
    cafeList?: TourCreatecafeListInput | Enumerable<string>
    Store?: StoreUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourCreateOrConnectWithoutStampInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutStampInput, TourUncheckedCreateWithoutStampInput>
  }

  export type CustomerUpsertWithoutStampInput = {
    update: XOR<CustomerUpdateWithoutStampInput, CustomerUncheckedUpdateWithoutStampInput>
    create: XOR<CustomerCreateWithoutStampInput, CustomerUncheckedCreateWithoutStampInput>
  }

  export type CustomerUpdateWithoutStampInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
    Alim_Customer?: Alim_CustomerUpdateManyWithoutCustomerNestedInput
    Store?: StoreUpdateOneWithoutCustomerNestedInput
    Delivery?: DeliveryUpdateManyWithoutCustomerNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutCustomerNestedInput
    Store_Review?: Store_ReviewUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutStampInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
    Alim_Customer?: Alim_CustomerUncheckedUpdateManyWithoutCustomerNestedInput
    Delivery?: DeliveryUncheckedUpdateManyWithoutCustomerNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutCustomerNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type StoreUpsertWithoutStampInput = {
    update: XOR<StoreUpdateWithoutStampInput, StoreUncheckedUpdateWithoutStampInput>
    create: XOR<StoreCreateWithoutStampInput, StoreUncheckedCreateWithoutStampInput>
  }

  export type StoreUpdateWithoutStampInput = {
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_ownerIdToStore_Owner?: Store_OwnerUpdateOneRequiredWithoutStore_Store_ownerIdToStore_OwnerNestedInput
    Tour?: TourUpdateOneWithoutStoreNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUpdateOneWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutStampInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    ownerId?: IntFieldUpdateOperationsInput | number
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUncheckedUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUncheckedUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateOneWithoutStoreNestedInput
  }

  export type TourUpsertWithoutStampInput = {
    update: XOR<TourUpdateWithoutStampInput, TourUncheckedUpdateWithoutStampInput>
    create: XOR<TourCreateWithoutStampInput, TourUncheckedCreateWithoutStampInput>
  }

  export type TourUpdateWithoutStampInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cafeList?: TourUpdatecafeListInput | Enumerable<string>
    Store?: StoreUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateWithoutStampInput = {
    id?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cafeList?: TourUpdatecafeListInput | Enumerable<string>
    Store?: StoreUncheckedUpdateManyWithoutTourNestedInput
  }

  export type CustomerCreateWithoutStoreInput = {
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    image?: string | null
    stampCount?: number
    couponCount?: number
    Alim_Customer?: Alim_CustomerCreateNestedManyWithoutCustomerInput
    Delivery?: DeliveryCreateNestedManyWithoutCustomerInput
    Stamp?: StampCreateNestedManyWithoutCustomerInput
    Store_Like?: Store_LikeCreateNestedManyWithoutCustomerInput
    Store_Review?: Store_ReviewCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutStoreInput = {
    id?: number
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    image?: string | null
    stampCount?: number
    couponCount?: number
    Alim_Customer?: Alim_CustomerUncheckedCreateNestedManyWithoutCustomerInput
    Delivery?: DeliveryUncheckedCreateNestedManyWithoutCustomerInput
    Stamp?: StampUncheckedCreateNestedManyWithoutCustomerInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutCustomerInput
    Store_Review?: Store_ReviewUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutStoreInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutStoreInput, CustomerUncheckedCreateWithoutStoreInput>
  }

  export type CustomerCreateManyStoreInputEnvelope = {
    data: Enumerable<CustomerCreateManyStoreInput>
    skipDuplicates?: boolean
  }

  export type StampCreateWithoutStoreInput = {
    randNum?: string | null
    timestamp?: Date | string | null
    store?: string | null
    tour?: string | null
    Customer?: CustomerCreateNestedOneWithoutStampInput
    Tour?: TourCreateNestedOneWithoutStampInput
  }

  export type StampUncheckedCreateWithoutStoreInput = {
    id?: number
    randNum?: string | null
    timestamp?: Date | string | null
    customerId?: number | null
    store?: string | null
    tourId?: number | null
    tour?: string | null
  }

  export type StampCreateOrConnectWithoutStoreInput = {
    where: StampWhereUniqueInput
    create: XOR<StampCreateWithoutStoreInput, StampUncheckedCreateWithoutStoreInput>
  }

  export type StampCreateManyStoreInputEnvelope = {
    data: Enumerable<StampCreateManyStoreInput>
    skipDuplicates?: boolean
  }

  export type Store_OwnerCreateWithoutStore_Store_ownerIdToStore_OwnerInput = {
    loginId: string
    password?: string | null
    store?: string | null
    director?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    detailAddress?: string | null
    licenseNumber?: string | null
    licenseImage: string
    authorized?: boolean | null
    termsAgree?: boolean | null
    marketingAgree?: boolean | null
    stampAuthorized?: boolean | null
    profileImage?: string | null
    Alim_Request?: Alim_RequestCreateNestedManyWithoutStore_OwnerInput
    Stamp_Request?: Stamp_RequestCreateNestedOneWithoutStore_OwnerInput
    Store_Store_Owner_storeIdToStore?: StoreCreateNestedOneWithoutStore_Owner_Store_Owner_storeIdToStoreInput
  }

  export type Store_OwnerUncheckedCreateWithoutStore_Store_ownerIdToStore_OwnerInput = {
    id?: number
    loginId: string
    password?: string | null
    store?: string | null
    director?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    detailAddress?: string | null
    licenseNumber?: string | null
    licenseImage: string
    authorized?: boolean | null
    termsAgree?: boolean | null
    marketingAgree?: boolean | null
    storeId?: number | null
    stampAuthorized?: boolean | null
    profileImage?: string | null
    Alim_Request?: Alim_RequestUncheckedCreateNestedManyWithoutStore_OwnerInput
    Stamp_Request?: Stamp_RequestUncheckedCreateNestedOneWithoutStore_OwnerInput
  }

  export type Store_OwnerCreateOrConnectWithoutStore_Store_ownerIdToStore_OwnerInput = {
    where: Store_OwnerWhereUniqueInput
    create: XOR<Store_OwnerCreateWithoutStore_Store_ownerIdToStore_OwnerInput, Store_OwnerUncheckedCreateWithoutStore_Store_ownerIdToStore_OwnerInput>
  }

  export type TourCreateWithoutStoreInput = {
    keyword: string
    title: string
    reward: string
    image?: string | null
    cafeList?: TourCreatecafeListInput | Enumerable<string>
    Stamp?: StampCreateNestedManyWithoutTourInput
  }

  export type TourUncheckedCreateWithoutStoreInput = {
    id?: number
    keyword: string
    title: string
    reward: string
    image?: string | null
    cafeList?: TourCreatecafeListInput | Enumerable<string>
    Stamp?: StampUncheckedCreateNestedManyWithoutTourInput
  }

  export type TourCreateOrConnectWithoutStoreInput = {
    where: TourWhereUniqueInput
    create: XOR<TourCreateWithoutStoreInput, TourUncheckedCreateWithoutStoreInput>
  }

  export type Store_LikeCreateWithoutStoreInput = {
    Customer: CustomerCreateNestedOneWithoutStore_LikeInput
  }

  export type Store_LikeUncheckedCreateWithoutStoreInput = {
    id?: number
    customerId: number
  }

  export type Store_LikeCreateOrConnectWithoutStoreInput = {
    where: Store_LikeWhereUniqueInput
    create: XOR<Store_LikeCreateWithoutStoreInput, Store_LikeUncheckedCreateWithoutStoreInput>
  }

  export type Store_LikeCreateManyStoreInputEnvelope = {
    data: Enumerable<Store_LikeCreateManyStoreInput>
    skipDuplicates?: boolean
  }

  export type Store_MenuCreateWithoutStoreInput = {
    title?: string | null
    content?: string | null
    image?: string | null
  }

  export type Store_MenuUncheckedCreateWithoutStoreInput = {
    id?: number
    title?: string | null
    content?: string | null
    image?: string | null
  }

  export type Store_MenuCreateOrConnectWithoutStoreInput = {
    where: Store_MenuWhereUniqueInput
    create: XOR<Store_MenuCreateWithoutStoreInput, Store_MenuUncheckedCreateWithoutStoreInput>
  }

  export type Store_MenuCreateManyStoreInputEnvelope = {
    data: Enumerable<Store_MenuCreateManyStoreInput>
    skipDuplicates?: boolean
  }

  export type Store_NoticeCreateWithoutStoreInput = {
    category?: string | null
    title?: string | null
    content?: string | null
    image?: string | null
    createdTime?: Date | string | null
  }

  export type Store_NoticeUncheckedCreateWithoutStoreInput = {
    id?: number
    category?: string | null
    title?: string | null
    content?: string | null
    image?: string | null
    createdTime?: Date | string | null
  }

  export type Store_NoticeCreateOrConnectWithoutStoreInput = {
    where: Store_NoticeWhereUniqueInput
    create: XOR<Store_NoticeCreateWithoutStoreInput, Store_NoticeUncheckedCreateWithoutStoreInput>
  }

  export type Store_NoticeCreateManyStoreInputEnvelope = {
    data: Enumerable<Store_NoticeCreateManyStoreInput>
    skipDuplicates?: boolean
  }

  export type Store_OwnerCreateWithoutStore_Store_Owner_storeIdToStoreInput = {
    loginId: string
    password?: string | null
    store?: string | null
    director?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    detailAddress?: string | null
    licenseNumber?: string | null
    licenseImage: string
    authorized?: boolean | null
    termsAgree?: boolean | null
    marketingAgree?: boolean | null
    stampAuthorized?: boolean | null
    profileImage?: string | null
    Alim_Request?: Alim_RequestCreateNestedManyWithoutStore_OwnerInput
    Stamp_Request?: Stamp_RequestCreateNestedOneWithoutStore_OwnerInput
    Store_Store_ownerIdToStore_Owner?: StoreCreateNestedOneWithoutStore_Owner_Store_ownerIdToStore_OwnerInput
  }

  export type Store_OwnerUncheckedCreateWithoutStore_Store_Owner_storeIdToStoreInput = {
    id?: number
    loginId: string
    password?: string | null
    store?: string | null
    director?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    detailAddress?: string | null
    licenseNumber?: string | null
    licenseImage: string
    authorized?: boolean | null
    termsAgree?: boolean | null
    marketingAgree?: boolean | null
    stampAuthorized?: boolean | null
    profileImage?: string | null
    Alim_Request?: Alim_RequestUncheckedCreateNestedManyWithoutStore_OwnerInput
    Stamp_Request?: Stamp_RequestUncheckedCreateNestedOneWithoutStore_OwnerInput
    Store_Store_ownerIdToStore_Owner?: StoreUncheckedCreateNestedOneWithoutStore_Owner_Store_ownerIdToStore_OwnerInput
  }

  export type Store_OwnerCreateOrConnectWithoutStore_Store_Owner_storeIdToStoreInput = {
    where: Store_OwnerWhereUniqueInput
    create: XOR<Store_OwnerCreateWithoutStore_Store_Owner_storeIdToStoreInput, Store_OwnerUncheckedCreateWithoutStore_Store_Owner_storeIdToStoreInput>
  }

  export type Store_ProductCreateWithoutStoreInput = {
    category?: string | null
    name?: string | null
    price?: string | null
    discountPrice?: string | null
    url?: string | null
    image?: string | null
  }

  export type Store_ProductUncheckedCreateWithoutStoreInput = {
    id?: number
    category?: string | null
    name?: string | null
    price?: string | null
    discountPrice?: string | null
    url?: string | null
    image?: string | null
  }

  export type Store_ProductCreateOrConnectWithoutStoreInput = {
    where: Store_ProductWhereUniqueInput
    create: XOR<Store_ProductCreateWithoutStoreInput, Store_ProductUncheckedCreateWithoutStoreInput>
  }

  export type Store_ProductCreateManyStoreInputEnvelope = {
    data: Enumerable<Store_ProductCreateManyStoreInput>
    skipDuplicates?: boolean
  }

  export type Store_ReviewCreateWithoutStoreInput = {
    id?: number
    title?: string | null
    content: string
    image?: string | null
    timestamp: Date | string
    writerName: string
    Customer: CustomerCreateNestedOneWithoutStore_ReviewInput
  }

  export type Store_ReviewUncheckedCreateWithoutStoreInput = {
    id?: number
    title?: string | null
    content: string
    image?: string | null
    timestamp: Date | string
    writerId: number
    writerName: string
  }

  export type Store_ReviewCreateOrConnectWithoutStoreInput = {
    where: Store_ReviewWhereUniqueInput
    create: XOR<Store_ReviewCreateWithoutStoreInput, Store_ReviewUncheckedCreateWithoutStoreInput>
  }

  export type CustomerUpsertWithWhereUniqueWithoutStoreInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutStoreInput, CustomerUncheckedUpdateWithoutStoreInput>
    create: XOR<CustomerCreateWithoutStoreInput, CustomerUncheckedCreateWithoutStoreInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutStoreInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutStoreInput, CustomerUncheckedUpdateWithoutStoreInput>
  }

  export type CustomerUpdateManyWithWhereWithoutStoreInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: Enumerable<CustomerScalarWhereInput>
    OR?: Enumerable<CustomerScalarWhereInput>
    NOT?: Enumerable<CustomerScalarWhereInput>
    id?: IntFilter | number
    loginId?: StringFilter | string
    password?: StringFilter | string
    name?: StringFilter | string
    email?: StringFilter | string
    phone?: StringFilter | string
    termsAgree?: BoolFilter | boolean
    marketingAgree?: BoolNullableFilter | boolean | null
    storeId?: IntNullableFilter | number | null
    image?: StringNullableFilter | string | null
    stampCount?: IntFilter | number
    couponCount?: IntFilter | number
  }

  export type StampUpsertWithWhereUniqueWithoutStoreInput = {
    where: StampWhereUniqueInput
    update: XOR<StampUpdateWithoutStoreInput, StampUncheckedUpdateWithoutStoreInput>
    create: XOR<StampCreateWithoutStoreInput, StampUncheckedCreateWithoutStoreInput>
  }

  export type StampUpdateWithWhereUniqueWithoutStoreInput = {
    where: StampWhereUniqueInput
    data: XOR<StampUpdateWithoutStoreInput, StampUncheckedUpdateWithoutStoreInput>
  }

  export type StampUpdateManyWithWhereWithoutStoreInput = {
    where: StampScalarWhereInput
    data: XOR<StampUpdateManyMutationInput, StampUncheckedUpdateManyWithoutStampInput>
  }

  export type Store_OwnerUpsertWithoutStore_Store_ownerIdToStore_OwnerInput = {
    update: XOR<Store_OwnerUpdateWithoutStore_Store_ownerIdToStore_OwnerInput, Store_OwnerUncheckedUpdateWithoutStore_Store_ownerIdToStore_OwnerInput>
    create: XOR<Store_OwnerCreateWithoutStore_Store_ownerIdToStore_OwnerInput, Store_OwnerUncheckedCreateWithoutStore_Store_ownerIdToStore_OwnerInput>
  }

  export type Store_OwnerUpdateWithoutStore_Store_ownerIdToStore_OwnerInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    director?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseImage?: StringFieldUpdateOperationsInput | string
    authorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    termsAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stampAuthorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    Alim_Request?: Alim_RequestUpdateManyWithoutStore_OwnerNestedInput
    Stamp_Request?: Stamp_RequestUpdateOneWithoutStore_OwnerNestedInput
    Store_Store_Owner_storeIdToStore?: StoreUpdateOneWithoutStore_Owner_Store_Owner_storeIdToStoreNestedInput
  }

  export type Store_OwnerUncheckedUpdateWithoutStore_Store_ownerIdToStore_OwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    director?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseImage?: StringFieldUpdateOperationsInput | string
    authorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    termsAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    stampAuthorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    Alim_Request?: Alim_RequestUncheckedUpdateManyWithoutStore_OwnerNestedInput
    Stamp_Request?: Stamp_RequestUncheckedUpdateOneWithoutStore_OwnerNestedInput
  }

  export type TourUpsertWithoutStoreInput = {
    update: XOR<TourUpdateWithoutStoreInput, TourUncheckedUpdateWithoutStoreInput>
    create: XOR<TourCreateWithoutStoreInput, TourUncheckedCreateWithoutStoreInput>
  }

  export type TourUpdateWithoutStoreInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cafeList?: TourUpdatecafeListInput | Enumerable<string>
    Stamp?: StampUpdateManyWithoutTourNestedInput
  }

  export type TourUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    keyword?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    reward?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cafeList?: TourUpdatecafeListInput | Enumerable<string>
    Stamp?: StampUncheckedUpdateManyWithoutTourNestedInput
  }

  export type Store_LikeUpsertWithWhereUniqueWithoutStoreInput = {
    where: Store_LikeWhereUniqueInput
    update: XOR<Store_LikeUpdateWithoutStoreInput, Store_LikeUncheckedUpdateWithoutStoreInput>
    create: XOR<Store_LikeCreateWithoutStoreInput, Store_LikeUncheckedCreateWithoutStoreInput>
  }

  export type Store_LikeUpdateWithWhereUniqueWithoutStoreInput = {
    where: Store_LikeWhereUniqueInput
    data: XOR<Store_LikeUpdateWithoutStoreInput, Store_LikeUncheckedUpdateWithoutStoreInput>
  }

  export type Store_LikeUpdateManyWithWhereWithoutStoreInput = {
    where: Store_LikeScalarWhereInput
    data: XOR<Store_LikeUpdateManyMutationInput, Store_LikeUncheckedUpdateManyWithoutStore_LikeInput>
  }

  export type Store_MenuUpsertWithWhereUniqueWithoutStoreInput = {
    where: Store_MenuWhereUniqueInput
    update: XOR<Store_MenuUpdateWithoutStoreInput, Store_MenuUncheckedUpdateWithoutStoreInput>
    create: XOR<Store_MenuCreateWithoutStoreInput, Store_MenuUncheckedCreateWithoutStoreInput>
  }

  export type Store_MenuUpdateWithWhereUniqueWithoutStoreInput = {
    where: Store_MenuWhereUniqueInput
    data: XOR<Store_MenuUpdateWithoutStoreInput, Store_MenuUncheckedUpdateWithoutStoreInput>
  }

  export type Store_MenuUpdateManyWithWhereWithoutStoreInput = {
    where: Store_MenuScalarWhereInput
    data: XOR<Store_MenuUpdateManyMutationInput, Store_MenuUncheckedUpdateManyWithoutStore_MenuInput>
  }

  export type Store_MenuScalarWhereInput = {
    AND?: Enumerable<Store_MenuScalarWhereInput>
    OR?: Enumerable<Store_MenuScalarWhereInput>
    NOT?: Enumerable<Store_MenuScalarWhereInput>
    id?: IntFilter | number
    title?: StringNullableFilter | string | null
    content?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    storeId?: IntNullableFilter | number | null
  }

  export type Store_NoticeUpsertWithWhereUniqueWithoutStoreInput = {
    where: Store_NoticeWhereUniqueInput
    update: XOR<Store_NoticeUpdateWithoutStoreInput, Store_NoticeUncheckedUpdateWithoutStoreInput>
    create: XOR<Store_NoticeCreateWithoutStoreInput, Store_NoticeUncheckedCreateWithoutStoreInput>
  }

  export type Store_NoticeUpdateWithWhereUniqueWithoutStoreInput = {
    where: Store_NoticeWhereUniqueInput
    data: XOR<Store_NoticeUpdateWithoutStoreInput, Store_NoticeUncheckedUpdateWithoutStoreInput>
  }

  export type Store_NoticeUpdateManyWithWhereWithoutStoreInput = {
    where: Store_NoticeScalarWhereInput
    data: XOR<Store_NoticeUpdateManyMutationInput, Store_NoticeUncheckedUpdateManyWithoutStore_NoticeInput>
  }

  export type Store_NoticeScalarWhereInput = {
    AND?: Enumerable<Store_NoticeScalarWhereInput>
    OR?: Enumerable<Store_NoticeScalarWhereInput>
    NOT?: Enumerable<Store_NoticeScalarWhereInput>
    id?: IntFilter | number
    category?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    content?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    storeId?: IntNullableFilter | number | null
    createdTime?: DateTimeNullableFilter | Date | string | null
  }

  export type Store_OwnerUpsertWithoutStore_Store_Owner_storeIdToStoreInput = {
    update: XOR<Store_OwnerUpdateWithoutStore_Store_Owner_storeIdToStoreInput, Store_OwnerUncheckedUpdateWithoutStore_Store_Owner_storeIdToStoreInput>
    create: XOR<Store_OwnerCreateWithoutStore_Store_Owner_storeIdToStoreInput, Store_OwnerUncheckedCreateWithoutStore_Store_Owner_storeIdToStoreInput>
  }

  export type Store_OwnerUpdateWithoutStore_Store_Owner_storeIdToStoreInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    director?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseImage?: StringFieldUpdateOperationsInput | string
    authorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    termsAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stampAuthorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    Alim_Request?: Alim_RequestUpdateManyWithoutStore_OwnerNestedInput
    Stamp_Request?: Stamp_RequestUpdateOneWithoutStore_OwnerNestedInput
    Store_Store_ownerIdToStore_Owner?: StoreUpdateOneWithoutStore_Owner_Store_ownerIdToStore_OwnerNestedInput
  }

  export type Store_OwnerUncheckedUpdateWithoutStore_Store_Owner_storeIdToStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    director?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseImage?: StringFieldUpdateOperationsInput | string
    authorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    termsAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stampAuthorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    Alim_Request?: Alim_RequestUncheckedUpdateManyWithoutStore_OwnerNestedInput
    Stamp_Request?: Stamp_RequestUncheckedUpdateOneWithoutStore_OwnerNestedInput
    Store_Store_ownerIdToStore_Owner?: StoreUncheckedUpdateOneWithoutStore_Owner_Store_ownerIdToStore_OwnerNestedInput
  }

  export type Store_ProductUpsertWithWhereUniqueWithoutStoreInput = {
    where: Store_ProductWhereUniqueInput
    update: XOR<Store_ProductUpdateWithoutStoreInput, Store_ProductUncheckedUpdateWithoutStoreInput>
    create: XOR<Store_ProductCreateWithoutStoreInput, Store_ProductUncheckedCreateWithoutStoreInput>
  }

  export type Store_ProductUpdateWithWhereUniqueWithoutStoreInput = {
    where: Store_ProductWhereUniqueInput
    data: XOR<Store_ProductUpdateWithoutStoreInput, Store_ProductUncheckedUpdateWithoutStoreInput>
  }

  export type Store_ProductUpdateManyWithWhereWithoutStoreInput = {
    where: Store_ProductScalarWhereInput
    data: XOR<Store_ProductUpdateManyMutationInput, Store_ProductUncheckedUpdateManyWithoutStore_ProductInput>
  }

  export type Store_ProductScalarWhereInput = {
    AND?: Enumerable<Store_ProductScalarWhereInput>
    OR?: Enumerable<Store_ProductScalarWhereInput>
    NOT?: Enumerable<Store_ProductScalarWhereInput>
    id?: IntFilter | number
    category?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    price?: StringNullableFilter | string | null
    discountPrice?: StringNullableFilter | string | null
    url?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    storeId?: IntNullableFilter | number | null
  }

  export type Store_ReviewUpsertWithoutStoreInput = {
    update: XOR<Store_ReviewUpdateWithoutStoreInput, Store_ReviewUncheckedUpdateWithoutStoreInput>
    create: XOR<Store_ReviewCreateWithoutStoreInput, Store_ReviewUncheckedCreateWithoutStoreInput>
  }

  export type Store_ReviewUpdateWithoutStoreInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    writerName?: StringFieldUpdateOperationsInput | string
    Customer?: CustomerUpdateOneRequiredWithoutStore_ReviewNestedInput
  }

  export type Store_ReviewUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    writerId?: IntFieldUpdateOperationsInput | number
    writerName?: StringFieldUpdateOperationsInput | string
  }

  export type StoreCreateWithoutStore_MenuInput = {
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    x?: string | null
    y?: string | null
    Customer?: CustomerCreateNestedManyWithoutStoreInput
    Stamp?: StampCreateNestedManyWithoutStoreInput
    Store_Owner_Store_ownerIdToStore_Owner: Store_OwnerCreateNestedOneWithoutStore_Store_ownerIdToStore_OwnerInput
    Tour?: TourCreateNestedOneWithoutStoreInput
    Store_Like?: Store_LikeCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutStore_MenuInput = {
    id?: number
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    ownerId: number
    tourId?: number | null
    x?: string | null
    y?: string | null
    Customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    Stamp?: StampUncheckedCreateNestedManyWithoutStoreInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeUncheckedCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductUncheckedCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewUncheckedCreateNestedOneWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutStore_MenuInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStore_MenuInput, StoreUncheckedCreateWithoutStore_MenuInput>
  }

  export type StoreUpsertWithoutStore_MenuInput = {
    update: XOR<StoreUpdateWithoutStore_MenuInput, StoreUncheckedUpdateWithoutStore_MenuInput>
    create: XOR<StoreCreateWithoutStore_MenuInput, StoreUncheckedCreateWithoutStore_MenuInput>
  }

  export type StoreUpdateWithoutStore_MenuInput = {
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUpdateManyWithoutStoreNestedInput
    Stamp?: StampUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_ownerIdToStore_Owner?: Store_OwnerUpdateOneRequiredWithoutStore_Store_ownerIdToStore_OwnerNestedInput
    Tour?: TourUpdateOneWithoutStoreNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUpdateOneWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutStore_MenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    ownerId?: IntFieldUpdateOperationsInput | number
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    Stamp?: StampUncheckedUpdateManyWithoutStoreNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUncheckedUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateOneWithoutStoreNestedInput
  }

  export type StoreCreateWithoutStore_NoticeInput = {
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    x?: string | null
    y?: string | null
    Customer?: CustomerCreateNestedManyWithoutStoreInput
    Stamp?: StampCreateNestedManyWithoutStoreInput
    Store_Owner_Store_ownerIdToStore_Owner: Store_OwnerCreateNestedOneWithoutStore_Store_ownerIdToStore_OwnerInput
    Tour?: TourCreateNestedOneWithoutStoreInput
    Store_Like?: Store_LikeCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutStore_NoticeInput = {
    id?: number
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    ownerId: number
    tourId?: number | null
    x?: string | null
    y?: string | null
    Customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    Stamp?: StampUncheckedCreateNestedManyWithoutStoreInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuUncheckedCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductUncheckedCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewUncheckedCreateNestedOneWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutStore_NoticeInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStore_NoticeInput, StoreUncheckedCreateWithoutStore_NoticeInput>
  }

  export type StoreUpsertWithoutStore_NoticeInput = {
    update: XOR<StoreUpdateWithoutStore_NoticeInput, StoreUncheckedUpdateWithoutStore_NoticeInput>
    create: XOR<StoreCreateWithoutStore_NoticeInput, StoreUncheckedCreateWithoutStore_NoticeInput>
  }

  export type StoreUpdateWithoutStore_NoticeInput = {
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUpdateManyWithoutStoreNestedInput
    Stamp?: StampUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_ownerIdToStore_Owner?: Store_OwnerUpdateOneRequiredWithoutStore_Store_ownerIdToStore_OwnerNestedInput
    Tour?: TourUpdateOneWithoutStoreNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUpdateOneWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutStore_NoticeInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    ownerId?: IntFieldUpdateOperationsInput | number
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    Stamp?: StampUncheckedUpdateManyWithoutStoreNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUncheckedUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUncheckedUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateOneWithoutStoreNestedInput
  }

  export type Alim_RequestCreateWithoutStore_OwnerInput = {
    category: string
    content: string
    isMessage: boolean
    isKakao: boolean
    timestamp: Date | string
    Alim_Customer?: Alim_CustomerCreateNestedManyWithoutAlim_RequestInput
  }

  export type Alim_RequestUncheckedCreateWithoutStore_OwnerInput = {
    id?: number
    category: string
    content: string
    isMessage: boolean
    isKakao: boolean
    timestamp: Date | string
    Alim_Customer?: Alim_CustomerUncheckedCreateNestedManyWithoutAlim_RequestInput
  }

  export type Alim_RequestCreateOrConnectWithoutStore_OwnerInput = {
    where: Alim_RequestWhereUniqueInput
    create: XOR<Alim_RequestCreateWithoutStore_OwnerInput, Alim_RequestUncheckedCreateWithoutStore_OwnerInput>
  }

  export type Alim_RequestCreateManyStore_OwnerInputEnvelope = {
    data: Enumerable<Alim_RequestCreateManyStore_OwnerInput>
    skipDuplicates?: boolean
  }

  export type Stamp_RequestCreateWithoutStore_OwnerInput = {
    isGrant?: boolean
  }

  export type Stamp_RequestUncheckedCreateWithoutStore_OwnerInput = {
    id?: number
    isGrant?: boolean
  }

  export type Stamp_RequestCreateOrConnectWithoutStore_OwnerInput = {
    where: Stamp_RequestWhereUniqueInput
    create: XOR<Stamp_RequestCreateWithoutStore_OwnerInput, Stamp_RequestUncheckedCreateWithoutStore_OwnerInput>
  }

  export type StoreCreateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput = {
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    x?: string | null
    y?: string | null
    Customer?: CustomerCreateNestedManyWithoutStoreInput
    Stamp?: StampCreateNestedManyWithoutStoreInput
    Tour?: TourCreateNestedOneWithoutStoreInput
    Store_Like?: Store_LikeCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput = {
    id?: number
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    tourId?: number | null
    x?: string | null
    y?: string | null
    Customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    Stamp?: StampUncheckedCreateNestedManyWithoutStoreInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuUncheckedCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeUncheckedCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductUncheckedCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewUncheckedCreateNestedOneWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutStore_Owner_Store_ownerIdToStore_OwnerInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput, StoreUncheckedCreateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput>
  }

  export type StoreCreateWithoutStore_Owner_Store_Owner_storeIdToStoreInput = {
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    x?: string | null
    y?: string | null
    Customer?: CustomerCreateNestedManyWithoutStoreInput
    Stamp?: StampCreateNestedManyWithoutStoreInput
    Store_Owner_Store_ownerIdToStore_Owner: Store_OwnerCreateNestedOneWithoutStore_Store_ownerIdToStore_OwnerInput
    Tour?: TourCreateNestedOneWithoutStoreInput
    Store_Like?: Store_LikeCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeCreateNestedManyWithoutStoreInput
    Store_Product?: Store_ProductCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutStore_Owner_Store_Owner_storeIdToStoreInput = {
    id?: number
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    ownerId: number
    tourId?: number | null
    x?: string | null
    y?: string | null
    Customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    Stamp?: StampUncheckedCreateNestedManyWithoutStoreInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuUncheckedCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeUncheckedCreateNestedManyWithoutStoreInput
    Store_Product?: Store_ProductUncheckedCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewUncheckedCreateNestedOneWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutStore_Owner_Store_Owner_storeIdToStoreInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStore_Owner_Store_Owner_storeIdToStoreInput, StoreUncheckedCreateWithoutStore_Owner_Store_Owner_storeIdToStoreInput>
  }

  export type Alim_RequestUpsertWithWhereUniqueWithoutStore_OwnerInput = {
    where: Alim_RequestWhereUniqueInput
    update: XOR<Alim_RequestUpdateWithoutStore_OwnerInput, Alim_RequestUncheckedUpdateWithoutStore_OwnerInput>
    create: XOR<Alim_RequestCreateWithoutStore_OwnerInput, Alim_RequestUncheckedCreateWithoutStore_OwnerInput>
  }

  export type Alim_RequestUpdateWithWhereUniqueWithoutStore_OwnerInput = {
    where: Alim_RequestWhereUniqueInput
    data: XOR<Alim_RequestUpdateWithoutStore_OwnerInput, Alim_RequestUncheckedUpdateWithoutStore_OwnerInput>
  }

  export type Alim_RequestUpdateManyWithWhereWithoutStore_OwnerInput = {
    where: Alim_RequestScalarWhereInput
    data: XOR<Alim_RequestUpdateManyMutationInput, Alim_RequestUncheckedUpdateManyWithoutAlim_RequestInput>
  }

  export type Alim_RequestScalarWhereInput = {
    AND?: Enumerable<Alim_RequestScalarWhereInput>
    OR?: Enumerable<Alim_RequestScalarWhereInput>
    NOT?: Enumerable<Alim_RequestScalarWhereInput>
    id?: IntFilter | number
    category?: StringFilter | string
    content?: StringFilter | string
    isMessage?: BoolFilter | boolean
    isKakao?: BoolFilter | boolean
    writerId?: IntFilter | number
    timestamp?: DateTimeFilter | Date | string
  }

  export type Stamp_RequestUpsertWithoutStore_OwnerInput = {
    update: XOR<Stamp_RequestUpdateWithoutStore_OwnerInput, Stamp_RequestUncheckedUpdateWithoutStore_OwnerInput>
    create: XOR<Stamp_RequestCreateWithoutStore_OwnerInput, Stamp_RequestUncheckedCreateWithoutStore_OwnerInput>
  }

  export type Stamp_RequestUpdateWithoutStore_OwnerInput = {
    isGrant?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Stamp_RequestUncheckedUpdateWithoutStore_OwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    isGrant?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StoreUpsertWithoutStore_Owner_Store_ownerIdToStore_OwnerInput = {
    update: XOR<StoreUpdateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput, StoreUncheckedUpdateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput>
    create: XOR<StoreCreateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput, StoreUncheckedCreateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput>
  }

  export type StoreUpdateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput = {
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUpdateManyWithoutStoreNestedInput
    Stamp?: StampUpdateManyWithoutStoreNestedInput
    Tour?: TourUpdateOneWithoutStoreNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUpdateOneWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutStore_Owner_Store_ownerIdToStore_OwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    Stamp?: StampUncheckedUpdateManyWithoutStoreNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUncheckedUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUncheckedUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateOneWithoutStoreNestedInput
  }

  export type StoreUpsertWithoutStore_Owner_Store_Owner_storeIdToStoreInput = {
    update: XOR<StoreUpdateWithoutStore_Owner_Store_Owner_storeIdToStoreInput, StoreUncheckedUpdateWithoutStore_Owner_Store_Owner_storeIdToStoreInput>
    create: XOR<StoreCreateWithoutStore_Owner_Store_Owner_storeIdToStoreInput, StoreUncheckedCreateWithoutStore_Owner_Store_Owner_storeIdToStoreInput>
  }

  export type StoreUpdateWithoutStore_Owner_Store_Owner_storeIdToStoreInput = {
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUpdateManyWithoutStoreNestedInput
    Stamp?: StampUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_ownerIdToStore_Owner?: Store_OwnerUpdateOneRequiredWithoutStore_Store_ownerIdToStore_OwnerNestedInput
    Tour?: TourUpdateOneWithoutStoreNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUpdateManyWithoutStoreNestedInput
    Store_Product?: Store_ProductUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUpdateOneWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutStore_Owner_Store_Owner_storeIdToStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    ownerId?: IntFieldUpdateOperationsInput | number
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    Stamp?: StampUncheckedUpdateManyWithoutStoreNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUncheckedUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Product?: Store_ProductUncheckedUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateOneWithoutStoreNestedInput
  }

  export type StoreCreateWithoutStore_ProductInput = {
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    x?: string | null
    y?: string | null
    Customer?: CustomerCreateNestedManyWithoutStoreInput
    Stamp?: StampCreateNestedManyWithoutStoreInput
    Store_Owner_Store_ownerIdToStore_Owner: Store_OwnerCreateNestedOneWithoutStore_Store_ownerIdToStore_OwnerInput
    Tour?: TourCreateNestedOneWithoutStoreInput
    Store_Like?: Store_LikeCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Review?: Store_ReviewCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutStore_ProductInput = {
    id?: number
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    ownerId: number
    tourId?: number | null
    x?: string | null
    y?: string | null
    Customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    Stamp?: StampUncheckedCreateNestedManyWithoutStoreInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuUncheckedCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeUncheckedCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Review?: Store_ReviewUncheckedCreateNestedOneWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutStore_ProductInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStore_ProductInput, StoreUncheckedCreateWithoutStore_ProductInput>
  }

  export type StoreUpsertWithoutStore_ProductInput = {
    update: XOR<StoreUpdateWithoutStore_ProductInput, StoreUncheckedUpdateWithoutStore_ProductInput>
    create: XOR<StoreCreateWithoutStore_ProductInput, StoreUncheckedCreateWithoutStore_ProductInput>
  }

  export type StoreUpdateWithoutStore_ProductInput = {
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUpdateManyWithoutStoreNestedInput
    Stamp?: StampUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_ownerIdToStore_Owner?: Store_OwnerUpdateOneRequiredWithoutStore_Store_ownerIdToStore_OwnerNestedInput
    Tour?: TourUpdateOneWithoutStoreNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Review?: Store_ReviewUpdateOneWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutStore_ProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    ownerId?: IntFieldUpdateOperationsInput | number
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    Stamp?: StampUncheckedUpdateManyWithoutStoreNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUncheckedUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateOneWithoutStoreNestedInput
  }

  export type StampCreateWithoutTourInput = {
    randNum?: string | null
    timestamp?: Date | string | null
    store?: string | null
    tour?: string | null
    Customer?: CustomerCreateNestedOneWithoutStampInput
    Store?: StoreCreateNestedOneWithoutStampInput
  }

  export type StampUncheckedCreateWithoutTourInput = {
    id?: number
    randNum?: string | null
    timestamp?: Date | string | null
    customerId?: number | null
    storeId?: number | null
    store?: string | null
    tour?: string | null
  }

  export type StampCreateOrConnectWithoutTourInput = {
    where: StampWhereUniqueInput
    create: XOR<StampCreateWithoutTourInput, StampUncheckedCreateWithoutTourInput>
  }

  export type StampCreateManyTourInputEnvelope = {
    data: Enumerable<StampCreateManyTourInput>
    skipDuplicates?: boolean
  }

  export type StoreCreateWithoutTourInput = {
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    x?: string | null
    y?: string | null
    Customer?: CustomerCreateNestedManyWithoutStoreInput
    Stamp?: StampCreateNestedManyWithoutStoreInput
    Store_Owner_Store_ownerIdToStore_Owner: Store_OwnerCreateNestedOneWithoutStore_Store_ownerIdToStore_OwnerInput
    Store_Like?: Store_LikeCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutTourInput = {
    id?: number
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    ownerId: number
    x?: string | null
    y?: string | null
    Customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    Stamp?: StampUncheckedCreateNestedManyWithoutStoreInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuUncheckedCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeUncheckedCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductUncheckedCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewUncheckedCreateNestedOneWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutTourInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutTourInput, StoreUncheckedCreateWithoutTourInput>
  }

  export type StoreCreateManyTourInputEnvelope = {
    data: Enumerable<StoreCreateManyTourInput>
    skipDuplicates?: boolean
  }

  export type StampUpsertWithWhereUniqueWithoutTourInput = {
    where: StampWhereUniqueInput
    update: XOR<StampUpdateWithoutTourInput, StampUncheckedUpdateWithoutTourInput>
    create: XOR<StampCreateWithoutTourInput, StampUncheckedCreateWithoutTourInput>
  }

  export type StampUpdateWithWhereUniqueWithoutTourInput = {
    where: StampWhereUniqueInput
    data: XOR<StampUpdateWithoutTourInput, StampUncheckedUpdateWithoutTourInput>
  }

  export type StampUpdateManyWithWhereWithoutTourInput = {
    where: StampScalarWhereInput
    data: XOR<StampUpdateManyMutationInput, StampUncheckedUpdateManyWithoutStampInput>
  }

  export type StoreUpsertWithWhereUniqueWithoutTourInput = {
    where: StoreWhereUniqueInput
    update: XOR<StoreUpdateWithoutTourInput, StoreUncheckedUpdateWithoutTourInput>
    create: XOR<StoreCreateWithoutTourInput, StoreUncheckedCreateWithoutTourInput>
  }

  export type StoreUpdateWithWhereUniqueWithoutTourInput = {
    where: StoreWhereUniqueInput
    data: XOR<StoreUpdateWithoutTourInput, StoreUncheckedUpdateWithoutTourInput>
  }

  export type StoreUpdateManyWithWhereWithoutTourInput = {
    where: StoreScalarWhereInput
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyWithoutStoreInput>
  }

  export type StoreScalarWhereInput = {
    AND?: Enumerable<StoreScalarWhereInput>
    OR?: Enumerable<StoreScalarWhereInput>
    NOT?: Enumerable<StoreScalarWhereInput>
    id?: IntFilter | number
    storeName?: StringFilter | string
    description?: StringNullableFilter | string | null
    officeHour?: StringNullableFilter | string | null
    dayOff?: StringNullableFilter | string | null
    homepage?: StringNullableFilter | string | null
    image?: StringNullableFilter | string | null
    category?: StringNullableListFilter
    ownerId?: IntFilter | number
    tourId?: IntNullableFilter | number | null
    x?: StringNullableFilter | string | null
    y?: StringNullableFilter | string | null
  }

  export type StoreCreateWithoutStore_ReviewInput = {
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    x?: string | null
    y?: string | null
    Customer?: CustomerCreateNestedManyWithoutStoreInput
    Stamp?: StampCreateNestedManyWithoutStoreInput
    Store_Owner_Store_ownerIdToStore_Owner: Store_OwnerCreateNestedOneWithoutStore_Store_ownerIdToStore_OwnerInput
    Tour?: TourCreateNestedOneWithoutStoreInput
    Store_Like?: Store_LikeCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductCreateNestedManyWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutStore_ReviewInput = {
    id?: number
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    ownerId: number
    tourId?: number | null
    x?: string | null
    y?: string | null
    Customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    Stamp?: StampUncheckedCreateNestedManyWithoutStoreInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuUncheckedCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeUncheckedCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutStore_ReviewInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStore_ReviewInput, StoreUncheckedCreateWithoutStore_ReviewInput>
  }

  export type CustomerCreateWithoutStore_ReviewInput = {
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    image?: string | null
    stampCount?: number
    couponCount?: number
    Alim_Customer?: Alim_CustomerCreateNestedManyWithoutCustomerInput
    Store?: StoreCreateNestedOneWithoutCustomerInput
    Delivery?: DeliveryCreateNestedManyWithoutCustomerInput
    Stamp?: StampCreateNestedManyWithoutCustomerInput
    Store_Like?: Store_LikeCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutStore_ReviewInput = {
    id?: number
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    storeId?: number | null
    image?: string | null
    stampCount?: number
    couponCount?: number
    Alim_Customer?: Alim_CustomerUncheckedCreateNestedManyWithoutCustomerInput
    Delivery?: DeliveryUncheckedCreateNestedManyWithoutCustomerInput
    Stamp?: StampUncheckedCreateNestedManyWithoutCustomerInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutStore_ReviewInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutStore_ReviewInput, CustomerUncheckedCreateWithoutStore_ReviewInput>
  }

  export type StoreUpsertWithoutStore_ReviewInput = {
    update: XOR<StoreUpdateWithoutStore_ReviewInput, StoreUncheckedUpdateWithoutStore_ReviewInput>
    create: XOR<StoreCreateWithoutStore_ReviewInput, StoreUncheckedCreateWithoutStore_ReviewInput>
  }

  export type StoreUpdateWithoutStore_ReviewInput = {
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUpdateManyWithoutStoreNestedInput
    Stamp?: StampUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_ownerIdToStore_Owner?: Store_OwnerUpdateOneRequiredWithoutStore_Store_ownerIdToStore_OwnerNestedInput
    Tour?: TourUpdateOneWithoutStoreNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUpdateManyWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutStore_ReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    ownerId?: IntFieldUpdateOperationsInput | number
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    Stamp?: StampUncheckedUpdateManyWithoutStoreNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUncheckedUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type CustomerUpsertWithoutStore_ReviewInput = {
    update: XOR<CustomerUpdateWithoutStore_ReviewInput, CustomerUncheckedUpdateWithoutStore_ReviewInput>
    create: XOR<CustomerCreateWithoutStore_ReviewInput, CustomerUncheckedCreateWithoutStore_ReviewInput>
  }

  export type CustomerUpdateWithoutStore_ReviewInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
    Alim_Customer?: Alim_CustomerUpdateManyWithoutCustomerNestedInput
    Store?: StoreUpdateOneWithoutCustomerNestedInput
    Delivery?: DeliveryUpdateManyWithoutCustomerNestedInput
    Stamp?: StampUpdateManyWithoutCustomerNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutStore_ReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
    Alim_Customer?: Alim_CustomerUncheckedUpdateManyWithoutCustomerNestedInput
    Delivery?: DeliveryUncheckedUpdateManyWithoutCustomerNestedInput
    Stamp?: StampUncheckedUpdateManyWithoutCustomerNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateWithoutAlim_CustomerInput = {
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    image?: string | null
    stampCount?: number
    couponCount?: number
    Store?: StoreCreateNestedOneWithoutCustomerInput
    Delivery?: DeliveryCreateNestedManyWithoutCustomerInput
    Stamp?: StampCreateNestedManyWithoutCustomerInput
    Store_Like?: Store_LikeCreateNestedManyWithoutCustomerInput
    Store_Review?: Store_ReviewCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAlim_CustomerInput = {
    id?: number
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    storeId?: number | null
    image?: string | null
    stampCount?: number
    couponCount?: number
    Delivery?: DeliveryUncheckedCreateNestedManyWithoutCustomerInput
    Stamp?: StampUncheckedCreateNestedManyWithoutCustomerInput
    Store_Like?: Store_LikeUncheckedCreateNestedManyWithoutCustomerInput
    Store_Review?: Store_ReviewUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAlim_CustomerInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAlim_CustomerInput, CustomerUncheckedCreateWithoutAlim_CustomerInput>
  }

  export type Alim_RequestCreateWithoutAlim_CustomerInput = {
    category: string
    content: string
    isMessage: boolean
    isKakao: boolean
    timestamp: Date | string
    Store_Owner: Store_OwnerCreateNestedOneWithoutAlim_RequestInput
  }

  export type Alim_RequestUncheckedCreateWithoutAlim_CustomerInput = {
    id?: number
    category: string
    content: string
    isMessage: boolean
    isKakao: boolean
    writerId: number
    timestamp: Date | string
  }

  export type Alim_RequestCreateOrConnectWithoutAlim_CustomerInput = {
    where: Alim_RequestWhereUniqueInput
    create: XOR<Alim_RequestCreateWithoutAlim_CustomerInput, Alim_RequestUncheckedCreateWithoutAlim_CustomerInput>
  }

  export type CustomerUpsertWithoutAlim_CustomerInput = {
    update: XOR<CustomerUpdateWithoutAlim_CustomerInput, CustomerUncheckedUpdateWithoutAlim_CustomerInput>
    create: XOR<CustomerCreateWithoutAlim_CustomerInput, CustomerUncheckedCreateWithoutAlim_CustomerInput>
  }

  export type CustomerUpdateWithoutAlim_CustomerInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
    Store?: StoreUpdateOneWithoutCustomerNestedInput
    Delivery?: DeliveryUpdateManyWithoutCustomerNestedInput
    Stamp?: StampUpdateManyWithoutCustomerNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutCustomerNestedInput
    Store_Review?: Store_ReviewUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAlim_CustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
    Delivery?: DeliveryUncheckedUpdateManyWithoutCustomerNestedInput
    Stamp?: StampUncheckedUpdateManyWithoutCustomerNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutCustomerNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type Alim_RequestUpsertWithoutAlim_CustomerInput = {
    update: XOR<Alim_RequestUpdateWithoutAlim_CustomerInput, Alim_RequestUncheckedUpdateWithoutAlim_CustomerInput>
    create: XOR<Alim_RequestCreateWithoutAlim_CustomerInput, Alim_RequestUncheckedCreateWithoutAlim_CustomerInput>
  }

  export type Alim_RequestUpdateWithoutAlim_CustomerInput = {
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isMessage?: BoolFieldUpdateOperationsInput | boolean
    isKakao?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    Store_Owner?: Store_OwnerUpdateOneRequiredWithoutAlim_RequestNestedInput
  }

  export type Alim_RequestUncheckedUpdateWithoutAlim_CustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isMessage?: BoolFieldUpdateOperationsInput | boolean
    isKakao?: BoolFieldUpdateOperationsInput | boolean
    writerId?: IntFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Alim_CustomerCreateWithoutAlim_RequestInput = {
    loginId: string
    name?: string | null
    phone: string
    Customer: CustomerCreateNestedOneWithoutAlim_CustomerInput
  }

  export type Alim_CustomerUncheckedCreateWithoutAlim_RequestInput = {
    id?: number
    loginId: string
    name?: string | null
    phone: string
    customerId: number
  }

  export type Alim_CustomerCreateOrConnectWithoutAlim_RequestInput = {
    where: Alim_CustomerWhereUniqueInput
    create: XOR<Alim_CustomerCreateWithoutAlim_RequestInput, Alim_CustomerUncheckedCreateWithoutAlim_RequestInput>
  }

  export type Alim_CustomerCreateManyAlim_RequestInputEnvelope = {
    data: Enumerable<Alim_CustomerCreateManyAlim_RequestInput>
    skipDuplicates?: boolean
  }

  export type Store_OwnerCreateWithoutAlim_RequestInput = {
    loginId: string
    password?: string | null
    store?: string | null
    director?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    detailAddress?: string | null
    licenseNumber?: string | null
    licenseImage: string
    authorized?: boolean | null
    termsAgree?: boolean | null
    marketingAgree?: boolean | null
    stampAuthorized?: boolean | null
    profileImage?: string | null
    Stamp_Request?: Stamp_RequestCreateNestedOneWithoutStore_OwnerInput
    Store_Store_ownerIdToStore_Owner?: StoreCreateNestedOneWithoutStore_Owner_Store_ownerIdToStore_OwnerInput
    Store_Store_Owner_storeIdToStore?: StoreCreateNestedOneWithoutStore_Owner_Store_Owner_storeIdToStoreInput
  }

  export type Store_OwnerUncheckedCreateWithoutAlim_RequestInput = {
    id?: number
    loginId: string
    password?: string | null
    store?: string | null
    director?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    detailAddress?: string | null
    licenseNumber?: string | null
    licenseImage: string
    authorized?: boolean | null
    termsAgree?: boolean | null
    marketingAgree?: boolean | null
    storeId?: number | null
    stampAuthorized?: boolean | null
    profileImage?: string | null
    Stamp_Request?: Stamp_RequestUncheckedCreateNestedOneWithoutStore_OwnerInput
    Store_Store_ownerIdToStore_Owner?: StoreUncheckedCreateNestedOneWithoutStore_Owner_Store_ownerIdToStore_OwnerInput
  }

  export type Store_OwnerCreateOrConnectWithoutAlim_RequestInput = {
    where: Store_OwnerWhereUniqueInput
    create: XOR<Store_OwnerCreateWithoutAlim_RequestInput, Store_OwnerUncheckedCreateWithoutAlim_RequestInput>
  }

  export type Alim_CustomerUpsertWithWhereUniqueWithoutAlim_RequestInput = {
    where: Alim_CustomerWhereUniqueInput
    update: XOR<Alim_CustomerUpdateWithoutAlim_RequestInput, Alim_CustomerUncheckedUpdateWithoutAlim_RequestInput>
    create: XOR<Alim_CustomerCreateWithoutAlim_RequestInput, Alim_CustomerUncheckedCreateWithoutAlim_RequestInput>
  }

  export type Alim_CustomerUpdateWithWhereUniqueWithoutAlim_RequestInput = {
    where: Alim_CustomerWhereUniqueInput
    data: XOR<Alim_CustomerUpdateWithoutAlim_RequestInput, Alim_CustomerUncheckedUpdateWithoutAlim_RequestInput>
  }

  export type Alim_CustomerUpdateManyWithWhereWithoutAlim_RequestInput = {
    where: Alim_CustomerScalarWhereInput
    data: XOR<Alim_CustomerUpdateManyMutationInput, Alim_CustomerUncheckedUpdateManyWithoutAlim_CustomerInput>
  }

  export type Store_OwnerUpsertWithoutAlim_RequestInput = {
    update: XOR<Store_OwnerUpdateWithoutAlim_RequestInput, Store_OwnerUncheckedUpdateWithoutAlim_RequestInput>
    create: XOR<Store_OwnerCreateWithoutAlim_RequestInput, Store_OwnerUncheckedCreateWithoutAlim_RequestInput>
  }

  export type Store_OwnerUpdateWithoutAlim_RequestInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    director?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseImage?: StringFieldUpdateOperationsInput | string
    authorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    termsAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stampAuthorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    Stamp_Request?: Stamp_RequestUpdateOneWithoutStore_OwnerNestedInput
    Store_Store_ownerIdToStore_Owner?: StoreUpdateOneWithoutStore_Owner_Store_ownerIdToStore_OwnerNestedInput
    Store_Store_Owner_storeIdToStore?: StoreUpdateOneWithoutStore_Owner_Store_Owner_storeIdToStoreNestedInput
  }

  export type Store_OwnerUncheckedUpdateWithoutAlim_RequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    director?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseImage?: StringFieldUpdateOperationsInput | string
    authorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    termsAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    stampAuthorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    Stamp_Request?: Stamp_RequestUncheckedUpdateOneWithoutStore_OwnerNestedInput
    Store_Store_ownerIdToStore_Owner?: StoreUncheckedUpdateOneWithoutStore_Owner_Store_ownerIdToStore_OwnerNestedInput
  }

  export type Store_OwnerCreateWithoutStamp_RequestInput = {
    loginId: string
    password?: string | null
    store?: string | null
    director?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    detailAddress?: string | null
    licenseNumber?: string | null
    licenseImage: string
    authorized?: boolean | null
    termsAgree?: boolean | null
    marketingAgree?: boolean | null
    stampAuthorized?: boolean | null
    profileImage?: string | null
    Alim_Request?: Alim_RequestCreateNestedManyWithoutStore_OwnerInput
    Store_Store_ownerIdToStore_Owner?: StoreCreateNestedOneWithoutStore_Owner_Store_ownerIdToStore_OwnerInput
    Store_Store_Owner_storeIdToStore?: StoreCreateNestedOneWithoutStore_Owner_Store_Owner_storeIdToStoreInput
  }

  export type Store_OwnerUncheckedCreateWithoutStamp_RequestInput = {
    id?: number
    loginId: string
    password?: string | null
    store?: string | null
    director?: string | null
    phone?: string | null
    email?: string | null
    address?: string | null
    detailAddress?: string | null
    licenseNumber?: string | null
    licenseImage: string
    authorized?: boolean | null
    termsAgree?: boolean | null
    marketingAgree?: boolean | null
    storeId?: number | null
    stampAuthorized?: boolean | null
    profileImage?: string | null
    Alim_Request?: Alim_RequestUncheckedCreateNestedManyWithoutStore_OwnerInput
    Store_Store_ownerIdToStore_Owner?: StoreUncheckedCreateNestedOneWithoutStore_Owner_Store_ownerIdToStore_OwnerInput
  }

  export type Store_OwnerCreateOrConnectWithoutStamp_RequestInput = {
    where: Store_OwnerWhereUniqueInput
    create: XOR<Store_OwnerCreateWithoutStamp_RequestInput, Store_OwnerUncheckedCreateWithoutStamp_RequestInput>
  }

  export type Store_OwnerUpsertWithoutStamp_RequestInput = {
    update: XOR<Store_OwnerUpdateWithoutStamp_RequestInput, Store_OwnerUncheckedUpdateWithoutStamp_RequestInput>
    create: XOR<Store_OwnerCreateWithoutStamp_RequestInput, Store_OwnerUncheckedCreateWithoutStamp_RequestInput>
  }

  export type Store_OwnerUpdateWithoutStamp_RequestInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    director?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseImage?: StringFieldUpdateOperationsInput | string
    authorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    termsAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stampAuthorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    Alim_Request?: Alim_RequestUpdateManyWithoutStore_OwnerNestedInput
    Store_Store_ownerIdToStore_Owner?: StoreUpdateOneWithoutStore_Owner_Store_ownerIdToStore_OwnerNestedInput
    Store_Store_Owner_storeIdToStore?: StoreUpdateOneWithoutStore_Owner_Store_Owner_storeIdToStoreNestedInput
  }

  export type Store_OwnerUncheckedUpdateWithoutStamp_RequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    director?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseImage?: StringFieldUpdateOperationsInput | string
    authorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    termsAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    stampAuthorized?: NullableBoolFieldUpdateOperationsInput | boolean | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    Alim_Request?: Alim_RequestUncheckedUpdateManyWithoutStore_OwnerNestedInput
    Store_Store_ownerIdToStore_Owner?: StoreUncheckedUpdateOneWithoutStore_Owner_Store_ownerIdToStore_OwnerNestedInput
  }

  export type CustomerCreateWithoutStore_LikeInput = {
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    image?: string | null
    stampCount?: number
    couponCount?: number
    Alim_Customer?: Alim_CustomerCreateNestedManyWithoutCustomerInput
    Store?: StoreCreateNestedOneWithoutCustomerInput
    Delivery?: DeliveryCreateNestedManyWithoutCustomerInput
    Stamp?: StampCreateNestedManyWithoutCustomerInput
    Store_Review?: Store_ReviewCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutStore_LikeInput = {
    id?: number
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    storeId?: number | null
    image?: string | null
    stampCount?: number
    couponCount?: number
    Alim_Customer?: Alim_CustomerUncheckedCreateNestedManyWithoutCustomerInput
    Delivery?: DeliveryUncheckedCreateNestedManyWithoutCustomerInput
    Stamp?: StampUncheckedCreateNestedManyWithoutCustomerInput
    Store_Review?: Store_ReviewUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutStore_LikeInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutStore_LikeInput, CustomerUncheckedCreateWithoutStore_LikeInput>
  }

  export type StoreCreateWithoutStore_LikeInput = {
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    x?: string | null
    y?: string | null
    Customer?: CustomerCreateNestedManyWithoutStoreInput
    Stamp?: StampCreateNestedManyWithoutStoreInput
    Store_Owner_Store_ownerIdToStore_Owner: Store_OwnerCreateNestedOneWithoutStore_Store_ownerIdToStore_OwnerInput
    Tour?: TourCreateNestedOneWithoutStoreInput
    Store_Menu?: Store_MenuCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewCreateNestedOneWithoutStoreInput
  }

  export type StoreUncheckedCreateWithoutStore_LikeInput = {
    id?: number
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    ownerId: number
    tourId?: number | null
    x?: string | null
    y?: string | null
    Customer?: CustomerUncheckedCreateNestedManyWithoutStoreInput
    Stamp?: StampUncheckedCreateNestedManyWithoutStoreInput
    Store_Menu?: Store_MenuUncheckedCreateNestedManyWithoutStoreInput
    Store_Notice?: Store_NoticeUncheckedCreateNestedManyWithoutStoreInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedCreateNestedOneWithoutStore_Store_Owner_storeIdToStoreInput
    Store_Product?: Store_ProductUncheckedCreateNestedManyWithoutStoreInput
    Store_Review?: Store_ReviewUncheckedCreateNestedOneWithoutStoreInput
  }

  export type StoreCreateOrConnectWithoutStore_LikeInput = {
    where: StoreWhereUniqueInput
    create: XOR<StoreCreateWithoutStore_LikeInput, StoreUncheckedCreateWithoutStore_LikeInput>
  }

  export type CustomerUpsertWithoutStore_LikeInput = {
    update: XOR<CustomerUpdateWithoutStore_LikeInput, CustomerUncheckedUpdateWithoutStore_LikeInput>
    create: XOR<CustomerCreateWithoutStore_LikeInput, CustomerUncheckedCreateWithoutStore_LikeInput>
  }

  export type CustomerUpdateWithoutStore_LikeInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
    Alim_Customer?: Alim_CustomerUpdateManyWithoutCustomerNestedInput
    Store?: StoreUpdateOneWithoutCustomerNestedInput
    Delivery?: DeliveryUpdateManyWithoutCustomerNestedInput
    Stamp?: StampUpdateManyWithoutCustomerNestedInput
    Store_Review?: Store_ReviewUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutStore_LikeInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
    Alim_Customer?: Alim_CustomerUncheckedUpdateManyWithoutCustomerNestedInput
    Delivery?: DeliveryUncheckedUpdateManyWithoutCustomerNestedInput
    Stamp?: StampUncheckedUpdateManyWithoutCustomerNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type StoreUpsertWithoutStore_LikeInput = {
    update: XOR<StoreUpdateWithoutStore_LikeInput, StoreUncheckedUpdateWithoutStore_LikeInput>
    create: XOR<StoreCreateWithoutStore_LikeInput, StoreUncheckedCreateWithoutStore_LikeInput>
  }

  export type StoreUpdateWithoutStore_LikeInput = {
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUpdateManyWithoutStoreNestedInput
    Stamp?: StampUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_ownerIdToStore_Owner?: Store_OwnerUpdateOneRequiredWithoutStore_Store_ownerIdToStore_OwnerNestedInput
    Tour?: TourUpdateOneWithoutStoreNestedInput
    Store_Menu?: Store_MenuUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUpdateOneWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutStore_LikeInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    ownerId?: IntFieldUpdateOperationsInput | number
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    Stamp?: StampUncheckedUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUncheckedUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUncheckedUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateOneWithoutStoreNestedInput
  }

  export type Alim_CustomerCreateManyCustomerInput = {
    id?: number
    loginId: string
    name?: string | null
    phone: string
    requestId: number
  }

  export type DeliveryCreateManyCustomerInput = {
    id?: number
    reward: string
    customer: string
    phone: string
    address: string
    detailAddress?: string | null
    message: string
    isGrant?: boolean | null
  }

  export type StampCreateManyCustomerInput = {
    id?: number
    randNum?: string | null
    timestamp?: Date | string | null
    storeId?: number | null
    store?: string | null
    tourId?: number | null
    tour?: string | null
  }

  export type Store_LikeCreateManyCustomerInput = {
    id?: number
    storeId: number
  }

  export type Store_ReviewCreateManyCustomerInput = {
    id?: number
    title?: string | null
    content: string
    image?: string | null
    timestamp: Date | string
    storeId: number
    writerName: string
  }

  export type Alim_CustomerUpdateWithoutCustomerInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    Alim_Request?: Alim_RequestUpdateOneRequiredWithoutAlim_CustomerNestedInput
  }

  export type Alim_CustomerUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    requestId?: IntFieldUpdateOperationsInput | number
  }

  export type Alim_CustomerUncheckedUpdateManyWithoutAlim_CustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    requestId?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryUpdateWithoutCustomerInput = {
    reward?: StringFieldUpdateOperationsInput | string
    customer?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isGrant?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeliveryUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    reward?: StringFieldUpdateOperationsInput | string
    customer?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isGrant?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type DeliveryUncheckedUpdateManyWithoutDeliveryInput = {
    id?: IntFieldUpdateOperationsInput | number
    reward?: StringFieldUpdateOperationsInput | string
    customer?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    detailAddress?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isGrant?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StampUpdateWithoutCustomerInput = {
    randNum?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    tour?: NullableStringFieldUpdateOperationsInput | string | null
    Store?: StoreUpdateOneWithoutStampNestedInput
    Tour?: TourUpdateOneWithoutStampNestedInput
  }

  export type StampUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    randNum?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    tour?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StampUncheckedUpdateManyWithoutStampInput = {
    id?: IntFieldUpdateOperationsInput | number
    randNum?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    tour?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Store_LikeUpdateWithoutCustomerInput = {
    Store?: StoreUpdateOneRequiredWithoutStore_LikeNestedInput
  }

  export type Store_LikeUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type Store_LikeUncheckedUpdateManyWithoutStore_LikeInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type Store_ReviewUpdateWithoutCustomerInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    writerName?: StringFieldUpdateOperationsInput | string
    Store?: StoreUpdateOneRequiredWithoutStore_ReviewNestedInput
  }

  export type Store_ReviewUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: IntFieldUpdateOperationsInput | number
    writerName?: StringFieldUpdateOperationsInput | string
  }

  export type Store_ReviewUncheckedUpdateManyWithoutStore_ReviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    storeId?: IntFieldUpdateOperationsInput | number
    writerName?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerCreateManyStoreInput = {
    id?: number
    loginId: string
    password: string
    name: string
    email: string
    phone: string
    termsAgree: boolean
    marketingAgree?: boolean | null
    image?: string | null
    stampCount?: number
    couponCount?: number
  }

  export type StampCreateManyStoreInput = {
    id?: number
    randNum?: string | null
    timestamp?: Date | string | null
    customerId?: number | null
    store?: string | null
    tourId?: number | null
    tour?: string | null
  }

  export type Store_LikeCreateManyStoreInput = {
    id?: number
    customerId: number
  }

  export type Store_MenuCreateManyStoreInput = {
    id?: number
    title?: string | null
    content?: string | null
    image?: string | null
  }

  export type Store_NoticeCreateManyStoreInput = {
    id?: number
    category?: string | null
    title?: string | null
    content?: string | null
    image?: string | null
    createdTime?: Date | string | null
  }

  export type Store_ProductCreateManyStoreInput = {
    id?: number
    category?: string | null
    name?: string | null
    price?: string | null
    discountPrice?: string | null
    url?: string | null
    image?: string | null
  }

  export type CustomerUpdateWithoutStoreInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
    Alim_Customer?: Alim_CustomerUpdateManyWithoutCustomerNestedInput
    Delivery?: DeliveryUpdateManyWithoutCustomerNestedInput
    Stamp?: StampUpdateManyWithoutCustomerNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutCustomerNestedInput
    Store_Review?: Store_ReviewUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
    Alim_Customer?: Alim_CustomerUncheckedUpdateManyWithoutCustomerNestedInput
    Delivery?: DeliveryUncheckedUpdateManyWithoutCustomerNestedInput
    Stamp?: StampUncheckedUpdateManyWithoutCustomerNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutCustomerNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    termsAgree?: BoolFieldUpdateOperationsInput | boolean
    marketingAgree?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    stampCount?: IntFieldUpdateOperationsInput | number
    couponCount?: IntFieldUpdateOperationsInput | number
  }

  export type StampUpdateWithoutStoreInput = {
    randNum?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    tour?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUpdateOneWithoutStampNestedInput
    Tour?: TourUpdateOneWithoutStampNestedInput
  }

  export type StampUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    randNum?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    tourId?: NullableIntFieldUpdateOperationsInput | number | null
    tour?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Store_LikeUpdateWithoutStoreInput = {
    Customer?: CustomerUpdateOneRequiredWithoutStore_LikeNestedInput
  }

  export type Store_LikeUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
  }

  export type Store_MenuUpdateWithoutStoreInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Store_MenuUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Store_MenuUncheckedUpdateManyWithoutStore_MenuInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Store_NoticeUpdateWithoutStoreInput = {
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Store_NoticeUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Store_NoticeUncheckedUpdateManyWithoutStore_NoticeInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Store_ProductUpdateWithoutStoreInput = {
    category?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Store_ProductUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Store_ProductUncheckedUpdateManyWithoutStore_ProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    discountPrice?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Alim_RequestCreateManyStore_OwnerInput = {
    id?: number
    category: string
    content: string
    isMessage: boolean
    isKakao: boolean
    timestamp: Date | string
  }

  export type Alim_RequestUpdateWithoutStore_OwnerInput = {
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isMessage?: BoolFieldUpdateOperationsInput | boolean
    isKakao?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    Alim_Customer?: Alim_CustomerUpdateManyWithoutAlim_RequestNestedInput
  }

  export type Alim_RequestUncheckedUpdateWithoutStore_OwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isMessage?: BoolFieldUpdateOperationsInput | boolean
    isKakao?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    Alim_Customer?: Alim_CustomerUncheckedUpdateManyWithoutAlim_RequestNestedInput
  }

  export type Alim_RequestUncheckedUpdateManyWithoutAlim_RequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isMessage?: BoolFieldUpdateOperationsInput | boolean
    isKakao?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StampCreateManyTourInput = {
    id?: number
    randNum?: string | null
    timestamp?: Date | string | null
    customerId?: number | null
    storeId?: number | null
    store?: string | null
    tour?: string | null
  }

  export type StoreCreateManyTourInput = {
    id?: number
    storeName: string
    description?: string | null
    officeHour?: string | null
    dayOff?: string | null
    homepage?: string | null
    image?: string | null
    category?: StoreCreatecategoryInput | Enumerable<string>
    ownerId: number
    x?: string | null
    y?: string | null
  }

  export type StampUpdateWithoutTourInput = {
    randNum?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    tour?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUpdateOneWithoutStampNestedInput
    Store?: StoreUpdateOneWithoutStampNestedInput
  }

  export type StampUncheckedUpdateWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    randNum?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    storeId?: NullableIntFieldUpdateOperationsInput | number | null
    store?: NullableStringFieldUpdateOperationsInput | string | null
    tour?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreUpdateWithoutTourInput = {
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUpdateManyWithoutStoreNestedInput
    Stamp?: StampUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_ownerIdToStore_Owner?: Store_OwnerUpdateOneRequiredWithoutStore_Store_ownerIdToStore_OwnerNestedInput
    Store_Like?: Store_LikeUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUpdateOneWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateWithoutTourInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    ownerId?: IntFieldUpdateOperationsInput | number
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
    Customer?: CustomerUncheckedUpdateManyWithoutStoreNestedInput
    Stamp?: StampUncheckedUpdateManyWithoutStoreNestedInput
    Store_Like?: Store_LikeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Menu?: Store_MenuUncheckedUpdateManyWithoutStoreNestedInput
    Store_Notice?: Store_NoticeUncheckedUpdateManyWithoutStoreNestedInput
    Store_Owner_Store_Owner_storeIdToStore?: Store_OwnerUncheckedUpdateOneWithoutStore_Store_Owner_storeIdToStoreNestedInput
    Store_Product?: Store_ProductUncheckedUpdateManyWithoutStoreNestedInput
    Store_Review?: Store_ReviewUncheckedUpdateOneWithoutStoreNestedInput
  }

  export type StoreUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    officeHour?: NullableStringFieldUpdateOperationsInput | string | null
    dayOff?: NullableStringFieldUpdateOperationsInput | string | null
    homepage?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StoreUpdatecategoryInput | Enumerable<string>
    ownerId?: IntFieldUpdateOperationsInput | number
    x?: NullableStringFieldUpdateOperationsInput | string | null
    y?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Alim_CustomerCreateManyAlim_RequestInput = {
    id?: number
    loginId: string
    name?: string | null
    phone: string
    customerId: number
  }

  export type Alim_CustomerUpdateWithoutAlim_RequestInput = {
    loginId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    Customer?: CustomerUpdateOneRequiredWithoutAlim_CustomerNestedInput
  }

  export type Alim_CustomerUncheckedUpdateWithoutAlim_RequestInput = {
    id?: IntFieldUpdateOperationsInput | number
    loginId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}